<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux磁盘分区与挂载</title>
    <link href="/2024/04/14/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E4%B8%8E%E6%8C%82%E8%BD%BD/"/>
    <url>/2024/04/14/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E4%B8%8E%E6%8C%82%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux磁盘分区与挂载"><a href="#Linux磁盘分区与挂载" class="headerlink" title="Linux磁盘分区与挂载"></a>Linux磁盘分区与挂载</h1><h2 id="1-lsblk查看当前块设备"><a href="#1-lsblk查看当前块设备" class="headerlink" title="1.lsblk查看当前块设备"></a>1.lsblk查看当前块设备</h2><p><strong>找到没有分区和挂载的磁盘sda</strong></p><p><img src="/img/courseimage-20240410042212136.png" alt="image-20240410042212136"></p><h2 id="2-使用-fdisk-对磁盘进行分区"><a href="#2-使用-fdisk-对磁盘进行分区" class="headerlink" title="2.使用 fdisk 对磁盘进行分区"></a>2.<strong>使用 fdisk 对磁盘进行分区</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">fdisk /dev/sda</span><br></code></pre></td></tr></table></figure><p><code>fdisk</code> 命令提供了一个交互式界面，允许用户执行以下任务：</p><ul><li>创建分区（<code>n</code>）</li><li>删除分区（<code>d</code>）</li><li>调整分区大小（<code>r</code>）</li><li>设置分区类型（<code>t</code>）</li><li>保存写入分区表（<code>w</code>）</li><li>退出（<code>q</code>）</li></ul><p><strong>输入n创建分区，剩下直接enter确认（默认分为一个区）</strong></p><img src="/img/courseimage-20240410042235008.png" alt="image-20240410042235008" style="zoom:67%;" /><p><img src="/img/courseimage-20240410042246880.png" alt="image-20240410042246880"></p><p><strong>再使用lsblk命令可以看到分区已完成</strong></p><p><img src="/img/courseimage-20240410042437772.png" alt="image-20240410042437772"></p><h2 id="3-格式化分区"><a href="#3-格式化分区" class="headerlink" title="3.格式化分区"></a>3.格式化分区</h2><p><strong>查看 <code>/dev/sdb1</code> 分区的类型，可以使用以下命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">df</span> -T /dev/sdc1</span><br>Filesystem     Type 1K-blocks  Used Available Use% Mounted on<br>/dev/sdc1      ext4  65739308    44  62367488   1% /data<br></code></pre></td></tr></table></figure><p><strong>要将 <code>/dev/sda1</code> 分区格式化为 ext4 文件系统，可以使用以下命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mkfs.ext4 /dev/sda1</span><br></code></pre></td></tr></table></figure><p><img src="/img/courseimage-20240410042528027.png" alt="image-20240410042528027"></p><h2 id="4-挂载分区"><a href="#4-挂载分区" class="headerlink" title="4.挂载分区"></a>4.挂载分区</h2><p><strong>先创建一个&#x2F;data目录</strong></p><p><img src="/img/courseimage-20240410042744611.png" alt="image-20240410042744611"></p><p><strong>然后执行命令挂载分区</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mount /dev/sda1 /data</span> <br></code></pre></td></tr></table></figure><h2 id="5-设置永久挂载"><a href="#5-设置永久挂载" class="headerlink" title="5.设置永久挂载"></a>5.设置永久挂载</h2><p> <strong>获取UUID</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo blkid /dev/sda1</span><br>/dev/sda1: UUID=&quot;deb8b33b-c908-4dbc-85a5-311727079736&quot; BLOCK_SIZE=&quot;4096&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;d91cf2eb-01&quot;<br></code></pre></td></tr></table></figure><p><strong>打开 <code>/etc/fstab</code> ，写入<code>UUID=deb8b33b-c908-4dbc-85a5-311727079736     /data   ext4   defaults   0   2</code> 实现永久挂载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/fstab</span>    <br>UUID=deb8b33b-c908-4dbc-85a5-311727079736     /data   ext4   defaults   0   2<br>UUID=c473537c-547e-48f4-b2ca-a2bc4e0d2f2e     /data   ext4   defaults   0   2<br></code></pre></td></tr></table></figure><h2 id="6-检查"><a href="#6-检查" class="headerlink" title="6.检查"></a>6.检查</h2><p><strong>使用<code>df -h</code>可以检查磁盘挂载是否成功</strong></p><p><img src="/img/courseimage-20240410210902334.png" alt="image-20240410210902334"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>服务器运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器添加Swap交换空间</title>
    <link href="/2024/04/14/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B7%BB%E5%8A%A0Swap%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/"/>
    <url>/2024/04/14/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B7%BB%E5%8A%A0Swap%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux服务器添加Swap交换空间"><a href="#Linux服务器添加Swap交换空间" class="headerlink" title="Linux服务器添加Swap交换空间"></a>Linux服务器添加Swap交换空间</h1><h3 id="演示环境"><a href="#演示环境" class="headerlink" title="演示环境"></a>演示环境</h3><ul><li>Ubuntu 22.04</li></ul><h3 id="Swap空间简介"><a href="#Swap空间简介" class="headerlink" title="Swap空间简介"></a>Swap空间简介</h3><p>Swap空间是一种虚拟内存空间，用于暂时存储操作系统不需要的数据，以便释放物理内存供其他程序使用。在Linux系统中，Swap空间通常是一个磁盘分区或者一个特殊的文件，用于扩展系统的虚拟内存空间。当系统的物理内存不足时，操作系统会将一部分内存中的数据移到Swap空间中，以释放物理内存。</p><p><strong>由于 Swap 空间位于硬盘上，因此访问速度较慢。</strong></p><h2 id="1-查看当前内存与swap"><a href="#1-查看当前内存与swap" class="headerlink" title="1.查看当前内存与swap"></a>1.查看当前内存与swap</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ free -m<br>               total        used        free      shared  buff/cache   available<br>Mem:             883         305         219           3         359         428<br>Swap:              0           0           0<br></code></pre></td></tr></table></figure><h3 id="检查-Swap-空间"><a href="#检查-Swap-空间" class="headerlink" title="检查 Swap 空间"></a>检查 Swap 空间</h3><ol><li>执行以下命令检查 Swap 空间是否存在：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">swapon -s<br></code></pre></td></tr></table></figure><p>如果输出为空，则表示没有 Swap 空间。</p><h2 id="2-创建-Swap-分区"><a href="#2-创建-Swap-分区" class="headerlink" title="2.创建 Swap 分区"></a>2.创建 Swap 分区</h2><ol><li><p>使用 <code>dd</code> 命令创建 2GB 的 Swap 分区（可根据服务器配置调整大小：Swap 空间的大小应根据服务器的实际内存和使用情况进行调整。一般来说，Swap 空间的大小应为实际内存的 1-2 倍。</p><p>使用 <code>if=/dev/zero</code> 创建 Swap 分区的原因是：</p><ul><li>它会创建一个包含零字节的文件，这对于 Swap 分区至关重要，因为 Swap 分区必须包含已知的干净数据。</li><li><code>/dev/zero</code> 是一个特殊文件，它会不断生成零字节，这意味着您可以创建任意大小的 Swap 分区。</li></ul><p>使用 <code>if=/dev/zero</code> 可以确保 Swap 分区从一开始就包含干净的数据，并且可以创建任意大小的 Swap 分区。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/mnt/swap bs=1M count=2048<br></code></pre></td></tr></table></figure><ol start="2"><li>设置 Swap 分区文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkswap /mnt/swap<br></code></pre></td></tr></table></figure><ol start="3"><li>启用 Swap：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">swapon /mnt/swap<br></code></pre></td></tr></table></figure><h2 id="3-启动时自动挂载Swap-分区"><a href="#3-启动时自动挂载Swap-分区" class="headerlink" title="3.启动时自动挂载Swap 分区"></a>3.启动时自动挂载Swap 分区</h2><ol><li>编辑 <code>/etc/fstab</code> 文件，添加以下行：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/mnt/swap swap swap defaults 0 0<br></code></pre></td></tr></table></figure><ul><li><code>/mnt/swap</code>：Swap 分区的挂载点。</li><li><code>swap</code>：指定该分区是 Swap 分区。</li><li><code>swap</code>：指定该分区的文件系统类型是 Swap。</li><li><code>defaults</code>：使用 Swap 分区的默认选项。</li><li><code>0</code>：指定该 Swap 分区在启动时不进行检查。</li><li><code>0</code>：指定该 Swap 分区在启动时不进行转储。</li></ul><h2 id="4-检查swap空间"><a href="#4-检查swap空间" class="headerlink" title="4.检查swap空间"></a>4.检查swap空间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ swapon -s<br>Filename                                Type            Size            Used            Priority<br>/mnt/swap                               file            2097148         0               -2<br>$ free -h<br>               total        used        free      shared  buff/cache   available<br>Mem:           883Mi       280Mi       157Mi       3.0Mi       445Mi       450Mi<br>Swap:          2.0Gi          0B       2.0Gi                                  <br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>服务器运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker compose管理</title>
    <link href="/2024/04/07/Docker-compose%E7%AE%A1%E7%90%86/"/>
    <url>/2024/04/07/Docker-compose%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。允许使用 YAML 文件来配置应用程序的服务,然后使用单个命令部署和启动所有服务。</p><ol><li><p><strong>YAML 配置文件</strong>:</p><ul><li><p>Docker Compose 使用 YAML 文件来定义应用程序的服务。YAML 文件包含服务名称、镜像、端口映射、数据卷等配置信息。</p></li><li><p>例如,一个包含 Web 服务和数据库服务的应用程序的 YAML 文件可能如下所示:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span> <br>    <span class="hljs-attr">volumes:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">.:/code</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>环境变量和配置管理</strong>:</p><ul><li>Docker Compose 支持通过环境变量来管理配置信息,如数据库连接字符串、API 密钥等。</li><li>可以在 YAML 文件中使用 <code>$&#123;VARIABLE&#125;</code> 语法引用环境变量。</li><li>这使得在不同的环境(如开发、测试、生产)中部署应用程序时,可以轻松地修改配置信息。</li></ul></li><li><p><strong>网络和依赖管理</strong>:</p><ul><li>Docker Compose 会自动创建一个虚拟网络,并将应用程序的所有服务连接到该网络上。</li><li>服务之间可以通过服务名称进行相互通信,无需知道具体的 IP 地址。</li><li>您还可以定义服务依赖关系,确保在启动某个服务之前,其依赖的其他服务已经启动。</li></ul></li><li><p><strong>扩展和缩容</strong>:</p><ul><li>Docker Compose 支持轻松扩展和缩减应用程序的规模。</li><li>您可以使用 <code>docker-compose scale</code> 命令来增加或减少某个服务的容器数量。</li></ul></li></ol><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具:"></a><strong>命令行工具</strong>:</h2><ul><li>Docker Compose 提供了一个命令行工具 <code>docker-compose</code>。使用该工具可以快速启动、停止和管理应用程序的服务。</li></ul><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>docker-compose up</code></td><td>启动应用程序的所有服务</td><td><code>docker-compose up -d</code> (以后台模式启动)</td></tr><tr><td><code>docker-compose down</code></td><td>停止并删除应用程序的所有服务</td><td><code>docker-compose down</code></td></tr><tr><td><code>docker-compose start</code></td><td>启动已停止的服务</td><td><code>docker-compose start web db</code> (启动 web 和 db 服务)</td></tr><tr><td><code>docker-compose stop</code></td><td>停止正在运行的服务</td><td><code>docker-compose stop web</code> (停止 web 服务)</td></tr><tr><td><code>docker-compose ps</code></td><td>列出应用程序中正在运行的容器</td><td><code>docker-compose ps</code></td></tr><tr><td><code>docker-compose build</code></td><td>构建或重新构建服务的镜像</td><td><code>docker-compose build --no-cache web</code> (不使用缓存构建 web 服务)</td></tr><tr><td><code>docker-compose logs</code></td><td>查看服务的日志输出</td><td><code>docker-compose logs -f web</code> (实时查看 web 服务的日志)</td></tr><tr><td><code>docker-compose exec</code></td><td>在运行的容器中执行命令</td><td><code>docker-compose exec web bash</code> (在 web 容器中执行 bash 命令)</td></tr><tr><td><code>docker-compose scale</code></td><td>扩展或缩减服务的容器数量</td><td><code>docker-compose scale web=3 db=2</code> (将 web 服务扩展到 3 个容器, db 服务扩展到 2 个容器)</td></tr></tbody></table><h2 id="docker-compose-yml文件编写"><a href="#docker-compose-yml文件编写" class="headerlink" title="docker-compose.yml文件编写"></a><code>docker-compose.yml</code>文件编写</h2><ol><li><h3 id="版本声明"><a href="#版本声明" class="headerlink" title="版本声明:"></a><strong>版本声明</strong>:</h3><ul><li>每个 YAML 文件都需要以 <code>version</code> 关键字开头,指定所使用的 Docker Compose 版本号。常见的版本号有 <code>&#39;2&#39;</code>、<code>&#39;3&#39;</code> 和 <code>&#39;3.x&#39;</code>。</li></ul></li><li><h3 id="services-部分"><a href="#services-部分" class="headerlink" title="services 部分:"></a><strong>services 部分</strong>:</h3><ul><li><code>services</code> 是 YAML 文件的核心部分,用于定义应用程序的各个服务。</li><li>每个服务都有一个唯一的名称,并包含以下常见的配置项:<ul><li><code>image</code>: 指定运行该服务的 Docker 镜像名称。</li><li><code>build</code>: 如果没有现成的镜像,可以指定构建该服务的 Dockerfile 路径。</li><li><code>ports</code>: 定义服务对外暴露的端口映射,格式为 <code>&quot;host_port:container_port&quot;</code>。</li><li><code>environment</code>: 设置服务运行时的环境变量。</li><li><code>volumes</code>: 定义数据卷,用于持久化服务产生的数据。</li><li><code>depends_on</code>: 指定该服务依赖的其他服务,确保先启动依赖服务。</li><li><code>networks</code>: 将服务连接到指定的网络。</li></ul></li></ul></li><li><h3 id="volumes-和-networks-部分"><a href="#volumes-和-networks-部分" class="headerlink" title="volumes 和 networks 部分:"></a><strong>volumes 和 networks 部分</strong>:</h3><ul><li><code>volumes</code> 部分用于定义数据卷,可以被多个服务共享使用。</li><li><code>networks</code> 部分用于定义虚拟网络,服务之间通过网络名称进行通信。</li></ul></li><li><h3 id="示例配置文件"><a href="#示例配置文件" class="headerlink" title="示例配置文件:"></a><strong>示例配置文件</strong>:</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./html:/usr/share/nginx/html</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">frontend</span><br>  <br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">password</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db-data:/var/lib/mysql</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span><br>      <br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">db-data:</span><br>    <br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">frontend:</span><br>  <span class="hljs-attr">backend:</span><br></code></pre></td></tr></table></figure><ul><li>该配置文件定义了一个 Web 服务和一个 MySQL 数据库服务,并为它们创建了前端和后端两个网络。</li></ul></li></ol><p>编写 Docker Compose YAML 配置文件时,需要注意服务之间的依赖关系、数据卷和网络的定义,以确保应用程序能够正确部署和运行。</p><h2 id="Dockerfile编写"><a href="#Dockerfile编写" class="headerlink" title="Dockerfile编写"></a>Dockerfile编写</h2><h3 id="Dockerfile中的主要命令"><a href="#Dockerfile中的主要命令" class="headerlink" title="Dockerfile中的主要命令:"></a>Dockerfile中的主要命令:</h3><ol><li><h3 id="FROM-指令"><a href="#FROM-指令" class="headerlink" title="FROM 指令"></a><strong>FROM 指令</strong></h3></li></ol><p>用于指定基础镜像,必须为Dockerfile的第一条指令。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">14</span>-alpine<br></code></pre></td></tr></table></figure><p>上例中,基础镜像为node:14-alpine。</p><ol start="2"><li><h4 id="RUN-指令"><a href="#RUN-指令" class="headerlink" title="RUN 指令"></a><strong>RUN 指令</strong></h4></li></ol><p>用于在镜像中执行指定的命令。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache tzdata &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">cp</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone</span><br></code></pre></td></tr></table></figure><p>上例中,先使用apk包管理器安装tzdata时区数据包,将上海时区复制为本地时区,并写入时区配置文件。</p><ol start="3"><li><h4 id="COPY-指令"><a href="#COPY-指令" class="headerlink" title="COPY 指令"></a><strong>COPY 指令</strong></h4></li></ol><p>用于将文件或目录从构建环境复制到镜像中。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span><br></code></pre></td></tr></table></figure><p>上例中,将当前目录下的所有文件复制到镜像的&#x2F;app目录下。</p><ol start="4"><li><h4 id="ADD-指令"><a href="#ADD-指令" class="headerlink" title="ADD 指令"></a><strong>ADD 指令</strong></h4></li></ol><p>类似于COPY,但ADD还支持从URL获取资源和自动解压缩等功能。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ADD</span><span class="language-bash"> https://example.com/app.tgz /app/</span><br></code></pre></td></tr></table></figure><p>上例从URL下载app.tgz包并解压到&#x2F;app目录下。</p><ol start="5"><li><h4 id="CMD-指令"><a href="#CMD-指令" class="headerlink" title="CMD 指令"></a><strong>CMD 指令</strong></h4></li></ol><p>用于设置容器启动时执行的默认命令。</p><p><strong>Dockerfile中只能有一条CMD指令。如果列出多个CMD，则只有最后一个CMD才会生效。</strong></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-comment">#格式</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] 　　　　<span class="hljs-comment">#使用 exec 执行，推荐方式；</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2 　　　　　　　　<span class="hljs-comment">#shell中执行 ( /bin/sh )，提供给需要交互的应用；</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;app.js&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>上例中,容器启动时执行node app.js命令。</p><ol start="6"><li><h4 id="ENTRYPOINT-指令"><a href="#ENTRYPOINT-指令" class="headerlink" title="ENTRYPOINT 指令"></a><strong>ENTRYPOINT 指令</strong></h4></li></ol><p>也用于设置容器入口,但其优先级比CMD高。</p><p>CMD指令指定的容器启动时命令可以被docker run指定的命令覆盖，ENTRYPOINT指令指定的命令不能被覆盖。</p><p>CMD与ENTRYPOINT同时存在时，CMD指令可以为ENTRYPOINT指令设置默认参数。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;app.js&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>上例中,node为入口命令,app.js为默认参数。</p><ol start="7"><li><h4 id="ENV-指令"><a href="#ENV-指令" class="headerlink" title="ENV 指令"></a><strong>ENV 指令</strong></h4></li></ol><p>用于设置环境变量。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ENV</span> NODE_ENV=production<br></code></pre></td></tr></table></figure><p>上例设置NODE_ENV环境变量为production。</p><ol start="8"><li><h4 id="WORKDIR-指令"><a href="#WORKDIR-指令" class="headerlink" title="WORKDIR 指令"></a><strong>WORKDIR 指令</strong></h4></li></ol><p>用于设置工作目录,类似于bash的cd命令。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br></code></pre></td></tr></table></figure><p>上例设置工作目录为&#x2F;app。</p><ol start="9"><li><h4 id="EXPOSE-指令"><a href="#EXPOSE-指令" class="headerlink" title="EXPOSE 指令"></a><strong>EXPOSE 指令</strong></h4></li></ol><p>用于告诉Docker容器将要监听的端口。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>上例将暴露容器的8080端口。</p><ol start="10"><li><h4 id="VOLUME-指令"><a href="#VOLUME-指令" class="headerlink" title="VOLUME 指令"></a><strong>VOLUME 指令</strong></h4></li></ol><p>用于创建挂载点,绕过联合文件系统,用于持久化存储。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>上例在&#x2F;data创建一个挂载点。</p><ol start="11"><li><h4 id="USER-指令"><a href="#USER-指令" class="headerlink" title="USER 指令"></a><strong>USER 指令</strong></h4></li></ol><p>用于指定运行容器的用户。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">USER</span> www<br></code></pre></td></tr></table></figure><p>设置用户为www用户。</p><ol start="12"><li><h4 id="ARG-指令"><a href="#ARG-指令" class="headerlink" title="ARG 指令"></a><strong>ARG 指令</strong></h4></li></ol><p>用于指定构建镜像时的变量值。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ARG</span> VERSION=<span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>设置VERSION变量默认为1.0。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ARG</span> VERSION<br><span class="hljs-keyword">ENV</span> APP_VERSION=$VERSION<br></code></pre></td></tr></table></figure><p>也可以将ARG变量的值赋给ENV环境变量。</p><ol start="13"><li><h4 id="LABEL-指令"><a href="#LABEL-指令" class="headerlink" title="LABEL 指令"></a><strong>LABEL 指令</strong></h4></li></ol><p>用于为镜像添加元数据标签。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;alice@example.com&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> description=<span class="hljs-string">&quot;This is a Node.js app&quot;</span></span><br></code></pre></td></tr></table></figure><ol start="14"><li><h4 id="SHELL-指令"><a href="#SHELL-指令" class="headerlink" title="SHELL 指令"></a><strong>SHELL 指令</strong></h4></li></ol><p>用于设置执行命令使用的shell。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">SHELL</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>上例设置使用bash执行命令,并使用-c选项允许从字符串读取命令。</p><h4 id="示例Dockerfile："><a href="#示例Dockerfile：" class="headerlink" title="示例Dockerfile："></a>示例Dockerfile：</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># 使用基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-comment"># 添加作者信息</span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;yourname&quot;</span></span><br><br><span class="hljs-comment"># 在镜像中安装依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span><br><span class="language-bash">    package1 \</span><br><span class="language-bash">    package2 \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 复制文件到镜像中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><br><span class="hljs-comment"># 容器启动时执行的命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="构建镜像："><a href="#构建镜像：" class="headerlink" title="构建镜像："></a>构建镜像：</h3><p>在包含Dockerfile的目录中运行以下命令构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t myimage .<br></code></pre></td></tr></table></figure><h3 id="运行容器："><a href="#运行容器：" class="headerlink" title="运行容器："></a>运行容器：</h3><p>使用构建的镜像启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 8080:8080 myimage<br></code></pre></td></tr></table></figure><h2 id="Dockerfile与docker-compose配合使用"><a href="#Dockerfile与docker-compose配合使用" class="headerlink" title="Dockerfile与docker-compose配合使用"></a>Dockerfile与docker-compose配合使用</h2><p>Dockerfile 和 docker-compose.yml 可以很好地协同工作,实现自动化构建和编排容器化应用。</p><ol><li><strong>编写 Dockerfile</strong></li></ol><p>首先,根据应用需求编写 Dockerfile,定义如何构建应用镜像。例如:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:centos7<br><br><span class="hljs-comment"># 从centos基础镜像构建</span><br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-string">&quot;/tmp&quot;</span></span><br><br><span class="hljs-comment"># 这里远程下载太慢了 我直接本地弄得。大家可以使用wget来进行远程下载</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> nginx-1.17.5.tar.gz /tmp</span><br><br><span class="hljs-comment"># 添加nginx用户</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> useradd -M -s /sbin/nologin nginx</span><br><br><span class="hljs-comment"># 安装相关依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash">  yum -y install gcc*  make pcre-devel zlib-devel openssl openssl-devel libxslt-devel gd gd-devel GeoIP GeoIP-devel pcre pcre-devel \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">cd</span> nginx-1.17.5 \</span><br><span class="language-bash">    &amp;&amp; ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-file-aio --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_xslt_module --with-http_image_filter_module --with-http_geoip_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_auth_request_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_stub_status_module &amp;&amp; make &amp;&amp; make install \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello aoppp.com&quot;</span> &gt; /usr/local/nginx/html/index.html</span><br><br><span class="hljs-comment"># 表示对外期望暴露得端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-comment"># 启动nginx 将nginx主进程 pid为1 nginx一旦挂掉那么docker容器就会直接退出</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/usr/local/nginx/sbin/nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>这个 Dockerfile 基于 node:14 镜像,安装 npm 依赖,复制应用代码,并配置启动命令。</p><ol start="2"><li><h3 id="编写-docker-compose-yml-文件"><a href="#编写-docker-compose-yml-文件" class="headerlink" title="编写 docker-compose.yml 文件"></a><strong>编写 docker-compose.yml 文件</strong></h3></li></ol><p>然后,在项目目录下创建 docker-compose.yml 文件,定义需要的服务、网络和数据卷等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./nginx</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./html:/usr/share/nginx/html</span><br>      <br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./db</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">password</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db-data:/var/lib/mysql</span><br></code></pre></td></tr></table></figure><p>上面的配置,定义了一个名为 app 的服务,使用当前目录下的 Dockerfile 构建镜像,映射端口 3000,挂载本地代码目录作为数据卷,并设置环境变量 NODE_ENV。</p><ol start="3"><li><h3 id="使用-docker-compose-构建和运行"><a href="#使用-docker-compose-构建和运行" class="headerlink" title="使用 docker-compose 构建和运行"></a><strong>使用 docker-compose 构建和运行</strong></h3></li></ol><p>编写完成后,就可以使用 docker-compose 命令自动构建镜像并启动容器了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up --build<br><span class="hljs-comment"># 简化 docker-compose up -d</span><br></code></pre></td></tr></table></figure><p>–build 参数保证 Compose 总是使用最新的 Dockerfile 构建镜像。</p><p>这条命令会：</p><ul><li>自动构建 Dockerfile 定义的镜像</li><li>根据 docker-compose.yml 的配置创建容器</li><li>启动容器</li><li>映射端口等</li></ul><p>这样 docker-compose up -d就会同时启动 web 和 db 服务了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker基础</title>
    <link href="/2024/04/07/Docker%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/04/07/Docker%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-底层原理"><a href="#Docker-底层原理" class="headerlink" title="Docker 底层原理"></a>Docker 底层原理</h1><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><ol><li><p><strong>命名空间(Namespaces)</strong></p><p> Docker 利用 Linux 内核的命名空间技术,为容器提供了一个独立的运行环境。主要包括以下几种命名空间:</p><ul><li>PID 命名空间:为容器提供独立的进程视图。</li><li>Network 命名空间:为容器提供独立的网络栈。</li><li>IPC 命名空间:为容器提供独立的进程间通信。</li><li>Mount 命名空间:为容器提供独立的挂载点视图。</li><li>UTS 命名空间:为容器提供独立的主机和域名。</li></ul></li><li><p><strong>控制组(cgroups)</strong>: Docker 使用 Linux 内核的 cgroups 功能,对容器的资源使用进行限制和隔离,如 CPU、内存、磁盘 I&#x2F;O 等。</p></li><li><p><strong>联合文件系统(UnionFS)</strong>: Docker 使用联合文件系统技术,支持为容器构建分层的文件系统。每层文件系统被称为一个 layer,新建容器时,Docker 会利用这些 layer 快速构建一个新的文件系统。</p></li></ol><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Docker 采用了 <code>C/S</code> 架构，包括客户端和服务端。Docker 守护进程 （<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p><p>客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。Docker 守护进程一般在宿主主机后台运行，等待接收来自客户端的消息。Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker 守护进程交互。</p><p><img src="/img/course/v7N8wg4sy3.png" alt="v7N8wg4sy3"></p><h3 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h3><p>Docker 包括三个基本概念:</p><p>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。<br>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>Docker 镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板,比如 Ubuntu 系统。</td></tr><tr><td>Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用,是镜像运行时的实体。</td></tr><tr><td>Docker 客户端(Client)</td><td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td></tr><tr><td>Docker 主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td>Docker Registry</td><td>Docker 仓库用来保存镜像,可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）;每个仓库可以包含多个标签（Tag）;每个标签对应一个镜像。通常,一个仓库会包含同一个软件不同版本的镜像,而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签,将以 latest 作为默认标签。</td></tr></tbody></table><h2 id="与VM虚拟机的不同"><a href="#与VM虚拟机的不同" class="headerlink" title="与VM虚拟机的不同"></a>与VM虚拟机的不同</h2><p>1、docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</p><p><img src="/img/course/20210211165803163.png" alt="20210211165803163"></p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>docker run</code></td><td>创建并运行一个新容器</td><td><code>docker run -d -p 80:80 nginx</code> - 以后台模式运行一个 Nginx 容器,并将主机 80 端口映射到容器的 80 端口</td></tr><tr><td><code>docker start/stop/restart</code></td><td>启动、停止、重启一个容器</td><td><code>docker stop mycontainer</code> - 停止名为 “mycontainer” 的容器</td></tr><tr><td><code>docker ps</code></td><td>列出所有正在运行的容器</td><td><code>docker ps</code> - 列出所有正在运行的容器</td></tr><tr><td><code>docker images</code></td><td>列出本地所有的 Docker 镜像</td><td><code>docker images</code> - 列出所有本地的 Docker 镜像</td></tr><tr><td><code>docker pull</code></td><td>从 Docker Registry 拉取一个镜像</td><td><code>docker pull ubuntu:18.04</code> - 从 Docker Hub 拉取 Ubuntu 18.04 镜像</td></tr><tr><td><code>docker build</code></td><td>根据 Dockerfile 构建一个新的镜像</td><td><code>docker build -t myapp .</code> - 使用当前目录下的 Dockerfile 构建一个名为 “myapp” 的镜像</td></tr><tr><td><code>docker commit</code></td><td>基于一个容器创建一个新的镜像</td><td><code>docker commit -m &quot;Added feature X&quot; mycontainer myusername/myimage:v1</code> - 基于名为 “mycontainer” 的容器创建一个新的镜像</td></tr><tr><td><code>docker push</code></td><td>将一个镜像上传到 Docker Registry</td><td><code>docker push myusername/myimage:v1</code> - 将本地的 “myimage:v1” 镜像上传到 Docker Hub</td></tr><tr><td><code>docker rmi</code></td><td>删除一个或多个本地镜像</td><td><code>docker rmi nginx:latest</code> - 删除 “nginx:latest” 镜像</td></tr><tr><td><code>docker rm</code></td><td>删除一个或多个容器</td><td><code>docker rm mycontainer</code> - 删除名为 “mycontainer” 的容器</td></tr><tr><td><code>docker exec</code></td><td>在一个已经运行的容器内执行命令</td><td><code>docker exec -it mycontainer bash</code> - 在名为 “mycontainer” 的容器内执行 Bash 命令</td></tr><tr><td><code>docker logs</code></td><td>查看容器的日志输出</td><td><code>docker logs mycontainer</code> - 查看名为 “mycontainer” 的容器的日志</td></tr><tr><td><code>docker network</code></td><td>管理 Docker 网络</td><td><code>docker network create mynetwork</code> - 创建一个名为 “mynetwork” 的自定义网络</td></tr><tr><td><code>docker volume</code></td><td>管理 Docker 数据卷</td><td><code>docker volume create myvolume</code> - 创建一个名为 “myvolume” 的数据卷</td></tr></tbody></table><p>引用文章：</p><blockquote><p><a href="https://blog.csdn.net/bbj12345678/article/details/113790971">https://blog.csdn.net/bbj12345678/article/details/113790971</a></p><p><a href="https://juejin.cn/post/7267477662360010767">https://juejin.cn/post/7267477662360010767</a></p><p><a href="https://blog.csdn.net/crazymakercircle/article/details/120747767">https://blog.csdn.net/crazymakercircle/article/details/120747767</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx负载均衡配置</title>
    <link href="/2024/03/17/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/03/17/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx负载均衡配置"><a href="#Nginx负载均衡配置" class="headerlink" title="Nginx负载均衡配置"></a>Nginx负载均衡配置</h1><p>Nginx是一个高性能的开源Web服务器，也可以用作反向代理服务器、负载均衡器和HTTP缓存。</p><h2 id="负载均衡（load-balancing）"><a href="#负载均衡（load-balancing）" class="headerlink" title="负载均衡（load balancing）"></a>负载均衡（load balancing）</h2><p>负载均衡是一种电子计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。</p><h2 id="负载均衡作用"><a href="#负载均衡作用" class="headerlink" title="负载均衡作用"></a>负载均衡作用</h2><ol><li><strong>提高系统可用性(Availability)</strong> 通过在多台服务器上部署相同的应用,当某一台服务器出现故障时,负载均衡器会自动将请求转发到其他正常工作的服务器,从而保证了整个系统的高可用性。</li><li><strong>提升系统扩展能力(Scalability)</strong> 随着访问量的增长,可以通过平滑地添加更多的服务器来分担负载压力,负载均衡器会自动将新加入的服务器纳入到集群中。这种无缝扩展让系统能够适应不断变化的访问量。</li><li><strong>增加吞吐量(Throughput)</strong> 将负载分布到多台服务器上,利用总体的计算资源,可以显著提升系统的吞吐量和响应速度。</li><li><strong>消除单点故障(Eliminate Single Point of Failure)</strong> 单个服务器是单点故障的风险,通过负载均衡将请求分发到多台服务器上,避免了单点故障导致的服务中断。</li><li><strong>复用昂贵资源</strong> 一些昂贵的资源如数据库、文件服务器等可以在一组服务器之间共享,从而更高效地利用这些资源。</li><li><strong>安全</strong> 负载均衡器通常位于网络边缘,可以为内部服务器实施一些安全策略,如过滤恶意请求、阻挡DOS攻击等。</li></ol><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><ol><li><strong>轮询（Round Robin）</strong>：按照顺序将每个新的请求分配给下一个服务器。这种算法简单且公平，适用于每台服务器性能相近的情况。</li><li><strong>最少连接（Least Connections）</strong>：将新的请求分配给当前连接数最少的服务器，以确保负载更均衡。适用于每个连接处理时间不同的情况。</li><li><strong>加权轮询（Weighted Round Robin）</strong>：给每台服务器分配一个权重，根据权重比例决定分配请求的次数。权重高的服务器会获得更多的请求，适用于服务器性能不均的情况。</li><li><strong>加权最少连接（Weighted Least Connections）</strong>：结合了加权和最少连接的概念，根据服务器的权重和当前连接数来分配请求。</li><li><strong>IP哈希（IP Hash）</strong>：根据客户端的IP地址计算哈希值，然后将请求分配给对应哈希值的服务器。这样可以确保同一客户端的请求始终被发送到同一台服务器，保持会话一致性。</li><li><strong>响应时间加权（Response Time Weighted）</strong>：根据服务器的响应时间来分配请求，响应时间短的服务器会获得更多的请求。</li><li><strong>最少流量（Least Traffic）</strong>：将请求发送到当前流量最小的服务器，以保持服务器的负载均衡。</li><li><strong>随机算法（Random）</strong>：随机选择一个服务器来处理请求，适用于简单的负载均衡需求。</li></ol><p>具体介绍参考<a href="https://www.alibabacloud.com/help/zh/slb/product-overview/introduction-to-load-balancing-scheduling-algorithm">负载均衡调度算法介绍</a></p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p><strong>负载服务器与后端服务器组均安装启动Nginx服务</strong>，<a href="https://blog.51cto.com/u_16099268/9789949">安装方法参考</a></p><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><h3 id="查看Nginx版本："><a href="#查看Nginx版本：" class="headerlink" title="查看Nginx版本："></a>查看Nginx版本：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -v<br></code></pre></td></tr></table></figure><p><strong>默认 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 为nginx配置文件，打开进行配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">events &#123;         <span class="hljs-comment">#events块</span><br>   <span class="hljs-string">...</span><br>&#125;<br><br>http      <span class="hljs-comment">#http块</span><br>&#123;<br>    <span class="hljs-string">...</span>   <span class="hljs-comment">#http全局块</span><br>    server        <span class="hljs-comment">#server块</span><br>    &#123; <br>        <span class="hljs-string">...</span>       <span class="hljs-comment">#server全局块</span><br>        location [PATTERN]   <span class="hljs-comment">#location块</span><br>        &#123;<br>            <span class="hljs-string">...</span><br>        &#125;<br>        location [PATTERN] <br>        &#123;<br>            <span class="hljs-string">...</span><br>        &#125;<br>    &#125;<br>    server<br>    &#123;<br>      <span class="hljs-string">...</span><br>    &#125;<br>    <span class="hljs-string">...</span>     <span class="hljs-comment">#http全局块</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在http代码块内添加名为load-balancing的负载均衡组，并添加一个服务器块："><a href="#在http代码块内添加名为load-balancing的负载均衡组，并添加一个服务器块：" class="headerlink" title="在http代码块内添加名为load.balancing的负载均衡组，并添加一个服务器块："></a>在http代码块内添加名为load.balancing的负载均衡组，并添加一个服务器块：</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs axapta">http &#123;<br>  upstream load.balancing &#123;<br>    <span class="hljs-meta"># 采用 ip_hash 负载均衡策略</span><br>    ip_hash;<br>    <span class="hljs-meta"># 负载均衡目的服务地址</span><br>    <span class="hljs-keyword">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">81</span>;<br>    <span class="hljs-keyword">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">82</span>;<br>    <span class="hljs-keyword">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">83</span> weight=<span class="hljs-number">10</span>;  <span class="hljs-meta"># weight 方式，不写默认为 1</span><br>  &#125;<br><br>  <span class="hljs-keyword">server</span> &#123;<br>  <span class="hljs-meta">#指定监听的端口</span><br>  listen <span class="hljs-number">8080</span>;<br>  <span class="hljs-meta">#指定域名</span><br>  server_name example.com;<br>    location / &#123;<br>      proxy_pass load.balancing;<br>      proxy_connect_timeout <span class="hljs-number">10</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>检查Nginx配置文件语法</strong>：在保存修改后，需要检查Nginx配置文件的语法是否正确。可以使用以下命令进行语法检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -t<br></code></pre></td></tr></table></figure><p><strong>重启Nginx服务器</strong>：重新加载Nginx配置并重启Nginx服务器（使新的配置生效，而不会中断正在处理的连接）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl reload nginx<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>访问<a href="http://your_server_ip:8080，观察配置是否生效">http://your_server_ip:8080，观察配置是否生效</a></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下中文版man命令--manpages-zh</title>
    <link href="/2024/03/16/Linux%E4%B8%8B%E4%B8%AD%E6%96%87%E7%89%88man%E5%91%BD%E4%BB%A4-manpages-zh/"/>
    <url>/2024/03/16/Linux%E4%B8%8B%E4%B8%AD%E6%96%87%E7%89%88man%E5%91%BD%E4%BB%A4-manpages-zh/</url>
    
    <content type="html"><![CDATA[<p>在Linux下使用man查看命令帮助，命令的词典。但默认的英文解释可能不便于理解。</p><h2 id="安装manpages-zh可以查看中文解释"><a href="#安装manpages-zh可以查看中文解释" class="headerlink" title="安装manpages-zh可以查看中文解释"></a>安装manpages-zh可以查看中文解释</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p><strong>使用安装命令</strong></p><p>Debian &#x2F; Ubuntu:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install manpages-zh<br></code></pre></td></tr></table></figure><p>Arch Linux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Syu<br>pacman -S man-pages-zh_cn man-pages-zh_tw<br></code></pre></td></tr></table></figure><p>Red Hat &#x2F; CentOS:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum update<br>yum install man-pages-zh-CN<br></code></pre></td></tr></table></figure><p>Fedora:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">dnf update<br>dnf install man-pages-zh-CN<br></code></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p><strong>下载源码编译安装</strong></p><p>参考GitHub项目 <a href="https://github.com/man-pages-zh/manpages-zh"><strong>manpages-zh</strong></a></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>可能出现的报错警告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">perl: warning: Setting locale failed.                                                                                                                                                      <br>perl: warning: Please check that your locale settings:                                                                                                                                     <br>        LANGUAGE = (unset),                                                                                                                                                                <br>        LC_ALL = (unset),                                                                                                                                                                  <br>        LC_MESSAGES = &quot;zh_CN.UTF-8&quot;,                                                                                                                                                       <br>        LANG = &quot;en_US.UTF-8&quot;            <br></code></pre></td></tr></table></figure><p><strong>原因</strong>：下载后如果系统并非中文环境，则还需要调整环境变量才能使用。</p><h3 id="特定会话中设置语言环境变量为中文（仅在此次登录的shell中使用）："><a href="#特定会话中设置语言环境变量为中文（仅在此次登录的shell中使用）：" class="headerlink" title="特定会话中设置语言环境变量为中文（仅在此次登录的shell中使用）："></a>特定会话中设置语言环境变量为中文（仅在此次登录的shell中使用）：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export LANG=&quot;zh_CN.UTF-8&quot;<br></code></pre></td></tr></table></figure><h3 id="永久更改系统的本地化设置："><a href="#永久更改系统的本地化设置：" class="headerlink" title="永久更改系统的本地化设置："></a>永久更改系统的本地化设置：</h3><p>1.在 <code>~/.bashrc</code> 文件中设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;LANG=&quot;zh_CN.UTF-8&quot;&#x27; &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><p>2.运行以下命令使更改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>更改本地化设置后，需要重新启动系统或者注销并重新登录用户才能使更改生效。</p><h2 id="使用man"><a href="#使用man" class="headerlink" title="使用man"></a>使用man</h2><p>在配置好后，就可以使用man命令愉快地查看命令的中文解释了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">man <span class="hljs-built_in">ls</span></span><br><br>LS(1)                            General Commands Manual                            LS(1)<br><br>NAME<br>       ls, dir, vdir - 列目录内容<br><br>提要<br>       ls [选项] [文件名...]<br><br>       POSIX 标准选项: [-CFRacdilqrtu1]<br><br>GNU 选项 (短格式):<br>       [-1abcdfgiklmnopqrstuxABCDFGLNQRSUX]  [-w  cols]  [-T  cols] [-I pattern] [--full-<br>       time]               [--format=&#123;long,verbose,commas,across,vertical,single-column&#125;]<br>       [--sort=&#123;none,time,size,extension&#125;]       [--time=&#123;atime,access,use,ctime,status&#125;]<br>       [--color[=&#123;none,auto,always&#125;]] [--help] [--version] [--]<br><br>描述（ DESCRIPTION ）<br>       程序ls先列出非目录的文件项，然后是每一个目录中的“可显示”文件。如果  没有选项之外的<br>       参数【译注：即文件名部分为空】出现，缺省为 &quot;.&quot; （当前目录）。 选项“ -d ”使得目录与<br>       非目录项同样对待。除非“ -a ” 选项出现，文 件名以“.”开始的文件不属“可显示”文件。<br><br>       以当前目录为准，每一组文件（包括非目录文件项，以及每一内含文件的目录）分  别按文件<br>       名比较顺序排序。如果“ -l ”选项存在，每组文件前显示一摘要行: 给出该组文件长度之和（<br>       以 512 字节为单位）。<br><br>       输出是到标准输出（  stdout  ）。除非以“  -C  ”选项要求按多列输出，输出  将是一行一<br>       个。然而，输出到终端时，单列输出或多列输出是不确定的。可以分别 用选项“ -1 ” 或“ -C<br>       ”来强制按单列或多列输出。<br><br>       -C     多列输出，纵向排序。<br><br>       -F     每个目录名加“ / ”后缀，每个 FIFO 名加“ | ”后缀， 每个可运行名加“ * ”后缀。<br><br>       -R     递归列出遇到的子目录。<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>服务器运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql数据库基本概念</title>
    <link href="/2024/03/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/03/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>MySQL数据库的相关的术语和数据类型</p><table><thead><tr><th>术语</th><th>描述</th></tr></thead><tbody><tr><td>数据库(Database)</td><td>用于存储数据的容器，可以包含多个表和其他相关对象。</td></tr><tr><td>表(Table)</td><td>数据库中的基本组织单位，用于存储数据。表由行和列组成。</td></tr><tr><td>列(Column)</td><td>表中的一个字段，用于存储特定类型的数据。</td></tr><tr><td>行(Row)</td><td>表中的一个记录，包含了一组相关的数据。</td></tr><tr><td>主键(Primary Key)</td><td>表中唯一标识每个行的字段。主键必须具有唯一性且不为空。</td></tr><tr><td>外键(Foreign Key)</td><td>表中的一个字段，用于与另一个表中的主键形成关联。</td></tr><tr><td>索引(Index)</td><td>用于提高数据检索效率的数据结构，可以加速查询操作。</td></tr><tr><td>SQL(Structured Query Language)</td><td>结构化查询语言，用于与数据库交互的标准语言。</td></tr></tbody></table><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>以下是常用的数据类型及其作用，采用表格形式列出：</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>int</td><td>整型</td></tr><tr><td>float</td><td>单精度浮点（4字节，32位）</td></tr><tr><td>double</td><td>双精度浮点（8字节，64位）</td></tr><tr><td>char</td><td>固定长度的字符类型</td></tr><tr><td>varchar</td><td>可变长度的字符类型</td></tr><tr><td>text</td><td>文本</td></tr><tr><td>image</td><td>图片</td></tr><tr><td>decimal(5,2)</td><td>5个有效长度数字，小数点后面有2位的十进制数</td></tr></tbody></table><h4 id="全部数据类型"><a href="#全部数据类型" class="headerlink" title="全部数据类型"></a>全部数据类型</h4><ol><li><p><strong>整数类型(Integers)</strong>:</p><ul><li><code>INT</code>: 整数类型，范围通常为-2147483648到2147483647。</li><li><code>BIGINT</code>: 大整数类型，范围通常为-9223372036854775808到9223372036854775807。</li></ul></li><li><p><strong>浮点数类型(Floating-Point Numbers)</strong>:</p><ul><li><code>FLOAT</code>: 单精度浮点数。</li><li><code>DOUBLE</code>: 双精度浮点数。</li></ul></li><li><p><strong>定点数类型(Fixed-Point Numbers)</strong>:</p><ul><li><code>DECIMAL</code>: 定点数，用于精确存储小数，需要指定精度和小数位数。</li></ul></li><li><p><strong>字符类型(Strings)</strong>:</p><ul><li><code>CHAR</code>: 固定长度字符串。</li><li><code>VARCHAR</code>: 可变长度字符串，根据存储的内容分配空间。</li><li><code>TEXT</code>: 用于存储大量文本数据。</li></ul></li><li><p><strong>日期和时间类型(Date and Time)</strong>:</p><ul><li><code>DATE</code>: 日期类型，格式为’YYYY-MM-DD’。</li><li><code>TIME</code>: 时间类型，格式为’HH:MM:SS’。</li><li><code>DATETIME</code>: 日期和时间类型，格式为’YYYY-MM-DD HH:MM:SS’。</li><li><code>TIMESTAMP</code>: 时间戳类型，存储自UNIX纪元（’1970-01-01 00:00:01’ UTC）以来的秒数。</li></ul></li><li><p><strong>布尔类型(Boolean)</strong>:</p><ul><li><code>BOOL</code> 或 <code>BOOLEAN</code>: 布尔类型，存储True或False。</li></ul></li><li><p><strong>二进制类型(Binary)</strong>:</p><ul><li><code>BLOB</code>: 二进制大对象，用于存储大量二进制数据。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql数据库基本操作</title>
    <link href="/2024/03/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/03/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>MySQL数据常见的操作包括创建数据库、创建表、插入数据、查询数据、更新数据，删除数据和更改表结构。</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE my_database;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE ecommerce_db;<br></code></pre></td></tr></table></figure><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE my_database;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE ecommerce_db;<br></code></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users (<br>    id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span> key<br>);<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> products (<br>    id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    price <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users (username, email) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;john_doe&#x27;</span>, <span class="hljs-string">&#x27;john@example.com&#x27;</span>);<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> products (name, price) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Laptop&#x27;</span>, <span class="hljs-number">1200.00</span>);<br></code></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;john.doe@example.com&#x27;</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;john_doe&#x27;</span>;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> products <span class="hljs-keyword">SET</span> price <span class="hljs-operator">=</span> <span class="hljs-number">1500.00</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Laptop&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;john_doe&#x27;</span>;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Laptop&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="更改表结构"><a href="#更改表结构" class="headerlink" title="更改表结构"></a>更改表结构</h3><h4 id="添加新列"><a href="#添加新列" class="headerlink" title="添加新列"></a>添加新列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> column_name datatype;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> users <span class="hljs-keyword">ADD</span> age <span class="hljs-type">INT</span>;<br></code></pre></td></tr></table></figure><h4 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name MODIFY column_name new_datatype;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name CHANGE column_name new_datatype;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> users MODIFY age <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> column_name;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> users <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> age;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件资源分享</title>
    <link href="/2024/02/29/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BD%AF%E4%BB%B6/"/>
    <url>/2024/02/29/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="远程桌面软件RDP"><a href="#远程桌面软件RDP" class="headerlink" title="远程桌面软件RDP"></a>远程桌面软件RDP</h1><h2 id="下载连接"><a href="#下载连接" class="headerlink" title="下载连接"></a>下载连接</h2><h2 id="Microsoft-远程桌面"><a href="#Microsoft-远程桌面" class="headerlink" title="Microsoft 远程桌面"></a><a href="/download/Microsoft.apk">Microsoft 远程桌面</a></h2><h1 id="V3rey"><a href="#V3rey" class="headerlink" title="V3rey"></a>V3rey</h1><h2 id="下载连接-1"><a href="#下载连接-1" class="headerlink" title="下载连接"></a>下载连接</h2><h2 id="V3rey-1"><a href="#V3rey-1" class="headerlink" title="V3rey"></a><a href="/download/v2rayNG.apk">V3rey</a></h2><h1 id="IDA-Pro-7-7"><a href="#IDA-Pro-7-7" class="headerlink" title="IDA Pro 7.7"></a>IDA Pro 7.7</h1><h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><h2 id="IDA-Pro-7-7-1"><a href="#IDA-Pro-7-7-1" class="headerlink" title="IDA Pro 7.7"></a><a href="/download/IDA7.7.zip">IDA Pro 7.7</a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>软件资源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法分析与设计</title>
    <link href="/2024/01/08/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/01/08/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="考试题型及分值"><a href="#考试题型及分值" class="headerlink" title="考试题型及分值"></a>考试题型及分值</h1><p>一、选择题（共 9 小题，每小题 2 分，共 18 分）<br>二、判断题（共 5 小题，每小题 2 分，共 10 分）<br>三、填空题（共 6 小题，每空1分，共 14 分）<br>四、解答题（共 5 大题，共 58 分）</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><h3 id="动态规划（关键）"><a href="#动态规划（关键）" class="headerlink" title="动态规划（关键）"></a>动态规划（关键）</h3><p>动态规划的要素（填空）：&#x3D;&#x3D;最优结构，重叠子问题&#x3D;&#x3D;</p><p>动态规划的原理、思想</p><p>多段图规划</p><p>0-1背包问题</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>和动态规划区别</p><p><strong>最短路径：迪杰斯特算法！</strong></p><p>Prim和Kruskal算法</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>关于0-1背包问题的算法，思想</p><h3 id="分支限界法！"><a href="#分支限界法！" class="headerlink" title="分支限界法！"></a>分支限界法！</h3><h3 id="随机算法（了解，什么时候使用）"><a href="#随机算法（了解，什么时候使用）" class="headerlink" title="随机算法（了解，什么时候使用）"></a>随机算法（了解，什么时候使用）</h3><h1 id="第一章-基础知识-排序"><a href="#第一章-基础知识-排序" class="headerlink" title="第一章 基础知识+排序"></a>第一章 基础知识+排序</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>1.算法由<strong>操作、控制结构、数据结构</strong>三要素组成</p><p>2.算法是什么：<strong>问题的程序化解决方案</strong></p><p>3.算法特征：有限性&#x2F;<strong>有穷性</strong>：对算法的每一次输入，算法都必须在有限步骤（即有限</p><p>时间）内结束</p><ol start="4"><li>算法与程序区别：</li></ol><p>(1)一个程序不一定满足<strong>有穷性</strong>（操作系统）。</p><p>(2)程序中的指令必须是机器可执行的，而算法中的指令则无此限制。</p><p>(3)<strong>算法代表了对问题的解</strong>，而程序则是算法在计算机上的特定的实现。</p><p>5.算法的描述（流程图、自然语言、程序语言、伪代码）</p><p>伪代码约定：利用i←j←e 来表示多重赋值，等价于 j←e 和i←j</p><p>6.算法的设计要求：</p><p>(1)正确性（对输入、输出和处理过程等有明确的<strong>无歧义</strong>的描述；有正确的输出结果并停止）</p><p>a)    不正确的算法：如果算法的<strong>错误率</strong>可以控制，也是有用的。</p><p><strong>b)</strong>    <strong>程序调试不能证明程序无错误</strong></p><p>(2)可读性</p><p>(3)健壮性（对于非法的输入数据，能适当地做出反应或进行处理(<strong>异常中断</strong>)）</p><p>(4)效率与低存储等需求</p><h2 id="二、算法分析基础"><a href="#二、算法分析基础" class="headerlink" title="二、算法分析基础"></a>二、算法分析基础</h2><p>1.算法分析的基本框架</p><p>(1)算法分析是指对一个算法所需要的资源进行预测，通常是对计算时间和空间的预测，采用<strong>随机存取机</strong>（RAM）计算模型。</p><p>算法运行时间是指在<strong>特定输入时，所执行的基本操作数</strong>。</p><p>输入数据的<strong>规模</strong>和<strong>分布</strong>是影响算法运行时间的两个主要因素。</p><p>对于大规模输入，通常只关注运行时间效率<strong>函数的增长率</strong></p><p>度量算法效率的方法：</p><p>事后统计 事前分析估算 算法的存储量（<strong>输入数据所占、程序本身所占和辅助变量所占</strong>）</p><p>(2)空间复杂度：通常指<strong>辅助变量所占空间 （S(n)&#x3D;O(f(n))）</strong></p><p>若额外空间相对于输入数据量是<strong>常数</strong>，该算法<strong>原地工作</strong>，频度&#x3D;重复</p><p>(3)时间复杂度：（嵌套最深层语句）</p><p>语句的频度之和构成运行时间。</p><p>对于规模为n的任何输入，一般考察算法的最坏运行时间</p><p>O(1)——常量阶   O(logn) ——对数阶  O(n) ——线性阶  O(nlogn) ——线性对数阶</p><p>O(n2) ——平方阶  O(n3) ——立方阶   O(nk)——多项式阶  O(2n) ——指数阶</p><p>&#x3D;&#x3D;<strong>Ο是渐进上界，Ω是渐进下界。Θ需同时满足大Ο和Ω，称为确界(必须同时符合上界和下界)。Ο表示了最差性能</strong>&#x3D;&#x3D;</p><h2 id="三、算法设计策略：分治法"><a href="#三、算法设计策略：分治法" class="headerlink" title="三、算法设计策略：分治法"></a>三、算法设计策略：分治法</h2><p>1.递归与分治法</p><p>分治策略: 将原问题<strong>划分</strong>为n个规模较小而结构与原问题相似的子问题,<strong>递归地解决</strong>这些子问题，然后再<strong>合并</strong>其结果，就得到原问题的解。</p><p>2.归并排序算法：</p><p>① 分解：把n个元素分成各含n&#x2F;2个元素的子序列；D(n)&#x3D;Θ(1)</p><p>② 解决：用归并排序算法对两个子序列递归地排序；2T(n&#x2F;2)</p><p>③ 合并：合并两个已排序的子序列以得到排序结果。C(n)&#x3D;Θ(n)</p><p>3.分治法分析</p><p><img src="/img/course/clip_image002.png" alt="img"></p><p>D(n)分解时间  C(n)合并时间  T(n)是一个规模为n的问题的运行时间</p><p>总共层数是lgn+1层，每一层代价都是cn，所以总代价为：cn(lgn +1) &#x3D;cnlgn+cn&#x3D;Θ(nlgn)</p><h1 id="第二章-排序"><a href="#第二章-排序" class="headerlink" title="第二章 排序"></a>第二章 排序</h1><h3 id="一、排序问题"><a href="#一、排序问题" class="headerlink" title="一、排序问题"></a>一、排序问题</h3><p>稳定排序算法：相同的数据，排序后仍维持原有的相对次序</p><h3 id="二、冒泡排序-选择排序"><a href="#二、冒泡排序-选择排序" class="headerlink" title="二、冒泡排序 &amp; 选择排序"></a>二、冒泡排序 &amp; 选择排序</h3><p>1.冒泡排序</p><p>基本思想：</p><p>① 比较相邻的两个元素。如果第一个元素比第二个大，就交换它们；</p><p>② 对每一对相邻元素做同样的操作，从开始第一对到结尾的最后一对，则最后的元素是最大的数；</p><p>③ 针对所有的元素重复以上的步骤，除了最后一个元素；</p><p>④ 重复步骤1~3，直到排序完成。</p><p>2.选择排序</p><p>基本思想：</p><p>① 初始状态：无序区为R[1..n]，有序区为空；</p><p>② 第i趟排序(i&#x3D;1, 2, 3, …, n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n</p><p>）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1</p><p>个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录</p><p>个数减少1个的新无序区；</p><p>③ n-1趟结束，数组有序化了</p><p>n个记录的直接选择排序，可经过n-1趟直接选择排序得到有序结果</p><p>算法分析：唯一的好处是不占用额外的内存空间</p><h3 id="三、插入排序-希尔排序"><a href="#三、插入排序-希尔排序" class="headerlink" title="三、插入排序 &amp; 希尔排序"></a>三、插入排序 &amp; 希尔排序</h3><ol><li><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4></li></ol><p>原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。一般来说，插入排序采用in-place基于数组进行实现</p><p>算法分析：插入排序的实现，通常采用<strong>in-place</strong>基于数组排序 (即只需O(1)的额外空间)，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><ol start="2"><li>希尔排序（<strong>缩小增量排序</strong>）：<strong>优先比较距离较远的元素</strong></li></ol><p>先将整个待排序的记录序列，分割成为若干组待排序的子序列，分别进行直接插入排序。</p><p><strong>出发点</strong>：插入排序在元素基本有序的情况下，效率很高。</p><p><strong>gap</strong>：初始值设为 n&#x2F;2，然后不断减半。</p><p>算法分析：希尔排序的核心在于<strong>间隔序列</strong>的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p><h3 id="四、快速排序-堆排序"><a href="#四、快速排序-堆排序" class="headerlink" title="四、快速排序 &amp; 堆排序"></a>四、快速排序 &amp; 堆排序</h3><p>1.快速排序（前面的比选定元素小，后面的大，然后对两边递归）</p><p>基本思想: 采用<strong>分治策略</strong>把未排序数组分为两部分，然后分别<strong>递归</strong>调用自身进行排序：</p><p>① 分解：数组A[p…r]被划分为两个（可能空）子数组A[p…q-1]和A[p+1..r]，使得A[p…q-1]中每个元素都小于或等于A[q]和A[q+1..r]中的元素。下标q在这个划分过程中进行计算；</p><p>② 解决：递归调用快速排序，对子数组A[p…q-1]和A[q+1..r]排序；</p><p>③ 合并：不需要任何操作。</p><p><strong>如何防止出现最坏情况发生</strong>？</p><p>策略1：显示地对输入进行排列使得快速排序算法随机化</p><p>策略2：采用<strong>随机取样</strong>的随机化技术：从子数组A[p…r]中随机选择一个元素作为主元，从而达到可以对输入数组的划分能够比较对称</p><p>2.堆排序</p><p>(1)堆排序（Heapsort）是指利用堆该数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：<strong>子结点的键值或索引总是小于（或者大于）它的父节点</strong></p><p>(2)基本思想：</p><p>① 将初始待排序关键字序列(R1,R2….Rn)构建成<strong>大顶堆</strong>，此堆为初始的无序区；</p><p>② 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn- 1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</p><p>③ 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成</p><p>(3)堆数据结构是一种数组对象，可以被视为一棵完全二叉树。树中每个节点与数组中存放该结点值的元素对应。树的每一层都是填满的，最后一层可能除外（从一个结点的左子树开始填）</p><p>在堆排序算法中，如果使用大根堆，堆中最大元素位于树根；</p><p>小根堆通常在构造<strong>优先队列</strong>时使用</p><p>是一种in-place原地排序算法</p><p>堆排序算法与插入排序算法设计策略关系是否类似？</p><p>（<strong>减治法</strong>：不断减小被处理的问题规模）</p><p>五、线性排序算法 (计数排序、桶排序、基数排序)</p><p><strong>比较排序</strong>：排序结果中各元素的次序基于输入元素间的比较，这类算法是比较排序。最好的时间复杂度为O(nlogn) </p><p>线性排序: 时间复杂度为 <strong>O(n)（突破了比较排序的最好时间复杂度）</strong>, 达到线性，排序不基于比较。</p><p>线性排序有三种：计数排序、桶排序、基数排序。</p><p><strong>排序算法正确工作的必要条件</strong>：n个元素的n!中排列都要作为决策树的一个叶子。</p><p><strong>定理1 任意比较排序算法在最坏情况下，都需要做Ω(nlogn)次比较。堆排序和合并排序是渐近最优的排序算法，快速排序执行效率平均较堆排序和合并排序好。</strong></p><p>计数排序（不是比较排序算法）基本思想：对每一个输入元素x，统计出小于x的元素的个数。然后，根据这一信息直接把元素x放到它在最终输出数组中的位置上。</p><ol><li>桶排序</li></ol><p>基本思想：</p><ol><li>把区间[0,1)划分成n个相同大小的子区间（称为桶）</li><li>将n个输入数分布到各个桶中去</li><li>先对各桶中元素进行排序，然后依次列出各桶中的元素</li><li>基数排序</li></ol><p>假设所有待排序元素均为整数，至多d位。先按<strong>最低有效位</strong>进行排序，再按<strong>次低有效位</strong>排序，重复这个过程，直到对所有的d位数字都进行了排序。</p><p><strong>基数排序关键是按位排序要稳定</strong></p><p><strong>总共花费O(d(n+k))的时间。</strong>如果 d是常数，k &#x3D; O(n)，基数排序能在线性时间内完成排序</p><h3 id="六、排序算法比较"><a href="#六、排序算法比较" class="headerlink" title="&#x3D;&#x3D;六、排序算法比较&#x3D;&#x3D;"></a>&#x3D;&#x3D;六、排序算法比较&#x3D;&#x3D;</h3><p>1.比较排序：排序结果中，各元素的次序基于输入元素间的比较，这类算法成为比较排序。</p><p>任何比较排序算法，排序n个元素时至少耗用Ω(nlgn)次比较，其时间复杂度至少为Ω(nlgn)</p><p>2.当数据规模n较小时，n2和nlog2n的差别不大</p><p>当文件的初态已基本有序时，可选择简单的排序方法,如直接插入排序或起泡排序等</p><p>当数据规模n较大时，应选用速度快的排序算法</p><p>快速排序法最快，被认为是目前基于比较的排序方法中最好的方法当待排序的记录是随机分布时，快速排序的平均时间最短。但快速排序有可能出现最坏情况，则快速排序算法的时间复杂度为O(n2)，且递归深度为n，即所需栈空间为O(n)</p><p><img src="/img/course/clip_image004.png" alt="img"></p><p>插帽龟，统计鸡走的稳（希尔快速选择堆不稳）</p><p>选帽插，全恩方，冒插最好没有方</p><p>统计鸡，加减乘除</p><p>恩老哥，快归堆</p><p>快桶最坏是恩方</p><h1 id="第三章-递归和分治策略"><a href="#第三章-递归和分治策略" class="headerlink" title="第三章  递归和分治策略"></a><strong>第三章  递归和分治策略</strong></h1><h2 id="一、-递归的定义、总体思想、特点；"><a href="#一、-递归的定义、总体思想、特点；" class="headerlink" title="一、 递归的定义、总体思想、特点；"></a><strong>一、</strong> <strong>递归的定义、总体思想、特点；</strong></h2><p>1.递归(Recursion)基本思想：把<strong>规模大的问题转化为规模小的相似的子问题</strong>来解决。在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了<strong>函数直接或间接调用它自身</strong>的情况。这个解决问题的函数<strong>必须有明显的结束条件</strong>，这样就不会产生无限递归的情况</p><ol start="2"><li><strong>总体思想</strong>：如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。（自底向上）</li></ol><p><strong>3</strong>.两个要素<strong>：边界条件、递归函数</strong></p><h2 id="二、-通过具体例子理解递归策略与设计（-N的阶乘、Fibonacci数列、全排列、整数划分问题、Hanoi塔问题）"><a href="#二、-通过具体例子理解递归策略与设计（-N的阶乘、Fibonacci数列、全排列、整数划分问题、Hanoi塔问题）" class="headerlink" title="二、 通过具体例子理解递归策略与设计（ N的阶乘、Fibonacci数列、全排列、整数划分问题、Hanoi塔问题）"></a><strong>二、</strong> <strong>通过具体例子理解递归策略与设计（</strong> N的阶乘、Fibonacci数列、全排列<strong>、整数划分问题、Hanoi塔问题）</strong></h2><p>1.N的阶乘：</p><p>n! &#x3D;       1(n&#x3D;0)     n&#x3D;0</p><p>​              n(n-1)     n&gt;0</p><p>2 Fibonacci数列</p><p>F(n)&#x3D;       1             n&#x3D;0</p><p>​               1             n&#x3D;1</p><p>​               F(n-1)+F(n-2)    n&gt;1</p><p>3.全排列 ：(从n个元素中取出m个元素进行排列)</p><h4 id="4-整数划分问题"><a href="#4-整数划分问题" class="headerlink" title="4. 整数划分问题"></a><strong>4.</strong> <strong>整数划分问题</strong></h4><p><strong>q(n****，m)&#x3D;      1                           m&#x3D;1,n&#x3D;1</strong></p><p>​              <strong>q(n,n)                       n&lt;m</strong></p><p><strong>q(n****，m)&#x3D;1+q(n,n-1)           n&#x3D;m</strong>              </p><p><strong>q(n,m)&#x3D;q(n,m-1)+q(n-m,m)      n&gt;m&gt;1</strong></p><p>**n:**<strong>待拆分的整数 m：拆分出的最大值不超过m</strong> </p><h4 id="5-Hanoi塔问题"><a href="#5-Hanoi塔问题" class="headerlink" title="5. Hanoi塔问题:"></a><strong>5. Hanoi</strong>塔问题:</h4><p>第n-1个盘子由a移到c；第n个盘子由a移到b；第n-1个盘子由c移到b；</p><p>public static void hanoi(int n, int a, int b, int c)</p><p>{</p><p>if (n &gt; 0)</p><p>{</p><p>hanoi(n-1, a, c, b);</p><p>move(a, b);</p><p>hanoi(n-1, c, b, a);</p><p>}</p><p>}</p><h2 id="三、-分治法的概念、步骤、复杂度分析；"><a href="#三、-分治法的概念、步骤、复杂度分析；" class="headerlink" title="三、 分治法的概念、步骤、复杂度分析；"></a><strong>三、</strong> <strong>分治法的概念、步骤、复杂度分析；</strong></h2><h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>(1)问题的规模缩小到一定的程度就可以容易地解决</p><p>(2)分解为若干个规模较小的相同问题，**&#x3D;&#x3D;具有最优子结构&#x3D;&#x3D;**</p><p>(3)分解出的子问题的解<strong>可以合并</strong>为该问题的解</p><p>(4)该问题所分解出的各个子问题是<strong>相互独立</strong>的，即子问题之间不包含公共的子问题</p><p>如果具有前两个特征未有第三个可以考虑动态规划和贪心算法</p><h3 id="分治法基本步骤"><a href="#分治法基本步骤" class="headerlink" title="分治法基本步骤"></a>分治法基本步骤</h3><p>&#x3D;&#x3D;① 分解② 解决③ 合并&#x3D;&#x3D;</p><p><strong>平衡子问题</strong>：最好使子问题规模大致相等   </p><p><strong>divide-and-conquer(P)</strong></p><p><strong>{&#x2F;&#x2F; P****是问题的规模，n0是阈值</strong></p><p><strong>if ( |P| &lt;&#x3D; n0) adhoc(P); &#x2F;&#x2F;</strong> <strong>基本子算法，解决小规模的问题</strong></p><p> <strong>divide P into smaller subinstances P1,P2,…,Pk****；&#x2F;&#x2F; 分解问题</strong></p><p> <strong>for (i&#x3D;1; i&lt;&#x3D;k; i++) &#x2F;&#x2F; k****通常为2</strong></p><p><strong>yi&#x3D;divide-and-conquer(Pi); &#x2F;&#x2F;</strong> <strong>递归的解各子问题</strong></p><p> <strong>return merge(y1,…,yk); &#x2F;&#x2F;</strong> <strong>将各子问题的解合并为原问题的解</strong></p><p><strong>}</strong></p><p>**3.**<strong>优缺点</strong></p><p>能简单地求解复杂的问题</p><p>并行性 (并行计算、多处理器系统)</p><p>内存访问 (利用内存缓存机制，不需要访问存取速度较慢的主存)</p><p><strong>分治法不能适应于所有问题</strong></p><p><strong>递归的效率较慢 (具体的实现方式)</strong></p><p><strong>分治法比迭代方法更复杂 (例子：n个数求和)</strong></p><p><strong>四、</strong> <strong>通过几个范例学习分治策略的设计技巧（二分搜索、归并排序、乘法问题、找最大最小值问题、循环赛日程表等）</strong></p><p><strong>1.</strong>   <strong>二分搜索（最坏情况下时间复杂性为O(logn)）</strong></p><p>应用场景及局限性</p><p>o 二分查找依赖<strong>顺序表结构</strong>，如数组</p><p>o 二分查找针对的是<strong>有序数据</strong></p><p>o <strong>数据量太小太大</strong>不适合二分查找</p><p>public static int binarySearch(int [] a, int x, int n)</p><p>{</p><p>&#x2F;&#x2F; 在 a[0] &lt;&#x3D; a[1] &lt;&#x3D; … &lt;&#x3D; a[n-1] 中搜索 x</p><p>&#x2F;&#x2F; 找到x时返回其在数组中的位置，否则返回-1</p><p>int left &#x3D; 0; int right &#x3D; n - 1;</p><p>while (left &lt;&#x3D; right) {</p><p>int middle &#x3D; (left + right)&#x2F;2;</p><p>if (x &#x3D;&#x3D; a[middle]) return middle;</p><p>if (x &gt; a[middle]) left &#x3D; middle + 1;</p><p>else right &#x3D; middle - 1;</p><p>}</p><p>return -1; &#x2F;&#x2F; 未找到x</p><p>}</p><p><strong>2.</strong>   <strong>归并排序</strong></p><p><strong>将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序</strong></p><p><strong><img src="/img/course/clip_image006.png" alt="img"></strong></p><p><strong>3.</strong>   <strong>乘法问题</strong></p><p>(1) 整数相乘问题【分治法：O(n1.59)】</p><p><strong>(2)</strong> <strong>矩阵相乘问题【分治法：O(n2.81)】</strong> </p><p><strong><img src="/img/course/clip_image008.png" alt="img"></strong></p><ol start="4"><li>最大最小值问题</li><li>循环赛日程表</li></ol><h1 id="第四章动态规划"><a href="#第四章动态规划" class="headerlink" title="第四章动态规划"></a><strong>第四章动态规划</strong></h1><h2 id="一、-理解动态规划算法的由来、概念、定义"><a href="#一、-理解动态规划算法的由来、概念、定义" class="headerlink" title="一、 理解动态规划算法的由来、概念、定义"></a><strong>一、</strong> <strong>理解动态规划算法的由来、概念、定义</strong></h2><p><strong>1.多阶段决策过程（最优决策序列）</strong>：问题的活动过程分为若干相互联系的阶段，任一阶段i以后的行为仅依赖于i阶段的过程状态，而与i阶段之前的过程如何达到这种状态的方式无关</p><ol start="2"><li>多阶段决策问题的求解策略<strong>（</strong>枚举法<strong>、动态规划（最优化原理、多阶段-&gt;单阶段））</strong></li><li><strong>最优决策序列性质</strong>：无论过程的<strong>初始状态和初始决策</strong>是什么，其余的决策都必须相对于初始决策所产生的状态构成一个最优决策序列。</li></ol><p>4.状态无后效性（马尔科夫性）未来与过去无关</p><p>5.多阶段决策模型：<strong>自然状态、策略、益损值（准则函数&#x2F;指标函数）</strong></p><p><strong>6.</strong> 动态规划求解问题的前提：<strong>最优性原理（前提）</strong>、<strong>递推关系式与边界条件</strong>。</p><ol start="7"><li>动态规划的设计技巧：<strong>阶段划分、状态表示、存储表</strong></li><li>动态规划法的优缺点</li></ol><p>与非线性规划相比，动态规划的优点：</p><p>（1）易于确定全局最优解。把原问题化为一系列结构相似的最优化子问题</p><p>（2）能得到一簇解</p><p>（3）动态规划方法反映了过程逐段演变的前后联系</p><p>不足之处：</p><p>（1）没有一个统一的标准模型可供应用。</p><p>（2）应用的局限性。状态变量要满足“无后效性”条件</p><p>（3）在数值求解中，存在“维数障碍”。每递推一段，必须把前一段的最优值函数在相应的状态集合上的全部值存入内存中。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="&#x3D;&#x3D;基本思想&#x3D;&#x3D;"></a>&#x3D;&#x3D;基本思想&#x3D;&#x3D;</h3><p>动态规划的思想实质是<strong>分治思想</strong>和<strong>解决冗余</strong> </p><p>动态规划算法与分治法类似，其基本思想也是<strong>将待求解问题分解成若干个子问题</strong></p><p>但是经过分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。</p><h2 id="三、掌握动态规划算法的要素："><a href="#三、掌握动态规划算法的要素：" class="headerlink" title="三、掌握动态规划算法的要素："></a>三、掌握动态规划算法的要素：</h2><p><strong>✓</strong> <strong>&#x3D;&#x3D;最优子结构&#x3D;&#x3D;（自底向上）：最优解是由其子问题的最优解来构造的，则具有最优子结构。</strong></p><p><strong>动态规划算法问题解的代价 &#x3D; 子问题的代价 + 选择带来的开销</strong></p><p>与贪心算法的不同：贪心算法适用的问题也具有最优子结构，但它是先做选择再求解一个结果子问题（自顶向下）</p><p>利用<strong>反证法</strong>判断问题满足最优性原理，不能应用最优子结构的时候，不能假设它能够应用</p><p><strong>✓</strong> &#x3D;&#x3D;重叠子问题&#x3D;&#x3D;（子问题的空间小、不被反复计算）</p><p><strong>自顶向下的做备忘录算法：为每一个子问题的解在表中记录一个表项</strong></p><p><strong>如果某些子问题没有必要求解，做备忘录方法具有只需要求解那些肯定要求解的</strong></p><p><strong>子问题的优点。</strong></p><h2 id="四、掌握设计动态规划算法的步骤"><a href="#四、掌握设计动态规划算法的步骤" class="headerlink" title="四、掌握设计动态规划算法的步骤"></a><strong>四、掌握设计动态规划算法的步骤</strong></h2><p><strong>① 划分子问题：找出最优解的性质，并刻划其结构特征。</strong></p><p><strong>② 最优解的递归式：递归地定义最优解的值。</strong></p><p><strong>③ 按自底向上的方式计算最优解的值。</strong></p><p><strong>④ 由计算出的结果构造一个最优解。</strong></p><p><strong>四、通过范例学习动态规划算法的设计策略</strong></p><p>**1.**<strong>矩阵连乘</strong></p><p><strong>2.</strong> <strong>最长公共子序列（LCS）</strong></p><p><strong><img src="/img/course/clip_image010.png" alt="img"></strong></p><p><strong>2.</strong>   <strong>多段图规划</strong></p><p><strong>3.</strong>   <strong>最大子段和</strong></p><p><img src="/img/course/clip_image012.png" alt="img"></p><p><strong>4.0-1****背包</strong></p><p><strong><img src="/img/course/clip_image014.png" alt="img"></strong></p><p><strong>5.</strong> <strong>备忘录动态规划算法</strong></p><h1 id="第5章-贪心算法"><a href="#第5章-贪心算法" class="headerlink" title="第5章 贪心算法"></a>第5章 贪心算法</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h4 id="最优化问题"><a href="#最优化问题" class="headerlink" title="最优化问题"></a>最优化问题</h4><p>最优化问题求解分类：根据描述问题约束条件和目标函数的数学模 型的特性和问题的求解方法的不同，可分为：线性规划、整数规划 、非线性规划、<strong>动态规划</strong>、<strong>分支限界法</strong>等<strong>精确算法</strong>。 </p><p><strong>贪心方法</strong>：一种改进的分级的处理方法，可对满足上述特征的某些 问题方便地求解，属于<strong>近似算法</strong>。</p><h4 id="最优子结构性质："><a href="#最优子结构性质：" class="headerlink" title="最优子结构性质："></a><strong>最优子结构性质：</strong></h4><p> 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</p><h2 id="贪心算法-1"><a href="#贪心算法-1" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心选择不一定等于整体最优解：由问题是否具有贪心选择性质决定</p><h3 id="基本思想："><a href="#基本思想：" class="headerlink" title="&#x3D;&#x3D;基本思想：&#x3D;&#x3D;"></a>&#x3D;&#x3D;基本思想：&#x3D;&#x3D;</h3><p><strong>从问题的某一个初始解出发，通过一系列的贪心选择，即当前状态下的局部最优选择，逐步逼近给定的目标，尽可能快地求得更好的解。</strong> </p><p> 在贪心算法(Greedy Method)中采用<strong>逐步构造&#x2F;分级最优解</strong>的方法 。在每个阶段，都作出一个按<strong>某个评价函数最优的决策</strong>，该最优 评价函数称为<strong>贪心准则</strong>(Greedy Criterion)</p><h3 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="&#x3D;&#x3D;基本步骤：&#x3D;&#x3D;"></a>&#x3D;&#x3D;基本步骤：&#x3D;&#x3D;</h3><p>① 决定问题的<strong>最优子结构</strong>； </p><p>② 设计出一个递归解； </p><p>③ 证明在递归的任一阶段，最优选择之一总是贪心选择, 那么做 贪心选择总是安全的。 </p><p>④ 证明通过做贪心选择，所有子问题(除一个以外)都为空, 即只产 生一个子问题。 </p><p>⑤ 设计出一个实现贪心策略的递归算法。 </p><p>⑥ (性能角度) 将递归算法转换成迭代算法。</p><h3 id="贪心策略设计："><a href="#贪心策略设计：" class="headerlink" title="贪心策略设计："></a>贪心策略设计：</h3><p>策略1：<strong>按价值最大贪心，是目标函数增长最快</strong>。 </p><p>策略2：<strong>按重量最小贪心，使背包增长最慢。</strong></p><p>策略3：<strong>按价值率最大贪心，使单位重量价值增长最快</strong>。</p><h3 id="贪心算法-vs-动态规划"><a href="#贪心算法-vs-动态规划" class="headerlink" title="&#x3D;&#x3D;贪心算法 vs 动态规划&#x3D;&#x3D;"></a>&#x3D;&#x3D;贪心算法 vs 动态规划&#x3D;&#x3D;</h3><p>贪心算法和动态规划算法都要求问题具有<strong>最优子结构性质</strong>，但是两者 存在着巨大的差别。</p><p>(1) 动态规划是先分析子问题，再做选择。而贪心算法是先做贪心选择，做完选择后，生成了子问题，然后再去求解子问题；</p><p>(2) 动态规划每一步<strong>可能会产生多个子问题</strong>，而贪心算法的每一步只会<strong>产生一个子问题</strong>； </p><p> (3) 从特点上看，动态规划是&#x3D;&#x3D;自底向上&#x3D;&#x3D;解决问题，而贪心算法则是&#x3D;&#x3D;自顶向下&#x3D;&#x3D;解决问题。</p><h2 id="可解决问题："><a href="#可解决问题：" class="headerlink" title="可解决问题："></a>可解决问题：</h2><p>活动安排问题、小数背包问题、最优装载问题、找钱问题、单源最短路径、最小生成树</p><h3 id="最小生成树—Prim算法"><a href="#最小生成树—Prim算法" class="headerlink" title="&#x3D;&#x3D;最小生成树—Prim算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>最小生成树—Prim算法</strong>&#x3D;&#x3D;</h3><p><img src="/img/course/image-20240106154600605.png" alt="image-20240106154600605"></p><p><img src="/img/course/image-20240106154640225.png" alt="image-20240106154640225"></p><h3 id="最小生成树—Kruskal算法"><a href="#最小生成树—Kruskal算法" class="headerlink" title="&#x3D;&#x3D;最小生成树—Kruskal算法&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;最小生成树—Kruskal算法&#x3D;&#x3D;</strong></h3><p><img src="/img/course/image-20240106154714944.png" alt="image-20240106154714944"></p><p><img src="/img/course/image-20240106154726870.png" alt="image-20240106154726870"></p><p>时间复杂度：&#x3D;&#x3D;O(Elog E)&#x3D;&#x3D;    V为顶点数，E为边数</p><p>当 E&gt;V^2^ 时，Kruskal算法比Prim算法差； </p><p>当E&lt;V^2^ 时，Kruskal算法却比Prim算法好得多。</p><h3 id="单源最短路径–迪杰斯特拉-Dijkstra-算法"><a href="#单源最短路径–迪杰斯特拉-Dijkstra-算法" class="headerlink" title="&#x3D;&#x3D;单源最短路径–迪杰斯特拉(Dijkstra)算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;单源最短路径–迪杰斯特拉(Dijkstra)算法&#x3D;&#x3D;</h3><p>&#x3D;&#x3D;基本思想&#x3D;&#x3D;：设置顶点集合S并不断地作&#x3D;&#x3D;贪心选择&#x3D;&#x3D;来扩充这个集合。 一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知。</p><p><img src="/img/course/image-20240107150050942.png" alt="image-20240107150050942"></p><h1 id="第6章-回溯法"><a href="#第6章-回溯法" class="headerlink" title="第6章 回溯法"></a>第6章 回溯法</h1><h2 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p><strong>回溯法</strong> (Backtracking) 又称为<strong>试探法</strong>： — 回溯法是一个既带有**&#x3D;&#x3D;系统性&#x3D;&#x3D;又带有&#x3D;&#x3D;跳跃性&#x3D;&#x3D;**的搜索算法； </p><p>— 它在包含问题的<strong>所有解的解空间树</strong>中，按照<strong>深度优先的策略</strong>，从 根结点出发搜索解空间树。—— 系统性</p><p> — 算法搜索至解空间树的任一结点时，<strong>判断该结点为根的子树是否包含问题的解</strong>，如果肯定不包含，则<strong>跳过</strong>以该结点为根的子树的搜索， 逐层向其祖先结点回溯。否则，进入该子树，继续深度优先的策略 进行搜索。——跳跃性 </p><p>— 这种以深度优先的方式系统地搜索问题的解的算法称为回溯法， 它适用于解一些<strong>组合数较大</strong>的问题。许多<strong>复杂的、规模较大</strong>的问题都可以使用回溯法，有“通用解题方法”的美称</p><h3 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h3><p><img src="/img/course/image-20240106144007100.png" alt="image-20240106144007100"></p><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p><img src="/img/course/image-20240106150720225.png" alt="image-20240106150720225"></p><p><img src="/img/course/image-20240106150732972.png" alt="image-20240106150732972"></p><p><img src="/img/course/image-20240106151741197.png" alt="image-20240106151741197"></p><h3 id="二类常见的解空间树："><a href="#二类常见的解空间树：" class="headerlink" title="二类常见的解空间树："></a>二类常见的解空间树：</h3><p><strong>子集树</strong>：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时。子集树通常有2 ^n^个叶子 结点，其总结点个数为2 ^n+1^ -1，遍历子集树时间为&#x3D;&#x3D;Ω(2^n^ )&#x3D;&#x3D; 。</p><p><strong>排列树</strong>：当所给问题是确定n个元素满足某种性质的排列时。排列树通常有n!个叶子结点，因此，遍历排列树需要&#x3D;&#x3D;Ω(n!)&#x3D;&#x3D;的计算时间。例如TSP</p><p><img src="/img/course/image-20240106151551908.png" alt="image-20240106151551908"></p><p><img src="/img/course/image-20240106151348691.png" alt="image-20240106151348691"></p><h3 id="可以解决的问题："><a href="#可以解决的问题：" class="headerlink" title="可以解决的问题："></a>可以解决的问题：</h3><p>排列生成问题：给定正整数n，生成1, 2, …, n所有排列</p><p>TSP问题：一个商品推销员要去若干个城市推销商品，该推销员从一个城市出发，需要经过所有城市后，回到出发地。应如何选择行进路线，以使总的行程最短。</p><p>n皇后问题：在n*n棋盘上放上n个皇后，使皇后彼此不受攻 击，即条件是彼此不在同行(列)、斜线上。求出全部的放法。</p><p>0-1背包问题、符号三角形问题</p><p>图的m着色问题：给定无向连通图G和m种不同的颜色。用这些颜色为图G的各顶点着色，每 个顶点着一种颜色。是否有一种着色法使G中每条边的2个顶点着不同颜色。</p><h3 id="回溯法效率分析"><a href="#回溯法效率分析" class="headerlink" title="回溯法效率分析"></a>回溯法效率分析</h3><p><strong>子集树</strong>：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时。子集树通常有2 ^n^个叶子 结点，其总结点个数为2 ^n+1^ -1，遍历子集树时间为&#x3D;&#x3D;Ω(2^n^ )&#x3D;&#x3D; 。例如0-1背包问题</p><p><strong>排列树</strong>：当所给问题是确定n个元素满足某种性质的排列时。排列树通常有n!个叶子结点，因此，遍历排列树需要&#x3D;&#x3D;Ω(n!)&#x3D;&#x3D;的计算时间。例如TSP</p><p>通过上述实例的讨论，回溯法的效率在很大程度上依赖于以下因素：</p><p> (1) 产生x[t]的时间；（生成解空间的时间）</p><p> (2) 满足显约束的x[t]值的个数；</p><p> (3) 计算约束函数constraint的时间；</p><p> (4) 计算上界函数bound的时间； </p><p>(5) 满足约束函数和上界函数约束的所有x[k]的个数。</p><p><strong>好的约束函数能显著地减少所生成的结点数</strong>，但这样的约束函数往 往计算量较大。因此，在选择约束函数时通常存在<strong>生成结点数与约束函数计算量之间的折衷</strong>。</p><h1 id="第7章-分支限界法"><a href="#第7章-分支限界法" class="headerlink" title="第7章 分支限界法"></a>第7章 分支限界法</h1><h2 id="方法概述-1"><a href="#方法概述-1" class="headerlink" title="方法概述"></a>方法概述</h2><h3 id="与回溯法区别："><a href="#与回溯法区别：" class="headerlink" title="与回溯法区别："></a>与回溯法区别：</h3><p><strong>求解目标不同</strong>： 一般而言，回溯法的求解目标是找出解空间树中满足约束条件的所有解， 而分支限界法的求解目标则是尽快地找出满足约束条件的一个解；</p><p><strong>搜索方法不同</strong>： 回溯法使用<strong>深度优先方法</strong>搜索，而分支限界一般用宽<strong>度优先或最佳优先方法</strong>来搜索； </p><p><strong>对扩展结点的扩展方式不同</strong>： 分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成 为扩展结点，就一次性产生其所有儿子结点； </p><p><strong>存储空间的要求不同</strong>：分支限界法的存储空间比回溯法大得多，因此当内存容量有限时，回溯法解决问题成功的可能性更大。</p><h3 id="基本思想-："><a href="#基本思想-：" class="headerlink" title="&#x3D;&#x3D;基本思想&#x3D;&#x3D;："></a><strong>&#x3D;&#x3D;基本思想&#x3D;&#x3D;：</strong></h3><p>分支限界法常以广度优先或以最小耗费(最大效益)优先的方式搜 索问题的解空间树。i) 对已处理的各结点根据限界函数估算目标 函数的可能取值，ii) 从中选出目标函数取得极大(极小) 值的结 点优先进行广度优先搜索, iii) 不断地调整搜索方向，尽快找到 解，裁剪那些不能得到最优解的子树以提高搜索效率。</p><h3 id="求解步骤："><a href="#求解步骤：" class="headerlink" title="求解步骤："></a><strong>求解步骤：</strong></h3><p>① 定义解空间(对解编码)； </p><p>② 确定解空间的树结构； </p><p>③ 按BFS等方式搜索： </p><p>​a. 每个活结点仅有一次机会变成扩展结点；</p><p>​b. 由扩展结点生成一步可达(即宽度搜索)的新结点； </p><p>​c. 在新结点中，删除不可能导出最优解的结点； &#x2F;&#x2F; 限界策略 </p><p>​d. 将剩余的新结点加入活动表(队列)中； </p><p>​e. 从活动表中选择结点再扩展； &#x2F;&#x2F;分支策略 </p><p>​f. 直至活动表为空；</p><h3 id="常见的两种分支限界法："><a href="#常见的两种分支限界法：" class="headerlink" title="常见的两种分支限界法："></a>常见的两种分支限界法：</h3><p>**&#x3D;&#x3D;队列式 (FIFO)分支限界法&#x3D;&#x3D;**：从活结点表中取出结点的顺序与加入 结点的顺序相同，因此活结点表的性质与队列相同；</p><p>&#x3D;&#x3D;<strong>优先队列(代价最小或效益最大)分支限界法</strong>&#x3D;&#x3D;：每个结点都有一个对 应的耗费或收益，以此决定结点的优先级</p><h3 id="具体方法："><a href="#具体方法：" class="headerlink" title="具体方法："></a>具体方法：</h3><p>分支限界法首先确定一个合理的<strong>限界函数</strong>，并根据 限界函数确定目标函数的界[down, up]；然后按照<strong>广度优先策略遍历</strong>问题的解空间树，在某一分支上，依次搜索该结点的所有孩子结点，分别估算这些孩子结点 的目标函数的可能取值 (注意：对于最小化问题，估算结点的down，对最大化问题，估算结点的up)。 如果某<strong>孩子结点的目标函数值超出目标函数的上界或下界</strong>，则将其<strong>丢弃</strong>(即基于该结点生成的解不会比目 前已得的更好)，否则入待处理表。</p><p><img src="/img/course/image-20240106142202691.png" alt="image-20240106142202691"></p><p><img src="/img/course/image-20240106142215076.png" alt="image-20240106142215076"></p><p><img src="/img/course/image-20240106143412916.png" alt="image-20240106143412916"></p><h1 id="第8章-随机算法（了解，什么时候使用）"><a href="#第8章-随机算法（了解，什么时候使用）" class="headerlink" title="第8章 随机算法（了解，什么时候使用）"></a>第8章 随机算法（了解，什么时候使用）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随机算法是指在算法中执行某些步骤或某些动作时，所进行的选择 是随机的。 </p><p>三要素：输入实例、随机源和停止准则。 </p><p>特点：简单、快速和易于并行化。</p><h2 id="常见的随机算法分为4类："><a href="#常见的随机算法分为4类：" class="headerlink" title="常见的随机算法分为4类："></a>常见的随机算法分为4类：</h2><p>① <strong>数值随机化算法</strong>：常用于<strong>数值问题的求解</strong>，所得到的往往是近似解， 近似解的精度随着计算时间增加而不断提高； </p><p>② <strong>蒙特卡罗算法</strong>：<strong>用于求问题的准确解。</strong>对于许多问题来说，近似解毫 无意义或者不存在。该方法总能得到问题的解，但该解未必是正确的 。求得正确解的概率依赖于算法所用的时间。难以判断解是否正确； </p><p>③ <strong>拉斯维加斯算法</strong>：<strong>不会得到不正确的解，但是有时会找不到解。</strong>找到 正确解的概率随着所用的计算时间的增加而提高。对任一实例，反复 调用算法求解足够多次，可使求解失效的概率任意小； 核心思想：随机生成答案并检测答案正确性。</p><p>④ <strong>&#x3D;&#x3D;舍伍德算法&#x3D;&#x3D;<strong>：</strong>总能求得问题的一个解，且所求得的解总是正确的。</strong>当 一个确定性算法最坏情况下的计算复杂性与其在平均情况下的计算复 杂性有较大差别时，可在这个确定性算法中引入随机性将它改造成一 个舍伍德算法，消除或者减少这种差别。核心思想：<strong>设法消除或减少最坏情况与特定实例之间的关联性。</strong>利用随机算法改造已有算法，使 得算法的性能尽量与输入数据无关，即平滑算法的性能。</p><p><img src="/img/course/image-20240106141006113.png" alt="image-20240106141006113"></p><p><img src="/img/course/image-20240106135507802.png" alt="image-20240106135507802"></p><h2 id="随机算法应用"><a href="#随机算法应用" class="headerlink" title="&#x3D;&#x3D;随机算法应用&#x3D;&#x3D;"></a>&#x3D;&#x3D;随机算法应用&#x3D;&#x3D;</h2><p>1.<strong>多种洗牌算法</strong></p><p>2.<strong>s-t连通性</strong>：无向图G &#x3D; (V,E), s, t为G上两点。令n &#x3D; |V|， m &#x3D; |E|。希望确定是否存在一条连接s和t的路。S到T有路吗？</p><p>随机算法：从s开始随机游动，如果在4n^3^步之内到达t，则返 回存在一条路；否则，返回不存在路。</p><p>3.<strong>最小割随机算法</strong>：每次随机选一条边，合并该边对应的顶点。 重复该过程n-2次。最后剩下两点之间的边，就是一个割集。</p><h1 id="第9章-NP完全性理论"><a href="#第9章-NP完全性理论" class="headerlink" title="第9章 NP完全性理论"></a>第9章 NP完全性理论</h1><p>（感觉非重点，选择判断填空）</p><h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Polynomial-Time-多项式时间"><a href="#Polynomial-Time-多项式时间" class="headerlink" title="Polynomial Time (多项式时间)"></a>Polynomial Time (多项式时间)</h3><p>定义：一个称为多项式时间的算法(Polynomial-time Algorithm) 必须 符合：在合理的输入大小 (input size)下，该算法在最差情況 (Worst-case)的时间复杂度以&#x3D;&#x3D;多项式函数&#x3D;&#x3D;为限。</p><h3 id="Intractability-难解问题"><a href="#Intractability-难解问题" class="headerlink" title="Intractability (难解问题)"></a>Intractability (难解问题)</h3><p>在计算机科学领域，若無法在&#x3D;&#x3D;<strong>最差情況</strong>&#x3D;&#x3D;(Worst-case)下，以多项式时 间的算法來解决某个问题，则该问题被称为难解 (Intractable)问题 </p><p>✓ 一个难解的问题，必須<strong>沒有任何多项式时间的算法</strong>可以解它</p><h3 id="Deterministic-Algorithm-决定性算法-确定性算法"><a href="#Deterministic-Algorithm-决定性算法-确定性算法" class="headerlink" title="Deterministic Algorithm (决定性算法&#x2F;确定性算法)"></a>Deterministic Algorithm (决定性算法&#x2F;确定性算法)</h3><p>定义: 这类算法在做任何事时，该算法的下一步只有<strong>一件事</strong>可以做。 (Permitting at most one next move at any step in a computation)  </p><p>✓ 是指算法中<strong>每一个步骤的运算都需要被唯一定义</strong>，因此产生的结果也是 唯一的。 </p><p>✓ 能夠执行决定性算法的机器，称为决定性的机器 (Deterministic  Machine)。电脑就是一种决定性的机器。</p><h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><p><img src="/img/course/image-20240106131421734.png" alt="image-20240106131421734"></p><h2 id="P-、NP及NPC类问题"><a href="#P-、NP及NPC类问题" class="headerlink" title="P 、NP及NPC类问题"></a>P 、NP及NPC类问题</h2><h3 id="P-、NP及NPC定义"><a href="#P-、NP及NPC定义" class="headerlink" title="P 、NP及NPC定义"></a>P 、NP及NPC定义</h3><p>&#x3D;&#x3D;<strong>P类问题</strong>&#x3D;&#x3D;：一类问题的集合，对其中的任一问题，都存在一个确定型图灵 机M和一个多项式p，对于该问题的任何(编码)长度为n的实例，M都能在 p(n)步内，给出对该实例的回答。即：&#x3D;&#x3D;多项式时间内可被解决的问题&#x3D;&#x3D; </p><p>&#x3D;&#x3D;<strong>NP类问题</strong>&#x3D;&#x3D;：一类问题的集合，对其中的任一问题，都存在一个非确定型 图灵机M和一个多项式p，对于该问题的任何(编码) 长度为n的实例，M都 能在p(n)步内，给出对该实例的回答。&#x3D;&#x3D;<strong>多项式时间内可验证问题(指验证其解的正确性)</strong>&#x3D;&#x3D;</p><p>多一归约：假设L1和L2是两个判定问题，f将L1的每个实例I变换成L2的实 例f(I)。若对L1的每个实例I，I的答案为“是”当且仅当f(I)是L2的答案为 “是”的实例，则称f是从L1到L2的多一归约，记作L1 ≤ mL2 (传递关系) 直观意义：将求解L1的问题转换为求解L2的问题，而问题L1不会难于L2 </p><p>&#x3D;&#x3D;多项式时间多一归约&#x3D;&#x3D;：若f是多项式时间可计算，则上述归约称为多项式 时间多一归约，也称多项式时间变换。记作： </p><p>&#x3D;&#x3D;NPC问题&#x3D;&#x3D;：对于一个(判定性)问题q，若 (1) q ∈ NP; (2) NP中任一问题均可 多项式时间多一归约到q，则称问题q为NP-完全的(NP-complete，NPC) </p><p>&#x3D;&#x3D;NP-hard问题&#x3D;&#x3D;：若问题q仅满足条件(2)而不一定满足条件(1)，则问题q称 为NP-难的(NP-hard，NPH)。显然：NPC ⊆ NP-hard</p><h3 id="P、NP、NPC和NP-hard之关系"><a href="#P、NP、NPC和NP-hard之关系" class="headerlink" title="&#x3D;&#x3D;P、NP、NPC和NP-hard之关系&#x3D;&#x3D;"></a>&#x3D;&#x3D;P、NP、NPC和NP-hard之关系&#x3D;&#x3D;</h3><p><img src="/img/course/image-20240106133422515.png" alt="image-20240106133422515"></p><h2 id="NP完全问题的求解"><a href="#NP完全问题的求解" class="headerlink" title="NP完全问题的求解"></a>NP完全问题的求解</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>减少搜索量</strong>：</p><p>简单算法是穷举搜索，时间为指数 </p><p>减少搜索量：分枝限界法，隐枚举法、动态规划等。可以提高效率， 但时间复杂度不变 </p><p><strong>优化问题</strong> </p><p>降低优化要求，求近似解，以得到一个多项式时间的算法。即：找 寻在容许的时间内得到容许精度的<strong>近似最优解</strong>的算法</p><p><strong>&#x3D;&#x3D;近似算法&#x3D;&#x3D;</strong></p><p>近似算法放弃求最优解，用近似解代替最优解，以换取算法设计 上的简化和时间复杂性的降低。 </p><p>近似算法通常采用两个标准来<strong>衡量性能</strong>： </p><p>✓ 算法的**&#x3D;&#x3D;时间复杂性&#x3D;&#x3D;** </p><p>✓ 解的&#x3D;&#x3D;<strong>近似程度</strong>&#x3D;&#x3D; </p><p>• 近似比 • 相对误差λ • 相对误差界ε(n)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络空间法律法规</title>
    <link href="/2024/01/03/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"/>
    <url>/2024/01/03/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性"><a href="#1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性" class="headerlink" title="1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性"></a>1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性</h2><p>背景 (目前存在的问题)</p><p>可以对比技术来说管理</p><p>结合某一具体网络安全问题、列举具体法律法规</p><h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><p>背景：</p><p>网络空间逐步成为世界主要国家展开竞争和战略博弈的新领域。我国作为一个拥有大量网民并正在持续发展中的国家，不断感受到来自现存霸主美国的战略压力。这决定了网络空间成为我国国家利益的新边疆，确立网络空间行为准则和模式已是当务之急。目前，中国已经成为名符其实的网络大国。截至2023年6月，我国网民规模达10.79亿人。但现实的网络环境十分堪忧，网络诈骗层出不穷、网络入侵比比皆是、个人隐私肆意泄露。</p><p>网络空间安全现状</p><p><img src="/img/coursr/image-20240104110205525.png" alt="image-20240104110205525"></p><p><img src="/img/coursr/image-20240104110245672.png" alt="image-20240104110245672"></p><p>&#x3D;&#x3D;<strong>从“无法可寻”到“有法可依”，是依法治网、化解网络 空间风险的法律武器，是网络空间健康运行的重要保障。</strong>&#x3D;&#x3D;</p><p>网络空间安全中三成依靠计算机系统信息安全设备和技术保障，而七成则依靠用户安全管理意识的提高以及管理模式的更新。 </p><p>1.技术是构筑材料，管理是真正的粘合剂和催化剂。</p><p>2.网络空间安全管理构成了网空安全具有能动性的部分，是指导和控制组织的关于信息安全风险的相互协调的活动。 </p><p>3.现实世界里大多数安全事件的发生和安全隐患的存在，与其说是技术上的原因，不如说是管理不善造成的。</p><p>4.理解并重视管理对于网络空间安全的关键作用，对于真正实现网空安全目标尤其重要</p><p>2022年7月21日，在依法对滴滴公司涉嫌违法的行为进行立案调查 后，国家互联网信息办公室依据《网络安全法》《数据安全法》 《个人信息保护法》等法律法规公布了对该公司的处罚决定—— 罚款80.26亿元，对滴滴全球股份有限公司董事长兼 CEO 程维、总 裁柳青各处人民币 100 万元罚款。</p><h2 id="2、我国关键信息基础设施保护制度"><a href="#2、我国关键信息基础设施保护制度" class="headerlink" title="2、我国关键信息基础设施保护制度"></a>2、我国关键信息基础设施保护制度</h2><p>定义、重要性</p><p>关基运营者义务等</p><p>法条举例说明<br>《网络安全法》<br>《关键信息基础设施安全保护条例》…</p><h3 id="回答-1"><a href="#回答-1" class="headerlink" title="回答"></a>回答</h3><h4 id="定义，重要性："><a href="#定义，重要性：" class="headerlink" title="定义，重要性："></a>定义，重要性：</h4><p><strong>定义</strong>：本条例所称关键信息基础设施，是指公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务、国防科技工业等重要行业和领域的，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的重要网络设施、信息系统等</p><p>政务、公共通信、金融、能源、交通等重要领域的系统、设备越来越多地 采用联网的方式运行或提供服务。这些系统承载着大量的国家基础数据、重要政务数据、公民个人信息， 是网络空间安全的命脉所在。因此，&#x3D;&#x3D;<strong>我国在网络 安全等级保护制度基础上对关键信息基础设施实行重点保护,专门建立关键信息基础设施运行安全制度</strong>&#x3D;&#x3D;。</p><h4 id="关基运营者义务等"><a href="#关基运营者义务等" class="headerlink" title="关基运营者义务等"></a>关基运营者义务等</h4><p>《网络安全等级保护条例(征求意见稿)》第四条规定:网络运营者在网络建设过程中，应当 同步规划、同步建设、同步运行网络安全保护、保密和密码保护措施。涉密网络应当依据 国家保密规定和标准，结合系统实际进行保密防护和保密监管</p><p>《关键信息基础设施安全保护条例》第十二条　安全保护措施应当与关键信息基础设施同 步规划、同步建设、同步使用。</p><p>《电信条例》第六十条规定:电信业务经营者 在电信网络的设计、建设和运行中，应当做到与国家安全和电信网络安全的需求&#x3D;&#x3D;同步规划， 同步建设,同步运行&#x3D;&#x3D;。</p><h4 id="监管者义务（国家部门）说一个就行"><a href="#监管者义务（国家部门）说一个就行" class="headerlink" title="监管者义务（国家部门）说一个就行"></a>监管者义务（国家部门）说一个就行</h4><p>网络安全法第三十九条规定:“国家网信部门应当统 筹协调有关部门对关键信息基础设施的安全保护采取下列措施：</p><p>• (一)对关键信息基础设施的安全风险进行抽查检测,提出改进措施，必要时可以委托网络安全服务机构 对网络存在的安全风险进行检测评估; </p><p>• (二)定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协 同配合能力; </p><p>• (三)促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络 安全信息共享; </p><p>• (四)对网络安全事件的应急处置与网络功能的恢复等,提供技术支持和协助。</p><p>《关键信息基础设施安全保护条例》针对关键信息基础设施安全保护的统筹协作机制，列举 如下: </p><p>• 第三条 在<strong>国家网信部门</strong>统筹协调下，国务院公安部门负责指导监督关键信息基础设施安 全保护工作。国务院电信主管部门和其他有关部门依照本条例和有关法律、行政法规的规 定，在各自职责范围内负责关键信息基础设施安全保护和监督管理工作。</p><p> • 第二十三条 国家网信部门统筹协调有关部门建立网络安全信息共享机制，及时汇总、研 判、共享、发布网络安全威胁、漏洞、事件等信息，促进有关部门、保护工作部门、运营 者以及网络安全服务机构等之间的网络安全信息共享。</p><p><img src="/img/coursr/image-20240102195631273.png" alt="image-20240102195631273"></p><p>法条举例说明<br>《网络安全法》<br>&#x3D;&#x3D;《关键信息基础设施安全保护条例》&#x3D;&#x3D; </p><h2 id="3、我国个人信息保护制度"><a href="#3、我国个人信息保护制度" class="headerlink" title="3、我国个人信息保护制度"></a>3、我国个人信息保护制度</h2><p>背景、</p><p>定义 (个人信息、敏感个人信息)</p><p>个人信息处理相关制度</p><p>法条举例说明<br>《网络安全法》<br>《个人信息保护法》···</p><h3 id="回答-2"><a href="#回答-2" class="headerlink" title="回答"></a>回答</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>个人信息被誉为二十一世纪最有价值的资源。推动个人信息的合理、合法收集和使用,保障个人和企业之间 形成良好的互动关系，对于形成数字经济健康发展的制度环境至关重要。同时，大数据技术及相关产业的 发展，正前所未有地改变着个人信息的收集和使用方式,对现有的个人信息保护制度带来新的问题和挑战。 如何有效平衡个人信息的利用与保护，是各国经济发展所面临的共同问题。</p><h4 id="定义-个人信息、敏感个人信息"><a href="#定义-个人信息、敏感个人信息" class="headerlink" title="定义 (个人信息、敏感个人信息)"></a>定义 (个人信息、敏感个人信息)</h4><p><strong>个人信息</strong>是以电子或者其他方式记录的与已识别或者可识别的自然人有关的各种 信息，不包括匿名化处理后的信息。 • 个人信息的处理包括个人信息的收集、存储、使用、加工、传输、提供、公开、删除等。</p><p><strong>个人敏感信息</strong> ：一旦泄露、非法提供或滥用可能危害人身和财产安全，极易导致个人名誉、身心健 康受到损害或歧视性待遇等的个人信息。 注 1：个人敏感信息包括身份证件号码、个人生物识别信息、银行账户、通信记录和内容、财产信息、 征信信息、行踪轨迹、住宿信息、健康生理信息、交易信息、14 岁以下（含）儿童的个人信息 等。</p><h4 id="个人信息处理相关制度"><a href="#个人信息处理相关制度" class="headerlink" title="个人信息处理相关制度"></a>个人信息处理相关制度</h4><p><strong>网络安全法</strong> 第四十一条 网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。 网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双 方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息</p><p><strong>个人信息保护法</strong> 第四条　个人信息是以电子或者其他方式记录的与已识别或者可识别的自然 人有关的各种信息，不包括匿名化处理后的信息。 </p><p>个人信息的处理包括个人信息的收集、存储、使用、加工、传输、提供、公开、删除等。</p><p>确立个人信息处理应遵循的原则，强调处理个人信息应当遵循合法、正当、必要和诚信原 则，具有明确、合理的目的，限于实现处理目的的最小范围，公开处理规则，保证信息准 确，采取安全保护措施等，并将上述原则贯穿于个人信息处理的全过程、各环节。(第五条 至第九条)</p><h2 id="4、我国数据出境制度"><a href="#4、我国数据出境制度" class="headerlink" title="4、我国数据出境制度"></a>4、我国数据出境制度</h2><p>背景</p><p>定义、重要性</p><p>各主体义务</p><p>法条举例说明<br>《中华人民共和国网络安全法》<br>《中华人民共和国数据安全法》<br>《中华人民共和国个人信息保护法》<br>《数据出境安全评估办法》</p><h3 id="回答-3"><a href="#回答-3" class="headerlink" title="回答"></a>回答</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>近年来，随着数字经济的蓬勃发展，数据跨境活动日益频繁，数据处理者的数据出境需求快速增长。明确数据出境安全评估的具体规定，是促进数字经济健康发展、防范化解数据跨境安全风险的需要，是维护国家安全和社会公共利益的需要，是保护个人信息权益的需要。</p><h4 id="定义、重要性"><a href="#定义、重要性" class="headerlink" title="定义、重要性"></a>定义、重要性</h4><p><strong>数据</strong>，是指任何以电子或者其他方式对信息的记录。</p><p><strong>重要数据</strong> critical data 以电子方式存在的，一旦遭到篡改、破坏、泄露或者非法获取、非法利用，可能危害国家安全、公共利益的数据。</p><h4 id="各主体义务"><a href="#各主体义务" class="headerlink" title="各主体义务"></a>各主体义务</h4><p><strong>网络安全法</strong> </p><p>第三十七条是关于数据出境管理制度的规定:“关键信息基础设施的运营者在中 华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要, 确需向境外提供的,应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估;法 律、行政法规另有规定的，依照其规定。</p><p><strong>数据安全法</strong>• 第三十一条 关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的重要数据的出境 安全管理，适用《中华人民共和国网络安全法》的规定；其他数据处理者在中华人民共和国境内运营 中收集和产生的重要数据的出境安全管理办法，由国家网信部门会同国务院有关部门制定。 </p><p>• 第三十六条　中华人民共和国主管机关根据有关法律和中华人民共和国缔结或者参加的国际条约、协 定，或者按照平等互惠原则，处理外国司法或者执法机构关于提供数据的请求。非经中华人民共和国 主管机关批准，境内的组织、个人不得向外国司法或者执法机构提供存储于中华人民共和国境内的数 据。 </p><p>• 第四十六条　违反本法第三十一条规定，向境外提供重要数据的，由有关主管部门责令改正，给予警 告，可以并处十万元以上一百万元以下罚款，对直接负责的主管人员和其他直接责任人员可以处一万 元以上十万元以下罚款；情节严重的，处一百万元以上一千万元以下罚款，并可以责令暂停相关业务、 停业整顿、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处十 万元以上一百万元以下罚款。 数据出境管理制度 数据安全法</p><p>《<strong>个人信息保护法</strong>》第三章 第三十九条 个人信息处理者向中华人民共和国境外提供个人信息的，应当向个人 告知境外接收方的名称或者姓名、联系方式、处理目的、处理方式、个人信息的种 类以及个人向境外接收方行使本法规定权利的方式和程序等事项，并取得个人的单 独同意。 • 第四十条 关键信息基础设施运营者和处理个人信息达到国家网信部门规定数量的 个人信息处理者，应当将在中华人民共和国境内收集和产生的个人信息存储在境内。 确需向境外提供的，应当通过国家网信部门组织的安全评估；法律、行政法规和国 家网信部门规定可以不进行安全评估的，从其规定</p><h4 id="法条举例说明"><a href="#法条举例说明" class="headerlink" title="法条举例说明"></a>法条举例说明</h4><p>网络安全法第三章网络运行安全第二节关键信息基础设施的运行安全中的第 三十七条规定:“关键信息基础设施的运营者在中华人民共和国境内运营中 收集和产生的个人信息和重要数据应当在境内存储。因业务需要,确需向境 外提供的,应当按照国家网信部门会同国务院有关部门制定的办法进行安全 评估;法律、行政法规另有规定的,依照其规定。”</p><p>《中华人民共和国数据安全法》 • 第三条　本法所称数据，是指任何以电子或者其他方式对信息的记录。 　数据处理，包括数据的收集、存储、使用、加工、传输、提供、公开等。 　数据安全，是指通过采取必要措施，确保数据处于有效保护和合法利用的状态，以及具备保障 持续安全状态的能力。</p><p>第二条　在中华人民共和国境内开展数据处理活动及其安全监管，适用本法。 　在中华人民共和国境外开展数据处理活动，损害中华人民共和国国家安全、公共利 益或者公民、组织合法权益的，依法追究法律责任。 • 第十一条　国家积极开展数据安全治理、数据开发利用等领域的国际交流与合作，参与数 据安全相关国际规则和标准的制定，促进数据跨境安全、自由流动。 • 第二十五条　国家对与维护国家安全和利益、履行国际义务相关的属于管制物项的数据依 法实施出口管制。</p><h2 id="5、违法信息监管制度"><a href="#5、违法信息监管制度" class="headerlink" title="5、违法信息监管制度"></a>5、违法信息监管制度</h2><p>背景</p><p>定义</p><p>网络使用者义务、网络运营者义务等</p><p>法条举例说明<br>《中华人民共和国网络安全法》<br>《中华人民共和国数据安全法》<br>《中华人民共和国个人信息保护法》<br>《数据出境安全评估办法》</p><h3 id="回答-4"><a href="#回答-4" class="headerlink" title="回答"></a>回答</h3><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4><p>违法信息监管的立法现状 • 随着互联网的深度普及和人工智能、大数据等技术在网络信息服务领域的广泛应用,当前的网络 信息服务业务呈现出智能化、个性化和强交互的态势。网络信息发布主体的多样性、网络信息 内容的动态性、网络文化体系的开放性使得网络信息呈现出多元、多变、多样的特点。网络信 息传播速度之快、传播领域之广也体现出万物互联的特色。这也为违法信息的滋生和蔓延提供 了沃土。网络安全法的出台,对违法信息监管制度的完善提出了更高的要求,促进了网络信息服务 相关领域法律体系的完善。 </p><p>• 网络信息内容管理方面，在《互联网信息服务管理办法》统率下，国家网信办依次发布《互联 网信息搜索服务管理规定》《移动互联网应用程序服务管理规定》《互联网直播服务管理规定》 《互联网新闻信息服务管理规定》《互联网论坛社区服务管理规定》《互联网跟帖评论服务管 理规定》《互联网群组信息服务管理规定》《互联网用户公众账号信息服务管理规定》《微博 客信息服务管理规定》。互联网信息内容管理体系日臻完善。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>违法信息监管的规范性表述</strong> • 网络安全法出台之前，我国网络信息安全管理的法律法规体系尚不健全。在不同法律法规中对违 法信息类型及其规制有零散规定。 • 《全国人大常委会关于维护互联网安全的决定》中的相关规定如下: • “二、为了维护国家安全和社会稳定,对有下列行为之一,构成犯罪的,依照刑法有关规定追究刑事 责任: • (一)利用互联网造谣、诽谤或者发表、传播其他有害信息，煽动颠覆国家政权、推翻社会主义制 度,或者煽动分裂国家、破坏国家统一; • (二)通过互联网窃取、泄露国家秘密、情报或者军事秘密； • (三)利用互联网煽动民族仇恨、民族歧视，破坏民族团结; • (四)利用互联网组织邪教组织、联络邪教组织成员，破坏国家法律、行政法规实施。</p><h4 id="网络使用者的一般义务、网络运营者义务等"><a href="#网络使用者的一般义务、网络运营者义务等" class="headerlink" title="网络使用者的一般义务、网络运营者义务等"></a>网络使用者的一般义务、网络运营者义务等</h4><p><strong>网络使用者的一般义务</strong>：1、网络安全法和刑法相关规定 • 关于禁止利用网络从事违法犯罪活动，网络安全法第四十六条规定:“任何个人和组织应当 对其使用网络的行为负责,不得设立用于实施诈骗,传授犯罪方法，制作或者销售违禁物品、 管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗,制作或者销 售违禁物品、管制物品以及其他违法犯罪活动的信息。” • 关于电子信息发送者和应用软件提供者的网络信息安全义务,网络安全法第四十八条第一款 规定:“任何个人和组织发送的电子信息、提供的应用软件,不得设置恶意程序,不得含有法律、 行政法规禁止发布或者传输的信息。</p><p>网络安全法第四章网络信息安全包含第四十条至第五十条,其中第四十条至第四十五条是关 于个人信息保护制度的规定,第四十六条至第五十条是关于违法信息监管制度的规定。本章 讨论违法信息监管制度，具体包括违法信息监管制度概述、网络使用者的一般义务、网络 运营者处置违法信息的义务、网络运营者建立投诉举报制度、网络运营者配合监督检查的 义务、国家对违法信息的监督管理等</p><p>1、相关规定 • 关于<strong>网络运营者</strong>、电子信息发送服务提供者、应用软件下载服务提供者处置违法信息的义务， 网络安全法第四十七条和第四十八条第二款都有规定。 • 第四十七条规定:“网络运营者应当加强对其用户发布的信息的管理，发现法律、行政法规禁止 发布或者传输的信息的,应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存 有关记录，并向有关主管部门报告。” • 第四十八条规定:“任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不 得含有法律、行政法规禁止发布或者传输的信息。 • 电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有 前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录,并向有关主管部门 报告。</p><h2 id="等级保护制度"><a href="#等级保护制度" class="headerlink" title="等级保护制度"></a>等级保护制度</h2><p>PPT 5-10</p><h2 id="网络运行安全"><a href="#网络运行安全" class="headerlink" title="网络运行安全"></a>网络运行安全</h2><p>PPT 5-10</p><p>监测预警，应急处置：</p><p>例如：预警分几级</p>]]></content>
    
    
    
    <tags>
      
      <tag>信息安全课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AC的端口映射</title>
    <link href="/2023/12/29/AC02/"/>
    <url>/2023/12/29/AC02/</url>
    
    <content type="html"><![CDATA[<p>【全网行为管理】02-AC的端口映射</p><p>装备实验</p><p>开始实验01:00:00</p><p><img src="https://oss.edu.sangfor.com.cn/file/20230803/%E6%A0%A1%E4%BC%81%E5%B0%8F%E6%9C%8D-%E5%BC%80%E5%BF%83%E5%A4%B4%E5%83%8F2x2308031952420255fsmq.png" alt="img"></p><p>拓扑</p><p>实验手册</p><p>实验报告</p><p>声明：本实验手册仅供学习交流使用，请勿用于非法用途，违者一律自行承担所有风险！PS：本窗口支持左右拉伸</p><h1 id="AC的端口映射"><a href="#AC的端口映射" class="headerlink" title="AC的端口映射"></a>AC的端口映射</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>学会配置AC的端口映射（DNAT）功能，满足从外网访问企业内部网站的需求。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>AC作为网关部署在公司互联网出口，当有外部用户，需要访问公司网站时，需要将AC的外网IP地址与端口映射到内网网站的IP地址与端口。</p><h2 id="实验场景"><a href="#实验场景" class="headerlink" title="实验场景"></a>实验场景</h2><p>某大型集团公司，其内部新建了一套网站系统，位于微软域控服务器上。<br>要求一：现在需要从互联网（Internet-WEB server）访问该网站，访问的IP地址为AC的WAN口地址。<br>要求二：为方便内网员工访问，员工在办公区也可以使用AC的WAN口地址，访问位于于微软域控上的网站。</p><h2 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h2><p><img src="https://oss.edu.sangfor.com.cn/file/20220418/AC%E5%AE%9E%E9%AA%8C1%E9%83%A8%E7%BD%B2220418170816453o4av5.png" alt="AC实验1部署.png"></p><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><p>1、总部AC ，作总部出口网关使用<br>2、微软域控，作为总部的服务器，本实验中主要作用为WEB服务器,理解为集团公司网站。<br>3、PC1，普通办公PC，员工办公使用。<br>4、Internet-WEB Server， 本实验中，作为在互联网上的客户端，访问集团公司网站（微软域控上的网站）</p><h2 id="环境预配"><a href="#环境预配" class="headerlink" title="环境预配"></a>环境预配</h2><p>环境预配，是指已经实验场景化的配置边界。<br>实验环境中，<strong>非深信服设备，不需要学员配置。</strong>如交换机、路由器、PC、服务器。</p><p>实验环境中，<strong>深信服设备，需要学员按实验拓扑说明进行配置。</strong></p><p>实验环境中，配置基本遵循上述两条原则，<strong>少数实验例外</strong>。例外过程，在实验步骤中说明</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>一、配置总部AC的网络（操作对象：总部AC）</p><p>登录设备过程略</p><p>1.1 开始配置网络</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126162610618wmhra.png" alt="image.png"></p><p>1.2 选择路由模式</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image22012616274665461ibb.png" alt="image.png"></p><p>1.3 根据拓扑图，配置网卡，如下图</p><p>其中<br>eth1为LAN口，即办公区<br>eth2为DMZ口，即服务器区<br>eth3为WAN口，即互联网区</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271300504664knzs.png" alt="image.png"></p><p>1.4 配置eth1</p><p>eth1接办公区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131616695za1gy.png" alt="image.png"></p><p>1.5 配置eth3</p><p>eth3接互联网区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261721328713hwx0.png" alt="image.png"></p><p>1.6 配置eth2</p><p>eth2接DMZ区，即服务器区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126171325751k1dw5.png" alt="image.png"></p><p>1.7 配置代理上网</p><p>这里配置代理办公网段上网。办公网网段为192.168.1.0&#x2F;24</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261717284730snac.png" alt="image.png"></p><p>1.8 检查无误后提交</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131823425ugehh.png" alt="image.png"></p><p>二、配置从互联网访问集团网站。（操作对象：总部AC）</p><p>2.1 新建端口映射–简单规则</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271403145337uf3p.png" alt="image.png"></p><p>将AC的WAN口(124.126.100.2) TCP 8080映射到微软域控(172.16.0.100)的TCP 80</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127140423759j7ywd.png" alt="image.png"></p><p>三、使用Internet-WEB Server验证上步配置(操作对象：Internet-web Server)</p><p>因为Internet-WEB Server为Linux，所以这里使用curl命令代替浏览器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span>  <span class="hljs-number">124.126.100.2:8080</span><br></code></pre></td></tr></table></figure><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271407259700o68v.png" alt="image.png"></p><p>如图，访问成功。</p><p>四、解决办公网PC使用互联网地址访问域控的问题。（操作对象：总部AC）</p><p>为了解决办公网PC使用互联网地址访问微软域控的问题,我们可以在总部AC的LAN口进行目标地址转换工作。</p><p>操作如下：</p><p>4.1 新增端口映射–&gt;高级规则</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201272156011339zx3c.png" alt="image.png"></p><p>4.2 配置DNAT生效的端口、源IP、目标IP</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127215950742uq3xl.png" alt="image.png"></p><p>继续向下滚动</p><p>4.3 配置DNAT生效的源端口、目标端口</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127220223558zm4sm.png" alt="image.png"></p><p>4.4 配置DNAT转换后的IP与端口（即微软域控的80端口）</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127220353193qwrwp.png" alt="image.png"></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>当从WAN口使用WAN口IP地址访问DMZ区服务器时， 端口映射规则（DNAT）在WAN口生效。普通端口映射多数是这种原理。</p><p>当从LAN口使用WAN口IP地址访问DMZ区服务器时， 端口映射规则（DNAT）在LAN口生效。此类规则比较少见，属于端口映射的高级规则。</p><h2 id="实验思考（有能力与时间可以学习）"><a href="#实验思考（有能力与时间可以学习）" class="headerlink" title="实验思考（有能力与时间可以学习）"></a>实验思考（有能力与时间可以学习）</h2><p>当从DMZ其他服务器使用WAN口IP地址访问DMZ区服务器时，如果同样的方法，配置端口映射高级规则，能否生效？为什么？</p><p>答案：</p><p>不能生效。假设DMZ其他服务器IP地址是172.16.0.200</p><p>其原因如下图</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/%E4%BC%9A%E8%AF%9D%E4%B8%8D%E4%B8%80%E8%87%B4.drawio1220127222325568ph3hs.png" alt="会话不一致.drawio 1.png"></p><p><strong>思考：如何解决会话不一致的问题？</strong></p><p>答案：</p><p>在AC转换DNAT的同时，也转一下SNAT，原理如下图</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/%E4%BC%9A%E8%AF%9D%E4%B8%8D%E4%B8%80%E8%87%B42.drawio220127223100041ythhx.png" alt="会话不一致2.drawio.png"></p><p>深信服设备操作方法，在新建端口映射高级规则的最后，钩选发布服务器即可。</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127223425920t28lm.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>深信服</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AC的路由模式部署</title>
    <link href="/2023/12/29/AC01/"/>
    <url>/2023/12/29/AC01/</url>
    
    <content type="html"><![CDATA[<p>【全网行为管理】01-AC的路由模式部署</p><p>装备实验</p><p>开始实验01:00:00</p><p><img src="https://oss.edu.sangfor.com.cn/file/20230803/%E6%A0%A1%E4%BC%81%E5%B0%8F%E6%9C%8D-%E5%BC%80%E5%BF%83%E5%A4%B4%E5%83%8F2x2308031952420255fsmq.png" alt="img"></p><p>拓扑</p><p>实验手册</p><p>实验报告</p><p>声明：本实验手册仅供学习交流使用，请勿用于非法用途，违者一律自行承担所有风险！PS：本窗口支持左右拉伸</p><h1 id="AC的路由模式部署"><a href="#AC的路由模式部署" class="headerlink" title="AC的路由模式部署"></a>AC的路由模式部署</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>理解深信服上网行为管理设备（下面简称AC），作为公司网关部署的过程与原理</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>AC作为网关部署在公司互联网出口，其原理与传统路由器一致。主要作用完成用户的SNAT上网工作，以及从外向内访问服务器的DNAT工作。本实验，我们主要讲述SNAT的部署过程。</p><h2 id="实验场景"><a href="#实验场景" class="headerlink" title="实验场景"></a>实验场景</h2><p>某大型集团公司，其集团总部为了管理公司内部PC上网，计划使用AC来代替传统路由器，解决用户上网认证、网速管理、日志审计等问题。本实验是部署AC的第一步场景。</p><h2 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h2><p><img src="https://oss.edu.sangfor.com.cn/file/20220418/AC%E5%AE%9E%E9%AA%8C1%E9%83%A8%E7%BD%B2220418170816453o4av5.png" alt="AC实验1部署.png"></p><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><p>1、总部AC ，作总部出口网关使用<br>2、微软域控，作为总部的服务器，本实验中主要作用为WEB服务器,理解为集团公司网站。<br>3、PC1，普通办公PC，员工办公使用，需要连接互联网<br>4、Internet-WEB Server，互联网上的WEB服务器，理解为类似sina，baidu等站点。</p><h2 id="环境预配"><a href="#环境预配" class="headerlink" title="环境预配"></a>环境预配</h2><p>环境预配，是指已经实验场景化的配置边界。<br>实验环境中，<strong>非深信服设备，不需要学员配置。</strong>如交换机、路由器、PC、服务器。</p><p>实验环境中，<strong>深信服设备，需要学员按实验拓扑说明进行配置。</strong></p><p>实验环境中，配置基本遵循上述两条原则，<strong>少数实验例外</strong>。例外过程，在实验步骤中说明</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>一、配置总部AC的网络（操作对象：总部AC）</p><p>登录设备过程略</p><p>1.1 开始配置网络</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126162610618wmhra.png" alt="image.png"></p><p>1.2 选择路由模式</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image22012616274665461ibb.png" alt="image.png"></p><p>1.3 根据拓扑图，配置网卡，如下图</p><p>其中<br>eth1为LAN口，即办公区<br>eth2为DMZ口，即服务器区<br>eth3为WAN口，即互联网区</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271300504664knzs.png" alt="image.png"></p><p>1.4 配置eth1</p><p>eth1接办公区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131616695za1gy.png" alt="image.png"></p><p>1.5 配置eth3</p><p>eth3接互联网区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261721328713hwx0.png" alt="image.png"></p><p>1.6 配置eth2</p><p>eth2接DMZ区，即服务器区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126171325751k1dw5.png" alt="image.png"></p><p>1.7 配置代理上网</p><p>这里配置代理办公网段上网。办公网网段为192.168.1.0&#x2F;24</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261717284730snac.png" alt="image.png"></p><p>1.8 检查无误后提交</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131823425ugehh.png" alt="image.png"></p><p>二、检查PC1上网是否正常（操作对象：PC1）</p><p>打开PC1 桌面上的浏览器，访问Internet-WEB,即124.126.200.2</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271323141379lfx0.png" alt="image.png"></p><p>访问正常</p><p>三、查看微软域控能否访问互联网（操作对象：微软域控）</p><p>打开桌面上浏览器，访问Internet-WEB,即124.126.200.2</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image22012713251368961evi.png" alt="image.png"></p><p>发现无法访问，因为在AC中仅做了办公网段的代理上网，而没有做服务器网段代理上网。</p><p>四、查看PC1能否访问域控制器上的WEB页面（操作对象：PC1）</p><p>打开PC1 桌面上的浏览器，访问微软域控的WEB,即172.16.0.100</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image22012713302885578qp5.png" alt="image.png"></p><p>可以访问。因为PC1与微软域控，同在内网，路由直接可达。</p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过本实验，理解AC的网关部署原理，和传统路由器作网关原理一致。AC所谓的“代理上网”理解为SNAT，即源地址转换。</p>]]></content>
    
    
    
    <tags>
      
      <tag>深信服</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户认证技术之无需认证</title>
    <link href="/2023/12/29/AC03/"/>
    <url>/2023/12/29/AC03/</url>
    
    <content type="html"><![CDATA[<p>【全网行为管理】03-用户认证技术之无需认证</p><p>装备实验</p><p>开始实验01:00:00</p><p><img src="https://oss.edu.sangfor.com.cn/file/20230803/%E6%A0%A1%E4%BC%81%E5%B0%8F%E6%9C%8D-%E5%BC%80%E5%BF%83%E5%A4%B4%E5%83%8F2x2308031952420255fsmq.png" alt="img"></p><p>拓扑</p><p>实验手册</p><p>实验报告</p><p>声明：本实验手册仅供学习交流使用，请勿用于非法用途，违者一律自行承担所有风险！PS：本窗口支持左右拉伸</p><h1 id="用户认证技术之无需认证"><a href="#用户认证技术之无需认证" class="headerlink" title="用户认证技术之无需认证"></a>用户认证技术之无需认证</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>学会配置AC的用户认证，本实验中不会强制认证，即无需认证。AC会以用户的IP地址作为用户标识，记录用户行为。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>AC作为网关部署在公司互联网出口，当用户访问网络的流量经过AC时，AC记录用户的IP作为用户标识。</p><h2 id="实验场景"><a href="#实验场景" class="headerlink" title="实验场景"></a>实验场景</h2><p>某大型集团公司，内部PC均使用固定IP地址。现在要通过IP地址审计用户上网行为。要求对用户上网不要造成任何影响。</p><h2 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h2><p><img src="https://oss.edu.sangfor.com.cn/file/20220418/AC%E5%AE%9E%E9%AA%8C3220418170945177dcp10.png" alt="AC实验3.png"></p><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><p>1、总部AC ，作总部出口网关使用<br>2、PC1，普通办公PC，员工办公使用。<br>3、PC2，普通办公PC，员工办公使用。<br>4、Internet-WEB Server， 作为在互联网上的服务器</p><h2 id="环境预配"><a href="#环境预配" class="headerlink" title="环境预配"></a>环境预配</h2><p>环境预配，是指已经实验场景化的配置边界。<br>实验环境中，<strong>非深信服设备，不需要学员配置。</strong>如交换机、路由器、PC、服务器。</p><p>实验环境中，<strong>深信服设备，需要学员按实验拓扑说明进行配置。</strong></p><p>实验环境中，配置基本遵循上述两条原则，<strong>少数实验例外</strong>。例外过程，在实验步骤中说明</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>一、配置总部AC的网络（操作对象：总部AC）</p><p>登录设备过程略</p><p>1.1 开始配置网络</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126162610618wmhra.png" alt="image.png"></p><p>1.2 选择路由模式</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image22012616274665461ibb.png" alt="image.png"></p><p>1.3 根据拓扑图，配置网卡，如下图</p><p>其中<br>eth1为LAN口，即办公区<br>eth2为DMZ口，即服务器区<br>eth3为WAN口，即互联网区</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271300504664knzs.png" alt="image.png"></p><p>1.4 配置eth1</p><p>eth1接办公区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131616695za1gy.png" alt="image.png"></p><p>1.5 配置eth3</p><p>eth3接互联网区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261721328713hwx0.png" alt="image.png"></p><p>1.6 配置eth2</p><p>eth2接DMZ区，即服务器区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126171325751k1dw5.png" alt="image.png"></p><p>1.7 配置代理上网</p><p>这里配置代理办公网段上网。办公网网段为192.168.1.0&#x2F;24</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261717284730snac.png" alt="image.png"></p><p>1.8 检查无误后提交</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131823425ugehh.png" alt="image.png"></p><p>二、配置认证策略。（操作对象：总部AC）</p><p>2.1 查看当前认证策略</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210180917320uf7z3.png" alt="image.png"></p><p>在深信服上网行为管理中，默认对所有的IP地址均无需认证。</p><p>2.2 对办公网段，定义无需认证</p><p>办公网段IP为192.168.1.0&#x2F;24</p><p>配置如下</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202101813416487yxqy.png" alt="image.png"></p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202101814155104yfer.png" alt="image.png"></p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image22021018183325235088.png" alt="image.png"></p><p>2.3 查看定义的认证策略</p><p>AC在匹配认证策略时，会从上往下依次匹配，所以这里要注意认证策略的先后关系。</p><p>确保我们在2.2中新建的策略优先级最高。</p><p>这样才能保证我们新建的策略优先级高于默认策略。用户才能到default组</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210182007865vmcky.png" alt="image.png"></p><p>三、使用PC1上网，生成认证数据。 (操作对象:PC1)</p><p>使用PC1的浏览器，访问Internet-WEB Server服务器,即124.126.200.2</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202101822311520p7tx.png" alt="image.png"></p><p>四、使用PC2上网，生成认证数据。 (操作对象:PC2)</p><p>使用PC2的浏览器，访问Internet-WEB Server服务器,即124.126.200.2</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202101822311520p7tx.png" alt="image.png"></p><p>五、查看AC的用户认证状态 (操作对象：总部AC)</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image22021018341041035hca.png" alt="image.png"></p><h2 id="实验思考（有能力与时间可以学习）"><a href="#实验思考（有能力与时间可以学习）" class="headerlink" title="实验思考（有能力与时间可以学习）"></a>实验思考（有能力与时间可以学习）</h2><p>上述实验过程中，使用的是IP地址作为用户名。如下图</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202101814155104yfer.png" alt="image.png"></p><p>思考下面几个问题</p><p>1、什么情况下可以使用MAC地址作为用户名？</p><p>2、什么情况下不可以使用MAC地址作用用户名？怎么样解决这个问题？</p><p>答案如下：</p><p>1、AC如果想使用MAC地址作为用户名，那么AC必须要知道PC1与PC2的MAC地址，当AC与PC1、PC2处于同一广播域，可以使用ARP协议，获取PC1与PC2的MAC地址，进而使用MAC地址作为用户名</p><p>2、如果AC与PC不处于同一广播域，那么AC无法通过ARP获取PC的MAC地址，无法使用MAC地址作用用户名。<br>解决方法：<br>AC与PC不处于同一广播域，在大型公司网络中非常常见，通常中间会跨跃三层交换机。</p><p>此时可以使AC的通过手段读取办公PC的IP与MAC地址映射关系，来实现MAC地址验证。</p><p>常见的手段有<br>1、通过映射端口流量读取ARP或DHCP<br>2、通过SNMP取三层交换机的IP与MAC对应关系</p><p>配置界面如下</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210184617124lq45l.png" alt="image.png"></p><p>关于MAC地址认证小结：</p><p>其本质就是AC要获取到PC的IP与MAC地址对应关系。</p>]]></content>
    
    
    
    <tags>
      
      <tag>深信服</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户认证技术之密码认证</title>
    <link href="/2023/12/29/AC04/"/>
    <url>/2023/12/29/AC04/</url>
    
    <content type="html"><![CDATA[<p>【全网行为管理】04-用户认证技术之密码认证</p><p>装备实验</p><p>开始实验01:00:00</p><p><img src="https://oss.edu.sangfor.com.cn/file/20230803/%E6%A0%A1%E4%BC%81%E5%B0%8F%E6%9C%8D-%E5%BC%80%E5%BF%83%E5%A4%B4%E5%83%8F2x2308031952420255fsmq.png" alt="img"></p><p>拓扑</p><p>实验手册</p><p>实验报告</p><p>声明：本实验手册仅供学习交流使用，请勿用于非法用途，违者一律自行承担所有风险！PS：本窗口支持左右拉伸</p><h1 id="用户认证技术之密码认证"><a href="#用户认证技术之密码认证" class="headerlink" title="用户认证技术之密码认证"></a>用户认证技术之密码认证</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>学会配置AC的内部用户，要求用户在上网时，使用AC的内置账户进行认证，才允许上网。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>AC作为网关部署在公司互联网出口，当用户访问网络时，需要使用分配的用户名和密码进行认证，才允许上网。</p><h2 id="实验场景"><a href="#实验场景" class="headerlink" title="实验场景"></a>实验场景</h2><p>某大型集团公司，内部用户上网处于无法管理的状态，也无法识别用户，不符合网络安全相关管理制度。</p><p>现在要求管理员在AC内给每个用户建立一个账号，用户上网时，必须要经过账号验证，才能获取上网权限。</p><h2 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h2><p><img src="https://oss.edu.sangfor.com.cn/file/20220418/AC%E5%AE%9E%E9%AA%8C3220418170945177dcp10.png" alt="AC实验3.png"></p><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><p>1、总部AC ，作总部出口网关使用<br>2、PC1，普通办公PC，员工办公使用。<br>3、PC2，普通办公PC，员工办公使用。<br>4、Internet-WEB Server， 作为在互联网上的服务器</p><h2 id="环境预配"><a href="#环境预配" class="headerlink" title="环境预配"></a>环境预配</h2><p>环境预配，是指已经实验场景化的配置边界。<br>实验环境中，<strong>非深信服设备，不需要学员配置。</strong>如交换机、路由器、PC、服务器。</p><p>实验环境中，<strong>深信服设备，需要学员按实验拓扑说明进行配置。</strong></p><p>实验环境中，配置基本遵循上述两条原则，<strong>少数实验例外</strong>。例外过程，在实验步骤中说明</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>一、配置总部AC的网络（操作对象：总部AC）</p><p>登录设备过程略</p><p>1.1 开始配置网络</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126162610618wmhra.png" alt="image.png"></p><p>1.2 选择路由模式</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image22012616274665461ibb.png" alt="image.png"></p><p>1.3 根据拓扑图，配置网卡，如下图</p><p>其中<br>eth1为LAN口，即办公区<br>eth2为DMZ口，即服务器区<br>eth3为WAN口，即互联网区</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271300504664knzs.png" alt="image.png"></p><p>1.4 配置eth1</p><p>eth1接办公区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131616695za1gy.png" alt="image.png"></p><p>1.5 配置eth3</p><p>eth3接互联网区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261721328713hwx0.png" alt="image.png"></p><p>1.6 配置eth2</p><p>eth2接DMZ区，即服务器区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126171325751k1dw5.png" alt="image.png"></p><p>1.7 配置代理上网</p><p>这里配置代理办公网段上网。办公网网段为192.168.1.0&#x2F;24</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261717284730snac.png" alt="image.png"></p><p>1.8 检查无误后提交</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131823425ugehh.png" alt="image.png"></p><p>二、新建AC的内置账户（操作对象：总部AC）</p><p>2.1 新建用户组</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image22021018592145159oxc.png" alt="image.png"></p><p>输入组名</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210185957983cru1q.png" alt="image.png"></p><p>2.2 新建用户</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202101901202331ma34.png" alt="image.png"></p><p>新建用户zhangsan 密码Sangfor!7890</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210190424698cjwna.png" alt="image.png"></p><p>新建用户lisi 密码Sangfor!7890</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210190536469s8wdi.png" alt="image.png"></p><p>三、配置AC的认证策略 （操作对象：总部AC）</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202101813416487yxqy.png" alt="image.png"></p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202101909220900w86u.png" alt="image.png"></p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210191011313p96bf.png" alt="image.png"></p><p>四、使用PC1上网测试 （操作对象：PC1）</p><p>使用PC1的浏览器，访问Internet-WEB Server服务器,即124.126.200.2</p><p>会自动跳转到如下页面</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210191156872yrrua.png" alt="image.png"></p><p>登录成功后，会自动跳转到之前的访问页面，即124.126.200.2</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202101822311520p7tx.png" alt="image.png"></p><p>五、查看用户认证状态（操作对象：总部AC）</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210191456131nwi91.png" alt="image.png"></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>前面实验仅仅实验了最简单的认证。</p><p>思考一下：</p><p>如果公司想规避更多的上网问题，例如</p><p>如何防止员工，共享同一个账户去上网？</p><p>如何防止员工，借用其他人的账户去上网？</p><p>如何使员工的账户只能在指定的IP地址上登录？</p><p>这些问题在刚才的配置中，属于一些只需稍加一点配置即可实现，大家可以进一步自行研究。</p><p>关键信息是“用户绑定”。</p>]]></content>
    
    
    
    <tags>
      
      <tag>深信服</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户认证技术之外部认证</title>
    <link href="/2023/12/29/AC05/"/>
    <url>/2023/12/29/AC05/</url>
    
    <content type="html"><![CDATA[<p>【全网行为管理】05-用户认证技术之外部认证</p><p>装备实验</p><p>开始实验01:00:00</p><p><img src="https://oss.edu.sangfor.com.cn/file/20230803/%E6%A0%A1%E4%BC%81%E5%B0%8F%E6%9C%8D-%E5%BC%80%E5%BF%83%E5%A4%B4%E5%83%8F2x2308031952420255fsmq.png" alt="img"></p><p>拓扑</p><p>实验手册</p><p>实验报告</p><p>声明：本实验手册仅供学习交流使用，请勿用于非法用途，违者一律自行承担所有风险！PS：本窗口支持左右拉伸</p><h1 id="用户认证技术之外部认证"><a href="#用户认证技术之外部认证" class="headerlink" title="用户认证技术之外部认证"></a>用户认证技术之外部认证</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>学本配置AC的用户认证功能，结合微软域控服务器上的域用户，实现用户认证。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>AC作为网关部署在公司互联网出口，微软AD是微软公司推出统一管理用户和计算机的活动目录。大型企业通常会使用微软AD来进行内部办公网的统一管理。本实验，将微软AD的用户，导入到深信服AC中，当用户上网时，使用微软AD中的用户实现密码验证。</p><h2 id="实验场景"><a href="#实验场景" class="headerlink" title="实验场景"></a>实验场景</h2><p>某大型集团公司，内部用户上网处于无法管理的状态，也无法识别用户，不符合网络安全相关管理制度。</p><p>现在要求管理员结合公司现有的微软域控服务器，对办公区上网用户进行身份识别，上网验证账号为域控服务器上的域账号。</p><h2 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h2><p><img src="https://oss.edu.sangfor.com.cn/file/20220418/%E5%AE%9E%E9%AA%8C5220418171100176bql5o.png" alt="实验5.png"></p><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><p>1、总部AC ，作总部出口网关使用<br>2、微软域控，作为总部的服务器，本实验中主要作用为WEB服务器,理解为集团公司网站。（本实验中，域控的名称为sangfor.edu,已有域用户zhangsan,lisi，同时有域用户admin作为同步账号，上述三个域用户的密码均为Sangfor!7890）<br>3、PC1，普通办公PC，员工办公使用。<br>4、Internet-WEB Server， 作为在互联网上的服务器</p><p><strong>域用户配置如下图</strong></p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210222810192oqxkn.png" alt="image.png"></p><h2 id="环境预配"><a href="#环境预配" class="headerlink" title="环境预配"></a>环境预配</h2><p>环境预配，是指已经实验场景化的配置边界。<br>实验环境中，<strong>非深信服设备，不需要学员配置。</strong>如交换机、路由器、PC、服务器。</p><p>实验环境中，<strong>深信服设备，需要学员按实验拓扑说明进行配置。</strong></p><p>实验环境中，配置基本遵循上述两条原则，<strong>少数实验例外</strong>。例外过程，在实验步骤中说明</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>一、配置总部AC的网络（操作对象：总部AC）</p><p>登录设备过程略</p><p>1.1 开始配置网络</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126162610618wmhra.png" alt="image.png"></p><p>1.2 选择路由模式</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image22012616274665461ibb.png" alt="image.png"></p><p>1.3 根据拓扑图，配置网卡，如下图</p><p>其中<br>eth1为LAN口，即办公区<br>eth2为DMZ口，即服务器区<br>eth3为WAN口，即互联网区</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271300504664knzs.png" alt="image.png"></p><p>1.4 配置eth1</p><p>eth1接办公区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131616695za1gy.png" alt="image.png"></p><p>1.5 配置eth3</p><p>eth3接互联网区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261721328713hwx0.png" alt="image.png"></p><p>1.6 配置eth2</p><p>eth2接DMZ区，即服务器区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126171325751k1dw5.png" alt="image.png"></p><p>1.7 配置代理上网</p><p>这里配置代理办公网段上网。办公网网段为192.168.1.0&#x2F;24</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261717284730snac.png" alt="image.png"></p><p>1.8 检查无误后提交</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131823425ugehh.png" alt="image.png"></p><p>二、查看同步用户的识别标识 （操作对象：微软域控）</p><p>2.1 打开用户和计算机管理，高级功能<br><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202102235468170m9ls.png" alt="image.png"></p><p>2.2 查看用户admin的属性</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202102238496507w8xx.png" alt="image.png"></p><p>找到用户admin的识别标识属性</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210224041551dqvo3.png" alt="image.png"></p><p>如图中是：<br>CN&#x3D;admin,OU&#x3D;sfusers,DC&#x3D;sangfor,DC&#x3D;edu<br>此属性可以在活动目录中唯一标识出用户admin，记住此串属性，后面会用到。</p><p>三、配置外部认证服务器（操作对象：总部AC）</p><p>3.1 新增LDAP认证服务器</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210223209595owjex.png" alt="image.png"></p><p>3.2 配置LDAP服务器（即微软域控）</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210224647289bfn6f.png" alt="image.png"></p><p>继续选择要从微软域控同步到AC的组织单元</p><p>【BaseDN】含义是指定域搜索路径的起点，该起点决定了该路径下的所有用户会被搜索到。</p><p>这里选择sfusers</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202102248391271p7om.png" alt="image.png"></p><p>3.3 测试当前配置是否有效</p><p>测试有效性</p><p>用户名zhangsan,密码Sangfor!7890</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210225028967l1psk.png" alt="image.png"></p><p>测试结果有效</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210225105010wkp1f.png" alt="image.png"></p><p>上述测试有效，表明外部认证服务器配置正常。否则请仔细检查配置。</p><p>四、配置AC认证策略(操作对象：总部AC)</p><p>4.1 新增认证策略<br><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210225339790i2luf.png" alt="image.png"></p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210225443949yj5m1.png" alt="image.png"></p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210225758068ew193.png" alt="image.png"></p><p>五、使用PC1上网验证（操作对象：PC01）</p><p>5.1 域用户验证</p><p>使用PC1的浏览器，访问Internet-WEB Server服务器,即124.126.200.2</p><p>会自动跳转到如下页面</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210191156872yrrua.png" alt="image.png"></p><p>登录成功后，会自动跳转到之前的访问页面，即124.126.200.2</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image2202101822311520p7tx.png" alt="image.png"></p><p>5.2 查看当前的用户身份</p><p>使用浏览器访问AC的WAN口IP地址，即124.126.100.2</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220210/image220210230228978b482f.png" alt="image.png"></p><p>可以看到当前的zhangsan是属于sfusers的域用户。</p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>微软AD域作为企业进行用户集中管理的服务器，在企业身份验证过程中起着重要作用。本实验使用了密码登录，来登录域用户。对用户的使用习惯有一定影响。</p><p>更进一步要求，我们可以结合微软AD域，将PC01进行加域操作，然后使用域用户zhangsan登录PC01，在AC上，实现单点登录，减少用户的操作。</p><p>其具体实验原理是AC获取到IP地址与域用户的对应关系，来完成单点登录，减少用户复杂度要求。</p><h2 id="实验思考（有能力与时间可以学习）"><a href="#实验思考（有能力与时间可以学习）" class="headerlink" title="实验思考（有能力与时间可以学习）"></a>实验思考（有能力与时间可以学习）</h2>]]></content>
    
    
    
    <tags>
      
      <tag>深信服</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件系统安全</title>
    <link href="/2023/12/27/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    <url>/2023/12/27/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h1><h2 id="软件安全的重要性"><a href="#软件安全的重要性" class="headerlink" title="软件安全的重要性"></a>软件安全的重要性</h2><h3 id="软件的定义"><a href="#软件的定义" class="headerlink" title="软件的定义"></a>软件的定义</h3><p>–1983年IEEE为软件下的定义是：计算机程序、方法、规则和相关的文档资料以及在计算机上运行时所需的数据</p><p>–通俗解释：<strong>软件</strong> <strong>&#x3D;</strong> <strong>程序</strong> <strong>+</strong> <strong>数据</strong> <strong>+</strong> <strong>文档资料</strong></p><p>•程序是完成特定功能和满足性能要求的指令序列</p><p>•数据是程序运行的基础和操作的对象</p><p>文档与程序开发、维护和使用有关的图文资料</p><h3 id="软件的分类"><a href="#软件的分类" class="headerlink" title="软件的分类"></a>软件的分类</h3><h4 id="按软件的功能分类"><a href="#按软件的功能分类" class="headerlink" title="按软件的功能分类"></a>按软件的<strong>功能</strong>分类</h4><p> docker import filename.tar - imagename:versionpowershell</p><p>§为计算机使用提供最基本的功能</p><p>§Windows、Linux、Android、IOS</p><p>•<strong>应用软件</strong></p><p>§为了某种特定的用途而被开发的软件</p><p>§Ms Office、QQ、迅雷</p><p>•<strong>支撑软件</strong></p><p>§支持软件的开发、维护与运行的软件</p><p>§编译器，数据库管理系统，软件开发工具 (Visual Studio)</p><h4 id="按软件运行平台划分"><a href="#按软件运行平台划分" class="headerlink" title="按软件运行平台划分"></a>按软件<strong>运行平台</strong>划分</h4><p>–服务器端软件</p><p>–PC端软件</p><p>–手机应用软件</p><p>嵌入式软件</p><h2 id="软件安全的概念"><a href="#软件安全的概念" class="headerlink" title="软件安全的概念"></a><strong>软件安全的概念</strong></h2><h3 id="什么是安全"><a href="#什么是安全" class="headerlink" title="*什么是安全"></a>*什么是安全</h3><p>安全是指不受威胁，没有危险，不受危害，不受损失的一种<strong>可接受状态。</strong></p><h3 id="软件安全："><a href="#软件安全：" class="headerlink" title="*软件安全："></a>*软件安全：</h3><p>–提供<strong>表示</strong>、<strong>分析</strong>和<strong>追踪</strong>具有危害性功能的软件<strong>缓解措施与控制</strong>的系统性方法</p><p>–<strong>采取工程的方法使得软件</strong>受到恶意攻击的情形下依然能够继续正确运行</p><h3 id="软件安全问题的根源是软件存在弱点"><a href="#软件安全问题的根源是软件存在弱点" class="headerlink" title="*软件安全问题的根源是软件存在弱点"></a>*软件安全问题的根源是软件存在弱点</h3><p>•软件存在弱点</p><p>•现有方法并不能解决软件安全问题</p><p>​–反病毒程序和防火墙之类的保护程序</p><p>​–密码学之类的信息加密技术</p><h3 id="软件的安全属性-CIA属性-："><a href="#软件的安全属性-CIA属性-：" class="headerlink" title="*软件的安全属性(CIA属性)："></a>*软件的安全属性(CIA属性)：</h3><p><strong>保密性、完整性、可用性、可认证性、授权、可审计性、抗抵赖性、可控性、可存活性</strong></p><h3 id="软件缺陷（Defect），常常又被称作Bug"><a href="#软件缺陷（Defect），常常又被称作Bug" class="headerlink" title="软件缺陷（Defect），常常又被称作Bug"></a>软件缺陷（<strong>Defect</strong>），常常又被称作<strong>Bug</strong></h3><p>§指计算机软件或程序中存在的某种破坏正常运行能力的问题、错误、或者隐蔽的功能缺陷。</p><h3 id="软件漏洞"><a href="#软件漏洞" class="headerlink" title="*软件漏洞"></a>*软件漏洞</h3><p>•软件漏洞（<strong>Vulnerability</strong>）是指软件在设计、实现、配置策略及使用过程中出现的缺陷，其可能导致攻击者能够<strong>在未授权的情况下</strong>访问或破坏系统。</p><h3 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a><strong>恶意软件</strong></h3><p>•恶意软件是对非用户期望运行的、怀有恶意目的或完成恶意功能的软件的统称</p><p>恶意软件的恶意行为：</p><p><strong>篡改或破坏已有的软件功能</strong></p><p><strong>窃取重要数据</strong></p><p><strong>监视用户行为</strong></p><p><strong>控制目标系统</strong></p><p>•典型恶意软件种类</p><p>计算机病毒、蠕虫、特洛伊木马、后门、僵尸、间谍软件等</p><h3 id="软件侵权"><a href="#软件侵权" class="headerlink" title="软件侵权"></a><strong>软件侵权</strong></h3><p>•软件版权是指软件作者对其创作的作品享有的人身权和财产权</p><h1 id="软件逆向工程基础"><a href="#软件逆向工程基础" class="headerlink" title="软件逆向工程基础"></a>软件逆向工程基础</h1><h3 id="逆向工程定义"><a href="#逆向工程定义" class="headerlink" title="*逆向工程定义"></a>*逆向工程定义</h3><p>一种分析目标系统的过程, 其目的是识别出系统的各个组件以及它们之间的关系, 并在较高的抽象层次上以另一形式创建对系统的表示[1], 从而理解目标系统的结构和行为。</p><h3 id="软件逆向工程的基本方法"><a href="#软件逆向工程的基本方法" class="headerlink" title="*软件逆向工程的基本方法"></a>*软件逆向工程的基本方法</h3><p>逆向工程的主要活动: 反汇编 + 分析 + 可能的修改(破解)</p><p><img src="/img/course/image-20231222144908011.png" alt="image-20231222144908011"></p><p>•<strong>静态方法</strong></p><p>–分析但不运行代码</p><p>–较动态方法更为安全</p><p>–反汇编器，如IDA Pro，objdump等</p><p>•<strong>动态方法</strong></p><p>–检查进程执行过程中寄存器、内存值的实时变化</p><p>–允许操作进程，通常应在虚拟机中运行</p><p>–调试器，如Windows下的WinDBG, Immunity, OllyDBG等,及Linux下的GDB</p><h3 id="软件逆向工程的典型应用场景"><a href="#软件逆向工程的典型应用场景" class="headerlink" title="软件逆向工程的典型应用场景"></a>软件逆向工程的典型应用场景</h3><p>•<strong>恶意代码分析</strong></p><p>•<strong>闭源软件漏洞分析</strong></p><p>•<strong>闭源软件互操作性分析</strong></p><p><strong>验证编译器的性能和准确性；调试器中生成汇编代码清单</strong></p><h3 id="GDB调试常用命令"><a href="#GDB调试常用命令" class="headerlink" title="*GDB调试常用命令"></a>*GDB调试常用命令</h3><p><img src="/img/course/image-20231222145048805.png" alt="image-20231222145048805"></p><h3 id="字节序"><a href="#字节序" class="headerlink" title="*字节序"></a>*字节序</h3><p>字节序：多字节数据在内存中存储或在网络上传输时各字节的存储&#x2F;传输顺序</p><p>–<strong>小端序（little</strong> <strong>endian）</strong>：低位字节存储在内存中低位地址,效率较高(Intel CPU使用)</p><p>–<strong>大端序（big endian）</strong>：低位字节存储在内存中高位地址,符合思维逻辑。RISC架构处理器(如MIPS, PowerPC)采用</p><h4 id="通用寄存器-GPR"><a href="#通用寄存器-GPR" class="headerlink" title="通用寄存器(GPR)"></a><strong>通用寄存器</strong><strong>(GPR)</strong></h4><p>•<strong>EBP:</strong> <strong>栈内数据指针, 栈帧的基地址, 用于为函数调用创建栈帧</strong></p><p>•<strong>ESP:</strong> <strong>栈指针, 栈区域的栈顶地址</strong></p><h4 id="汇编指令格式"><a href="#汇编指令格式" class="headerlink" title="汇编指令格式"></a><strong>汇编指令格式</strong></h4><p>•AT&amp;T: source在destination前, 在较早期的GNU工具中普遍使用（如gcc,gdb等）</p><p>•Intel : destination在source前,“[… ]”含义类似于解引用,MASM,NASM等工具中使用</p><p><img src="/img/course/image-20231222135332941.png" alt="image-20231222135332941"></p><h1 id="函数调用与内存破坏漏洞"><a href="#函数调用与内存破坏漏洞" class="headerlink" title="函数调用与内存破坏漏洞"></a>函数调用与内存破坏漏洞</h1><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a><strong>进程地址空间</strong></h3><p><img src="/img/course/image-20231222140815686.png" alt="image-20231222140815686"></p><p>栈stack: 由系统自动分配。 void func() {int a;} 系统自动在栈中为 a 开辟空间</p><p>堆heap: 需要程序员自己申请，并指明大小 (例如 malloc)。</p><h3 id="栈"><a href="#栈" class="headerlink" title="*栈"></a>*栈</h3><p>在IA-32架构下, <strong>栈是连续的内存区域</strong>, 存在于一个栈段内,</p><p>–任意时刻, <strong>ESP</strong>寄存器所包含的栈指针均指向栈顶位置</p><p>–通常由高地址向低地址扩展（PUSH时ESP自减，POP时ESP自增）</p><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="*栈帧"></a>*栈帧</h4><p>将调用函数和被调用函数联系起来的机制, <strong>栈被分割为栈帧,栈帧组成栈</strong>。栈帧的内容包含</p><p>–函数的局部变量</p><p>–向被调用函数传递的参数</p><p>–函数调用的联系信息（栈帧相关的指针: 栈帧基址针,返回指令指针）</p><p>•<strong>栈帧基指针</strong>(在<strong>EBP</strong>中)</p><p>–被调用函数栈帧的固定参考点</p><p><img src="/img/course/image-20231222141420485.png" alt="image-20231222141420485"></p><p>•esp寄存器始终指向栈的顶部。</p><p>•ebp寄存器指向了函数活动记录的一个固定位置</p><h3 id="x86函数调用的步骤"><a href="#x86函数调用的步骤" class="headerlink" title="*x86函数调用的步骤"></a>*x86函数调用的步骤</h3><p>•<strong>参数入栈</strong>：将参数从右向左依次压入系统栈中。</p><p>•<strong>返回地址入栈</strong>：将当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行。</p><p>•<strong>代码区跳转</strong>：处理器从当前代码区跳转到被调用函数的入口处。</p><p>•<strong>栈帧调整</strong>：具体包括。</p><p>–保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP 入栈）</p><p>–将当前栈帧切换到新栈帧（将 ESP 值装入 EBP，更新栈帧底部）</p><p>–给新栈帧分配空间（把 ESP 减去所需空间的大小，抬高栈顶）；</p><h4 id="函数返回的步骤"><a href="#函数返回的步骤" class="headerlink" title="*函数返回的步骤"></a>*函数返回的步骤</h4><p>•<strong>保存返回值</strong>：通常将函数的返回值保存在寄存器 EAX 中</p><p>•<strong>弹出当前栈帧</strong>，恢复上一个栈帧</p><p>–在堆栈平衡的基础上，给 ESP 加上栈帧的大小，降低栈顶，回收当前栈帧的空间</p><p>–将当前栈帧底部保存的前栈帧 EBP 值弹入 EBP 寄存器，恢复出上一个栈帧</p><p>–将函数返回地址弹给 EIP 寄存器。</p><p><strong>跳转</strong>：按照函数返回地址跳回母函数中继续执行</p><p><img src="/img/course/image-20231222142747674.png" alt="image-20231222142747674"></p><h3 id="x64函数调用约定"><a href="#x64函数调用约定" class="headerlink" title="*x64函数调用约定"></a>*x64函数调用约定</h3><p>•x64的多数调用惯例更多地通过<strong>寄存器传递参数</strong></p><p>•Windows x64中, 只有一种调用惯例用到栈,且其中前4个参数通过RCX, RDX, R8, R9 传递</p><p>•Linux x64中, System V AMD64 ABI调用惯例: 前6个参数通过RDI, RSI, RDX, RCX, R8, R9传递</p><p>•相比IA-32, 减小了在栈上存储和查找值的时间, 一些函数根本不需要访问栈</p><table><thead><tr><th></th><th><strong>Cdecl</strong></th><th><strong>Syscall</strong></th><th><strong>StdCall</strong></th></tr></thead><tbody><tr><td>参数入栈顺序</td><td>右-&gt;左</td><td>右-&gt;左</td><td>右-&gt;左</td></tr><tr><td>恢复栈平衡的位置</td><td>母函数</td><td>子函数</td><td>子函数</td></tr></tbody></table><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="*缓冲区溢出"></a>*缓冲区溢出</h3><p>–指<strong>数据写出到为特定数据结构开辟的内存空间的边界之外</strong></p><p>–通常可能发生在缓冲区边界被忽略或没有被检查时</p><p>–缓冲区溢出可被利用于修改</p><p>•<strong>栈上的返回指令指针，函数指针局部变量</strong>. . .</p><p>堆数据结构</p><h3 id="缓冲区溢出原因："><a href="#缓冲区溢出原因：" class="headerlink" title="*缓冲区溢出原因："></a>*缓冲区溢出原因：</h3><ol><li><strong>输入验证不足</strong>：当程序没有对输入进行充分的验证和边界检查时，攻击者可以通过输入超过缓冲区容量的数据来触发溢出。例如，如果程序接受用户输入并将其存储在固定大小的缓冲区中，但没有检查输入的长度，那么当用户输入超过缓冲区容量时，就会发生溢出。</li><li><strong>缓冲区操作错误</strong>：在程序中使用不安全的缓冲区操作函数（如C&#x2F;C++中的<code>strcpy</code>、<code>strcat</code>等）时，如果目标缓冲区的容量不足以存储要复制或连接的数据，就会导致溢出。这些函数没有对目标缓冲区的长度进行检查，容易导致溢出。</li><li><strong>格式化字符串漏洞</strong>：当程序使用格式化字符串函数（如<code>printf</code>、<code>sprintf</code>等）时，如果格式化字符串中包含了过多的参数，而实际提供的参数数量不足，就可能导致溢出。攻击者可以通过精心构造的格式化字符串来修改程序的内存内容，甚至执行恶意代码。</li></ol><h1 id="代码注入攻击与格式化字符串"><a href="#代码注入攻击与格式化字符串" class="headerlink" title="代码注入攻击与格式化字符串"></a>代码注入攻击与格式化字符串</h1><h2 id="代码注入"><a href="#代码注入" class="headerlink" title="*代码注入"></a>*代码注入</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>•将ret设置为被注入代码的起始地址, 被注入代码可以做任何事情,如下载和安装蠕虫</p><p>•攻击者创建一个恶意的参数——一个精巧构造出的字符串,该字符串包含一个指向攻击者恶意代码的指针</p><p>•当被调用函数返回时, 程序控制流交给恶意代码 (shellcode)</p><p>–当函数返回时，被注入的代码以与漏洞程序相同的权限运行</p><p>–以root或其他较高权限运行的程序是攻击目标</p><h4 id="shellcode-概述"><a href="#shellcode-概述" class="headerlink" title="shellcode 概述"></a>shellcode 概述</h4><p>•统一用 shellcode 这个专用术语来通称缓冲区溢出攻击中植入进程的代码</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p><img src="/img/course/image-20231225200313989.png" alt="image-20231225200313989"></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>•分析并调试漏洞程序，获得淹没返回地址的偏移。</p><p>•获得 buf 的起始地址，并将其写入 abc 的相应偏移处，用来冲刷返回地址。</p><p>• 向abc 中写入可执行的机器代码</p><table><thead><tr><th><strong>esp</strong></th><th><strong>？</strong></th><th><strong>buf</strong></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td><strong>?</strong></td><td><strong>old_ebp  (?)</strong></td></tr><tr><td></td><td><strong>?</strong></td><td><strong>ret</strong> <strong>addr</strong></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="使用“跳板”的溢出利用"><a href="#使用“跳板”的溢出利用" class="headerlink" title="*使用“跳板”的溢出利用"></a>*使用“跳板”的溢出利用</h2><p><img src="/img/course/image-20231225200615045.png" alt="image-20231225200615045"></p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>•用内存中任意一个 jmp esp 指令的地址覆盖函数返回地址，而不是原来用手工查出的shellcode (buf) 起始地址直接覆盖。</p><p>•函数返回后被重定向去执行内存中的这条jmp esp指令，而不是直接开始执行shellcode。</p><p>•由于 esp 在函数返回时仍指向栈区（函数返回地址之后），jmp esp 指令被执行后，处理器会到栈区函数返回地址之后的地方取指令执行。</p><p>•重新布置 shellcode。在淹没函数返回地址后，继续淹没一片栈空间。将缓冲区前边一段地方用任意数据填充，把 shellcode 恰好摆放在函数返回地址之后。这样，jmp esp 指令执行过后会恰好跳进 shellcode。</p><h3 id="shellcode-摆放位置"><a href="#shellcode-摆放位置" class="headerlink" title="shellcode 摆放位置"></a>shellcode 摆放位置</h3><p>•直接放在缓冲区 buf[80]里，</p><p>–shellcode 位于函数返回地址之前。</p><p>•使用跳转指令 jmp esp 来定位 shellcode</p><p>–shellcode 恰好在函数返回地址之后</p><table><thead><tr><th></th><th><strong>好处</strong></th><th><strong>坏处</strong></th><th>类型</th></tr></thead><tbody><tr><td>shellcode 位于函数返回地址之前</td><td>对程序破坏小，比较稳定；不会大范围破坏前栈帧</td><td>自身可能被压栈数据破坏</td><td>使用静态地址定位shellcode</td></tr><tr><td>shellcode 位于函数返回地址之后</td><td>不用担心自身被压栈数据破坏</td><td>破坏前栈帧数据</td><td>使用“跳板”的溢出利用</td></tr></tbody></table><h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="*格式化字符串漏洞"></a>*格式化字符串漏洞</h2><h4 id="格式化字符串函数介绍"><a href="#格式化字符串函数介绍" class="headerlink" title="格式化字符串函数介绍"></a>格式化字符串函数介绍</h4><p>格式化字符串函数可以接受<strong>可变数量</strong>的参数，并将<strong>第一个参数</strong>作为<strong>格式化字符串</strong>，根据其来解析之后的参数</p><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th><th><strong>Passed as</strong></th></tr></thead><tbody><tr><td>%d</td><td>十进制</td><td>Value</td></tr><tr><td>%u</td><td>无符号十进制</td><td>Value</td></tr><tr><td>%x</td><td>十六进制</td><td>Value</td></tr><tr><td>%s</td><td>字符串</td><td>Reference</td></tr><tr><td><strong>%n</strong></td><td>将已经输出过的字节数输入到指定的地址中</td><td>Reference</td></tr></tbody></table><h4 id="格式化字符串漏洞的原理"><a href="#格式化字符串漏洞的原理" class="headerlink" title="格式化字符串漏洞的原理"></a>格式化字符串漏洞的原理</h4><p>•对于printf函数，其要打印的内容及格式是由该函数的<strong>第一个参数</strong>确定的。如果第一个参数指定的格式与其后续参数匹配，则不会发生错误。</p><p>•然而如果指定的格式与其后续参数不匹配，则将会输出错误的结果，在某些情况下还会泄露内存变量的值。</p><p>•如果攻击者可以控制输入的字符串(含打印格式)，则有可能利用该漏洞执行shellcode，从而入侵目标系统</p><h3 id="格式化字符串漏洞的利用"><a href="#格式化字符串漏洞的利用" class="headerlink" title="格式化字符串漏洞的利用"></a>格式化字符串漏洞的利用</h3><h4 id="使程序崩溃"><a href="#使程序崩溃" class="headerlink" title="使程序崩溃"></a>使程序崩溃</h4><p>•原理：</p><p>–**%s**将会把栈中的内容作为地址进行解析，读取对应地址的内容。如果栈中内容不是有效地址时，程序将会崩溃</p><h4 id="读取栈上的数据"><a href="#读取栈上的数据" class="headerlink" title="读取栈上的数据"></a>读取栈上的数据</h4><p>•从栈顶开始的第7个(4字节）单元开始保存变量int_input，A、B、C值。</p><p>•想读取某个内存单元的值，可以将int_input设置为内存地址，然后设置第7个格式化参数为%s</p><p>•读取栈顶0xffffcd4c (十进制数为4294954316)中的数据</p><p><img src="/img/course/image-20231225201503800.png" alt="image-20231225201503800"></p><h4 id="修改栈内容"><a href="#修改栈内容" class="headerlink" title="修改栈内容"></a>修改栈内容</h4><p>•格式字符**%n**</p><p>–把栈中的内容当作地址进行解析，并且把已经输出的字符的数量输入到对应的地址中</p><p>–printf(“hello%n”,&amp;i)</p><p>–printf(“%d\n”,i)  —— <strong>输出i的值为5</strong></p><p>•<strong>原理：</strong>将目标地址放入栈之后，利用%m.n的格式，通过设定宽度和精度，控制%n的计数值，计数值就等于目标单元的值</p><h1 id="代码复用攻击"><a href="#代码复用攻击" class="headerlink" title="代码复用攻击"></a>代码复用攻击</h1><h2 id="代码复用攻击的基本概念"><a href="#代码复用攻击的基本概念" class="headerlink" title="*代码复用攻击的基本概念"></a>*代码复用攻击的基本概念</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>•Stack不具有可执行属性？</p><p>–Data Execution Prevention (DEP)</p><p>–无法执行注入的恶意代码（shellcode）</p><p>•可能的解决办法</p><p>–缓冲区溢出</p><p>–覆写返回地址，使其指向某个函数的地址</p><p>–通常为<strong>系统调用的地址</strong></p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>•<strong>攻击者利用程序本身已有的代码片段构造能够被自己利用的代码链</strong></p><h4 id="绕过系统提供的一些安全机制"><a href="#绕过系统提供的一些安全机制" class="headerlink" title="绕过系统提供的一些安全机制"></a>绕过系统提供的一些安全机制</h4><p>–如Windows提供的数据执行保护(Data Execution Prevention, <strong>DEP</strong>)</p><p>–Linux提供的<strong>NX</strong>(Non-eXecute) </p><h2 id="Ret2libc"><a href="#Ret2libc" class="headerlink" title="*Ret2libc"></a>*Ret2libc</h2><p>•<strong>在程序的控制流 （返回地址）被劫持后, 使其跳转到已在被攻击进程的地址空间中存在的代码中 (共享库中的函数中)</strong></p><p>•共享库中有很多可以被攻击者利用的函数</p><p>e.g. system, execve, execl, etc</p><p><img src="/img/course/image-20231225204226156.png" alt="image-20231225204226156"></p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>•在共享库(libc.so)中找到感兴趣的函数的地址</p><p>•在栈上部署该函数的参数</p><p>•利用缓冲区溢出覆写返回地址使其指向该函数的地址</p><p><img src="/img/course/image-20231225204848513.png" alt="image-20231225204848513"></p><h3 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h3><p>1.获取函数system()和exit()的地址</p><p>2.<strong>获取字符串bin&#x2F;sh的地址(难点)</strong></p><p>3.为系统调用system() 创建形参</p><p>4.覆写返回地址</p><h4 id="获取字符串-“-bin-sh”的地址（非重点，了解即可）"><a href="#获取字符串-“-bin-sh”的地址（非重点，了解即可）" class="headerlink" title="获取字符串 “&#x2F;bin&#x2F;sh”的地址（非重点，了解即可）"></a>获取字符串 “&#x2F;bin&#x2F;sh”的地址（非重点，了解即可）</h4><p>•<strong>方法1</strong>：将字符串“&#x2F;bin&#x2F;sh部署在栈中</p><p><img src="/img/course/image-20231225205710891.png" alt="image-20231225205710891"></p><p>•<strong>方法2</strong>：将“&#x2F;bin&#x2F;sh写入环境变量中</p><p><img src="/img/course/image-20231225205949007.png" alt="image-20231225205949007"></p><p>•<strong>方法3</strong>：在共享库libc.so中定位“&#x2F;bin&#x2F;sh”的地址</p><h2 id="Return-oriented-Programming-ROP"><a href="#Return-oriented-Programming-ROP" class="headerlink" title="*Return-oriented Programming (ROP)"></a>*Return-oriented Programming (ROP)</h2><p>•面向返回编程</p><p>•链接代码片段(Gadgets)来执行恶意行为</p><p>•存在于不同的平台</p><p>–X86, ARM, SPARC </p><p>•被证明图灵完备</p><h3 id="Gadget"><a href="#Gadget" class="headerlink" title="Gadget"></a>Gadget</h3><p>•以分支指令结尾的代码片段</p><p>•ret, call <em>, jmp</em></p><p>•<strong>ROP</strong> 攻击：以<strong>ret</strong>指令结尾</p><p>•<strong>指令数较少</strong> <strong>（2-6条指令组成）</strong></p><p>•<strong>Intented 指令序列和 Unintented 指令序列</strong></p><h4 id="Intented-指令序列"><a href="#Intented-指令序列" class="headerlink" title="Intented 指令序列"></a><strong>Intented</strong> 指令序列</h4><p>•正常反汇编得到的代码序列</p><p>•直接以ret指令作为结尾的代码序列</p><p>•主要存在于函数的末尾处</p><h4 id="Unintented-指令序列"><a href="#Unintented-指令序列" class="headerlink" title="Unintented 指令序列"></a><strong>Unintented</strong> 指令序列</h4><p>•不通过正常反汇编得到的以ret指令结尾的指令序列</p><p>–进行反汇编时，向后偏移一个或几个字节对指令进行解析</p><p>•由于CISC支持变长指令</p><p><img src="/img/course/image-20231225213239077.png" alt="image-20231225213239077"></p><h4 id="ROP攻击"><a href="#ROP攻击" class="headerlink" title="ROP攻击"></a>ROP攻击</h4><p>•找到合适的gadgets</p><p>•将gadgets的地址存入栈中</p><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><h2 id="数据执行保护DEP"><a href="#数据执行保护DEP" class="headerlink" title="*数据执行保护DEP"></a>*数据执行保护DEP</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>•很多缓冲区溢出攻击涉及到将机器码复制到目标缓冲区，然后将执行转移到这些缓冲区</p><p>•<strong>阻止在栈&#x2F;堆&#x2F;全局数据区中执行代码</strong>，并假定可执行代码只能在进程地址空间的除这些位置外的其他位置出现</p><p>– 需要从CPU的内存管理单元（MMU）提供支持，将虚拟内存的对应页标记为非执行（向MMU中加入no_x0002_execute位）</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>Linux 关闭DEP</p><p>•-z execstack</p><p>–gcc -z execstack stack.c -o stack-exec</p><h3 id="攻击DEP：代码重用攻击"><a href="#攻击DEP：代码重用攻击" class="headerlink" title="攻击DEP：代码重用攻击"></a>攻击DEP：代码重用攻击</h3><p>•思路: 重用程序本身中的代码</p><p>–不需要注入代码</p><p>•<strong>Ret2Libc</strong>: 用危险的库函数的地址替换返回地址l</p><p>–攻击者构造合适的参数（在栈上，在返回指令指针的上方）</p><p>•在x64架构上，还需要更多的工作：设置参数传递寄存器的值</p><p>–函数返回，库函数得到执行</p><p>•例如：execve(“&#x2F;bin&#x2F;sh”)</p><p>甚至可以链接两个库函数调用</p><p>•在很多攻击中，代码重用攻击用来作为<strong>禁用DEP</strong>的第一步</p><p>–目标是允许对栈内存进行执行</p><p>–有一个系统调用可以更改栈的读&#x2F;写&#x2F;执行属性</p><p>•int mprotect(void *addr, size_t len, int prot);</p><p>– 设置对于起始于addr的内存区域的保护</p><p>–调用此系统调用，允许在栈上的“执行”属性，然后开始执行被注入的代码</p><h2 id="地址空间随机化ASLR"><a href="#地址空间随机化ASLR" class="headerlink" title="*地址空间随机化ASLR"></a>*地址空间随机化ASLR</h2><h3 id="随机化方法分类"><a href="#随机化方法分类" class="headerlink" title="随机化方法分类"></a>随机化方法分类</h3><p>•地址随机化</p><p>•指令随机化</p><p>•数据随机化</p><p>•接口随机化</p><p>•基地址随机化</p><p>–地址空间随机化 （ASLR）</p><p>•相对地址随机化</p><h3 id="地址空间随机化-（ASLR）"><a href="#地址空间随机化-（ASLR）" class="headerlink" title="*地址空间随机化 （ASLR）"></a>*地址空间随机化 （ASLR）</h3><p>•Address Space Layout Randomization</p><p>•将进程的堆、栈、共享库等内存空间基地址进行随机化来增大入侵者预测目的地址的难度，从而降低进程被成功入侵的风险</p><p>–Linux、Windows 等主流操作系统都已经采用该项技术</p><p>•开启 ASLR，在每次程序运行时的时候，装载的可执行文件和共享库都会被映射到虚拟地址空间的<strong>不同基地址处</strong></p><h4 id="攻破ASLR的方法"><a href="#攻破ASLR的方法" class="headerlink" title="攻破ASLR的方法"></a>攻破ASLR的方法</h4><p>•如果随机地址空间很小，可以进行一个<strong>穷举搜索</strong></p><p>–例如，Linux提供16位的随机</p><p>•可以在约200秒以内被穷举搜索攻破</p><p>•ASLR经常被<strong>memory disclosure攻破</strong></p><p>–例如，如果攻击者可以读取指向栈的一个指针值</p><p>•他就可以使用该指针值发现栈在哪里</p><h3 id="相对地址随机化"><a href="#相对地址随机化" class="headerlink" title="*相对地址随机化"></a>*相对地址随机化</h3><table><thead><tr><th><strong>类型</strong></th><th><strong>操作</strong></th></tr></thead><tbody><tr><td>指令级随机化</td><td>等价指令替换；指令重排序；无关指令填充</td></tr><tr><td>基本块级随机化</td><td>基本块重排序；虚假基本块插入；基本块分解</td></tr><tr><td>函数级随机化</td><td>函数参数随机化；栈布局随机化</td></tr><tr><td>程序级随机化</td><td>函数重排序；库函数入口地址随机化；</td></tr></tbody></table><h3 id="指令集随机化"><a href="#指令集随机化" class="headerlink" title="指令集随机化"></a>指令集随机化</h3><p>•为每一个运行的进程创建特有的指令集，使得攻击者注入的代码与现在的指令集不兼容而无法正常运行</p><p>–常在应用程序加载前或加载时对指令进行加密操作，在执行时对指令进行解密操作</p><p>可以有效地抵抗代码注入攻击</p><p>缺点：时间开销大</p><h3 id="数据随机化"><a href="#数据随机化" class="headerlink" title="数据随机化"></a>数据随机化</h3><p>将内存中的指针或非指针数据作为随机化对象，通过随机化变换（加密操作），使得数据在内存中以密文存储，使用时解密数据</p><h3 id="接口随机化"><a href="#接口随机化" class="headerlink" title="接口随机化"></a>接口随机化</h3><p>•将与底层进行交互的接口进行随机化</p><p>–常将系统调用接口的相关信息作为随机化对象</p><p>–系统调用号、系统调用参数</p><h2 id="控制流完整性检测（CFI）"><a href="#控制流完整性检测（CFI）" class="headerlink" title="控制流完整性检测（CFI）"></a>控制流完整性检测（CFI）</h2><p>•判断程序的执行流程是否按照事先得到的控制流图(Control Flow Graph, CFG)进行</p><h3 id="CFI基本思想"><a href="#CFI基本思想" class="headerlink" title="CFI基本思想"></a>CFI基本思想</h3><p>​–限制程序运行中的控制转移，使之始终处于原有的控制流图所限定的范围内。</p><p>​–规定软件执行必须遵循提前确定的控制流图（CFG）的路径。</p><p>•控制流劫持攻击</p><p>​–引进额外的控制流转移</p><p><img src="/img/course/image-20231226113844849.png" alt="image-20231226113844849"></p><h3 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h3><p>–通过分析程序的控制流图，获取间接转移指令（包括间接跳转、间接调用、和函数返回指令）目标的白名单</p><p>–在程序运行过程中，核对间接转移指令的目标是否在白名单中。</p><p>•通过二进制代码重写实现：插桩</p><p>•利用二进制重写技术向软件函数入口及调用返回处分别插入标识符ID和ID_check</p><p>•通过对比ID和ID_check的值是否一致判断软件的函数执行过程是否符合预期，从而判断软件是否被篡改。</p><p><strong>CFI分类</strong></p><table><thead><tr><th>类型</th><th>技术</th><th>简介</th></tr></thead><tbody><tr><td>基于编译器</td><td>Require source code  CFG is more precise  需要源代码CFG更精确</td><td>1.静态分析源代码构建CFG2.编译时，插入CFI 检查3.运行时进行CFI检测</td></tr><tr><td>基于二进制重写</td><td>No source code is needed  CFG is more over-approximated</td><td>•通过静态二进制文件分析构造CFG（不如通过分析源代码获得的CFG准确）</td></tr><tr><td>基于硬件</td><td>Transparent runtime monitoring  透明的运行时监控</td><td>利用CPU提供的分支记录机制记录程序的执行流</td></tr></tbody></table><h3 id="绕过CFI检测"><a href="#绕过CFI检测" class="headerlink" title="绕过CFI检测"></a>绕过CFI检测</h3><p>–由于构造的CFG不是100%准确</p><p>•利用不违反CFG的gadgets进行攻击</p><p>–整个函数作为一个gadget</p><h2 id="预防（防御性编程）"><a href="#预防（防御性编程）" class="headerlink" title="预防（防御性编程）"></a>预防（防御性编程）</h2><p>1.<strong>使用更安全的编程语言</strong></p><p>2.<strong>安全的库libsafe</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>信息安全课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用密码学总结</title>
    <link href="/2023/12/25/%E5%BA%94%E7%94%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/25/%E5%BA%94%E7%94%A8%E5%AF%86%E7%A0%81%E5%AD%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h3 id="密码学发展历史"><a href="#密码学发展历史" class="headerlink" title="密码学发展历史"></a>密码学发展历史</h3><p>古代加密方法（手工阶段） </p><p>古典密码（机械阶段） </p><p>近代密码（计算机阶段)</p><h3 id="网络信息安全的机制和安全服务"><a href="#网络信息安全的机制和安全服务" class="headerlink" title="网络信息安全的机制和安全服务"></a>网络信息安全的机制和安全服务</h3><p><img src="/img/course/image-20231220191629472.png" alt="image-20231220191629472"></p><h3 id="安全攻击的主要形式及分类"><a href="#安全攻击的主要形式及分类" class="headerlink" title="安全攻击的主要形式及分类"></a>安全攻击的主要形式及分类</h3><p><img src="/img/course/image-20231220191743077.png" alt="image-20231220191743077"></p><h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h2 id="密码学相关概念"><a href="#密码学相关概念" class="headerlink" title="密码学相关概念"></a>密码学相关概念</h2><p><strong>密码学</strong> (cryptology) ✓是密码编码学和密码分析学的统称  </p><p><strong>密码编码学</strong>(cryptography) ✓通过变换消息使其保密的科学和艺术 ✓是密码理论的基础，也是保密系统设计的基础 </p><p><strong>密码分析学</strong>(cryptanalysis) ✓在未知密钥的情况下从密文推演出明文或密钥的艺术 </p><p>密码编码学和密码分析学既相互对立，又相互促进和 发展</p><h3 id="密码分析分类：根据密码分析者对明文、密文等信息-掌握的多少"><a href="#密码分析分类：根据密码分析者对明文、密文等信息-掌握的多少" class="headerlink" title="密码分析分类：根据密码分析者对明文、密文等信息 掌握的多少"></a>密码分析分类：根据密码分析者对明文、密文等信息 掌握的多少</h3><p>唯密文攻击 (Ciphertext-only Attack) ：破译者已知：密码算法、待破译的密文</p><p>已知明文攻击 (Known-plaintext Attack) ：破译者已知：密码算法、一定数量的明文-密文对、截获 的待解密的密文</p><p>选择明文攻击 (Chosen-plaintext Attack) ：破译者已知：密码算法、选定的明文和对应的密文</p><p>选择密文攻击 (Chosen-ciphertext Attack) ：破译者已知：密码算法、选定的密文和对应的明文</p><p>选择文本攻击 (Chosen-text Attack)：破译者已知：密码算法、选定的明文和对应的密文、选 定的密文和对应的明文</p><h2 id="密码系统"><a href="#密码系统" class="headerlink" title="密码系统"></a>密码系统</h2><p><strong>密码体制的安全性仅应依赖于对密钥的保密，而不应依 赖于对算法的保密</strong></p><h3 id="密码系统的安全条件"><a href="#密码系统的安全条件" class="headerlink" title="密码系统的安全条件"></a>密码系统的安全条件</h3><p><strong>计算安全性</strong> 指使用目前最好的方法攻破它所需要的计算远远超出攻击 者的计算资源水平，则可以定义这个密码体制是安全的</p><p><strong>可证明安全性</strong> 这种方法是将密码系统的安全性归结为某个经过深入研究 的数学难题，数学难题被证明求解困难。 该方法存在的问题：只说明了安全和另一个问题是相关的 ，并未完全证明问题本身的安全性</p><p><strong>无条件安全性</strong> 假定攻击者拥有无限的计算资源，但仍然无法破译该密码 系统。 除一次一密方案外，无其他的加密方案是无条件安全的。 一次一密方案使用与消息一样长的随机密钥，且密钥使用 永不重复。 但是不实用，因为消息发送者和接受者必须每次安全更新 随机密钥，在当前技术条件下这并不现实</p><p>密码系统用户所能做的全部努力就是满足下面准则中的 一个或两个</p><p>➢ <strong>破译密文的代价超过被加密信息的价值</strong></p><p>➢ <strong>破译密文所花的时间超过信息的有用期</strong></p><h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><h2 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h2><p><strong>对称密码体制 非对称密码体制</strong></p><p><img src="/img/course/image-20231220193216627.png" alt="image-20231220193216627"></p><h1 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h1><h2 id="代替密码"><a href="#代替密码" class="headerlink" title="代替密码"></a>代替密码</h2><p><strong>单表代替密码和多表代替密码。</strong></p><h3 id="单表代替密码"><a href="#单表代替密码" class="headerlink" title="单表代替密码"></a>单表代替密码</h3><h4 id="移位密码"><a href="#移位密码" class="headerlink" title="移位密码"></a>移位密码</h4><p>加密变换，E&#x3D;{E:Z26→Z26, Ek (p) &#x3D; p + k (mod26)| p∈P,  k∈K } </p><p>解密变换，D&#x3D;{D:Z26→Z26, Dk (c) &#x3D; c－k (mod26)| c∈C,  k∈K }</p><h4 id="使用密钥的单表代替密码"><a href="#使用密钥的单表代替密码" class="headerlink" title="使用密钥的单表代替密码"></a>使用密钥的单表代替密码</h4><p>设密钥为：spectacular。 </p><p>明文： ABCDEFGHIJKLMNOPQRSTUVWXYZ </p><p>对应的密文：spectaulrbdfghijkmnoqvwxyz </p><h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><p>仿射密码举例 </p><p>✓ 设明文消息为China，密钥k &#x3D; (k1 , k2 ) &#x3D; (7, 3)，用仿射密 码对其进行加密，然后再进行解密。</p><p>✓ 解答：利用扩展的欧几里德算法可计算出k1 -1 &#x3D; 7-1&#x3D;15  (mod 26)，加密函数为Ek (p) &#x3D; 7× p + 3 (mod 26)，对应 的解密函数为Dk (c) &#x3D; 15 ×(c - 3) (mod 26)&#x3D;15c-19 (mod  26)。</p><h3 id="多表代替密码"><a href="#多表代替密码" class="headerlink" title="多表代替密码"></a>多表代替密码</h3><p>**普莱费尔密码（Playfair Cipher） **</p><p>**维吉尼亚密码（Vigenere Cipher） **</p><p><strong>希尔密码（Hill Cipher）</strong></p><h3 id="换位密码"><a href="#换位密码" class="headerlink" title="换位密码"></a>换位密码</h3><h3 id="密码的破解"><a href="#密码的破解" class="headerlink" title="密码的破解"></a>密码的破解</h3><p>单表代替密码攻击：统计分析攻击</p><p>多表代替密码的破解： Kasiski测试法， 重合指数法</p><h1 id="数学引论"><a href="#数学引论" class="headerlink" title="数学引论"></a>数学引论</h1><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a><strong>欧几里得算法</strong></h3><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a><strong>扩展欧几里得算法</strong></h3><p><strong>费马定理</strong></p><p><img src="/img/course/image-20231220205617568.png" alt="image-20231220205617568"></p><p><strong>欧拉函数</strong></p><hr><p><img src="/img/course/image-20231220210333547.png" alt="image-20231220210333547"></p><p><img src="/img/course/image-20231220210347450.png" alt="image-20231220210347450"></p><p><img src="/img/course/image-20231220210407592.png" alt="image-20231220210407592"></p><p><img src="/img/course/image-20231220210419371.png" alt="image-20231220210419371"></p><p><strong>欧拉定理</strong></p><p><img src="/img/course/image-20231220210512517.png" alt="image-20231220210512517"></p><h1 id="对称密码体制——分组密码"><a href="#对称密码体制——分组密码" class="headerlink" title="对称密码体制——分组密码"></a>对称密码体制——分组密码</h1><p><strong>针对安全性的分组密码设计要求</strong></p><p>✓分组长度足够大</p><p>✓密钥量足够大</p><p>✓密码变换足够复杂</p><p>✓加密和解密运算简单，易于软件和硬件高速实现</p><h3 id="分组密码的操作模式"><a href="#分组密码的操作模式" class="headerlink" title="分组密码的操作模式"></a>分组密码的操作模式</h3><p><img src="/img/course/2111796-20220917142622147-391646435.png" alt="img"></p><h3 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h3><p>1.明文分组64比特，使用的密钥为64位，有效密钥长度 为56位(有8位用于奇偶校验位或者完全随意设置) </p><p>2.DES由初始置换，16轮Feistel变换，逆初始置换组成 </p><p>3.基本运算操作：置换、替换、异或与循环移位</p><p><img src="/img/course/image-20231221160220578.png" alt="image-20231221160220578"></p><p><img src="/img/course/image-20231221160746276.png" alt="image-20231221160746276"></p><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><p>Rijndael算法是一种非Feistel密码结构的对称分组密码 体制，采用代替&#x2F;置换网络 </p><p>轮函数由3个不同的可逆均匀变换组成，称它们为3个 “层”： </p><p>✓线性混合层：确保多轮之上的高度扩散 </p><p>✓非线性层：由16个S盒并置而成，起到混淆的作用 </p><p>✓密钥加层：子密钥异或到中间状态</p><p><strong>AES基本运算</strong> </p><p>✓字节代替SubBytes </p><p>✓列混淆MixColumns </p><p>✓轮密钥加AddRoundKey </p><p>✓行移位ShiftRows</p><h1 id="非对称密码体制"><a href="#非对称密码体制" class="headerlink" title="非对称密码体制"></a>非对称密码体制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="对称密码体制的主要问题"><a href="#对称密码体制的主要问题" class="headerlink" title="对称密码体制的主要问题"></a>对称密码体制的主要问题</h3><p>✓<strong>系统开放性差</strong>，需要可靠的密钥传递渠道 </p><p>✓<strong>密钥管理困难</strong> 任何两个用户间要进行保密通信就需要一个密钥，不同用户 间进行保密通信时必须使用不同的密钥。n个用户需要 C(n,2)&#x3D;n(n-1)&#x2F;2个密钥，当用户量增大时密钥空间急剧增大。 如n&#x3D;100时，C(100,2)&#x3D;4995；n&#x3D;500时，C(500,2)&#x3D;124750 </p><p>✓<strong>陌生人间的保密通信问题</strong> 对称密码体制的密钥分发方法要求密钥共享各方是互相信任 的 </p><p>✓<strong>数字签名问题</strong> 对称密码体制不能实现通信中的抗抵赖需求</p><h3 id="Diffie-Hellman密钥交换算法"><a href="#Diffie-Hellman密钥交换算法" class="headerlink" title="Diffie-Hellman密钥交换算法"></a>Diffie-Hellman密钥交换算法</h3><p>算法的有效性依赖于计算有限域中离散对数的困难性</p><p>中间人攻击</p><p><img src="/img/course/image-20231221154325957.png" alt="image-20231221154325957"></p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>大整数的因子分解困难性</p><p><img src="/img/course/image-20231221154952339.png" alt="image-20231221154952339"></p><p>如何快速计算a m mod n ：快速取模指数算法</p><p>如何检测一个数是素数 ：确定性素数测试算法，概率测试算法</p><p>如何找到足够大的素数p和q：确定性素数测试和概率测试结合</p><h3 id="椭圆曲线密码体制ECC"><a href="#椭圆曲线密码体制ECC" class="headerlink" title="椭圆曲线密码体制ECC"></a>椭圆曲线密码体制ECC</h3><p><strong>ECC的安全性基于椭圆曲线离散对数问题的难解性</strong></p><h4 id="概念与定义"><a href="#概念与定义" class="headerlink" title="概念与定义"></a>概念与定义</h4><p><img src="/img/course/image-20231221162725036.png" alt="image-20231221162725036"></p><p><img src="/img/course/image-20231221163259461.png" alt="image-20231221163259461"></p><h4 id="椭圆曲线的加法规则"><a href="#椭圆曲线的加法规则" class="headerlink" title="椭圆曲线的加法规则"></a>椭圆曲线的加法规则</h4><p><img src="/img/course/image-20231221163350890.png" alt="image-20231221163350890"></p><p><img src="/img/course/image-20231221163406983.png" alt="image-20231221163406983"></p><p><img src="/img/course/image-20231221163535435.png" alt="image-20231221163535435"></p><p><img src="/img/course/image-20231221164247854.png" alt="image-20231221164247854"></p><p><img src="/img/course/image-20231221164430017.png" alt="image-20231221164430017"></p><h1 id="散列函数与消息认证"><a href="#散列函数与消息认证" class="headerlink" title="散列函数与消息认证"></a>散列函数与消息认证</h1><p>基本概念 </p><p>✓<strong>消息认证</strong>用来<strong>抗击主动攻击</strong> </p><p>✓消息认证是一个过程，用于<strong>验证接受消息的真实性</strong>（的 确是由它所声称的实体发来的）和完整性（未被篡改、 插入、删除），同时还用于验证消息的顺序性和时间性 （未重排、重放、延迟） </p><p>✓除此之外，在考虑网络安全时还需考虑业务的<strong>不可否认性</strong>，即防止通信双方中的某一方对所传输消息的否认 </p><p>✓实现消息的<strong>不可否认性</strong>可通过<strong>数字签名</strong> </p><p>✓数字签名也是一种认证技术，也可用于抗击主动攻击</p><p>✓<strong>消息认证机制和数字签名机制</strong>都有一<strong>产生认证符</strong>的基本 功能，这一基本功能又作为认证协议的一个组成部分 </p><p>✓认证符是用于认证消息的数值，它的产生方法又分为消 息认证码（Message Authentication Code，MAC）、哈希 函数（Hash Function）两大类</p><h3 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h3><h4 id="系统实现功能"><a href="#系统实现功能" class="headerlink" title="系统实现功能"></a>系统实现功能</h4><p>➢ 接收方相信发来的消息未被篡改 </p><p>➢ 接收方相信发方不是冒充的<img src="/img/course/image-20231221164819236.png" alt="image-20231221164819236"></p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>✓又称<strong>杂凑函数或散列函数</strong> </p><p>✓哈希函数H可以将任意长度的消息M映射为**较短的、固定长度的一个值H(M)**，作为认证符</p><p>✓称H(M)为哈希值或哈希码或消息摘要</p><h5 id="哈希函数性质"><a href="#哈希函数性质" class="headerlink" title="哈希函数性质"></a>哈希函数性质</h5><p>✓<strong>函数算法H公开</strong> </p><p>✓ <strong>单向性</strong>：已知消息M，H(M)易于计算；但是已知H(M) ，求M计算不可行 </p><p>✓ <strong>弱抗碰撞性</strong>：已知消息M，找一个消息M’ (M’≠ M)，使 得H(M)&#x3D;H(M’)计算不可行 </p><p>✓ <strong>强抗碰撞性</strong>：找出任意两个不同的输入M和M’，使得 H(M)&#x3D;H(M’)计算不可行 </p><p>✓ <strong>雪崩性</strong>：微小修改消息M ，会使H(M)发生巨大变化</p><p><img src="/img/course/image-20231221165601184.png" alt="image-20231221165601184"></p><p><img src="/img/course/image-20231221165609636.png" alt="image-20231221165609636"></p><h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>数字签名是手写签名的一种电子模拟，针对电子文档 的一种签名确认方法</p><p>目的 </p><p>✓用于向接收方或第三方证实消息被信源方签署 </p><p>✓用于存储的数据或程序的完整性证实</p><h3 id="数字签名性质"><a href="#数字签名性质" class="headerlink" title="数字签名性质"></a>数字签名性质</h3><p>✓<strong>精确性</strong>：签名是对文档的一种映射，不同的文档内容所 得到的映射结果是不一样的 </p><p>✓<strong>唯一性</strong>：签名应基于签名者的唯一性特征（如私钥）， 从而确定签名的不<strong>可伪造性和不可否认性</strong> </p><p>✓<strong>时效性</strong>：签名应该具有时间特征，防止签名的重复使用</p><h3 id="数字签名要求"><a href="#数字签名要求" class="headerlink" title="数字签名要求"></a>数字签名要求</h3><p>✓ 接收者能够核实发送者对报文的签名 </p><p>✓ 发送者事后不能抵赖对报文的签名 </p><p>✓ 接收者不能伪造对报文的签名 </p><p>✓ 必须能够认证签名时刻的内容 </p><p>✓ 签名必须能够被第三方验证，以解决争议</p><h3 id="数字签名的产生方式（了解）"><a href="#数字签名的产生方式（了解）" class="headerlink" title="数字签名的产生方式（了解）"></a>数字签名的产生方式（了解）</h3><p><img src="/img/course/image-20231221170702137.png" alt="image-20231221170702137"></p><p><img src="/img/course/image-20231221170710815.png" alt="image-20231221170710815"></p><p><img src="/img/course/image-20231221170718329.png" alt="image-20231221170718329"></p><h4 id="RSA签名"><a href="#RSA签名" class="headerlink" title="RSA签名"></a>RSA签名</h4><p><img src="/img/course/image-20231221170736301.png" alt="image-20231221170736301"></p><h3 id="案例分析（大题）"><a href="#案例分析（大题）" class="headerlink" title="案例分析（大题）"></a>案例分析（大题）</h3><p><img src="/img/course/image-20231221171002379.png" alt="image-20231221171002379"></p><h1 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h1><p><img src="/img/course/image-20231221171158455.png" alt="image-20231221171158455"></p><h3 id="公钥加密体制的密钥管理"><a href="#公钥加密体制的密钥管理" class="headerlink" title="公钥加密体制的密钥管理"></a>公钥加密体制的密钥管理</h3><h4 id="公钥的分配方法——公用目录表"><a href="#公钥的分配方法——公用目录表" class="headerlink" title="公钥的分配方法——公用目录表"></a>公钥的分配方法——公用目录表</h4><p>✓本方案的安全性虽然高于公开发布的安全性，但仍易受 攻击。如果敌手成功地获取管理员的秘密钥，就可伪造 一个公钥目录表，以后既可假冒任一用户又能监听发往 任一用户的消息，且公用目录表还易受到敌手的窜扰</p><h4 id="公钥的分配方法——公钥管理机构"><a href="#公钥的分配方法——公钥管理机构" class="headerlink" title="公钥的分配方法——公钥管理机构"></a>公钥的分配方法——公钥管理机构</h4><p>上述公钥管理机构分配公开钥时也有缺点，由于每一用 户要想和他人联系都需求助于管理机构，所以管理机构 有可能成为系统的瓶颈，而且由管理机构维护的公钥目 录表也易被敌手窜扰</p><h1 id="序列密码"><a href="#序列密码" class="headerlink" title="序列密码"></a>序列密码</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>序列密码，即流密码（Stream Cipher），按位或字节处理</p><h3 id="序列密码与分组密码的区别"><a href="#序列密码与分组密码的区别" class="headerlink" title="序列密码与分组密码的区别"></a>序列密码与分组密码的区别</h3><p>✓序列密码以<strong>一个符号作为基本的处理单元</strong>，而分组密码 以一定大小的分组作为基本的处理单元 </p><p>✓序列密码使用一个随时间变化的简单的加密变换，即<strong>不同时刻所用的密钥不同</strong>，而分组密码在不同时刻所用的 密钥是相同的 </p><h3 id="序列密码分类"><a href="#序列密码分类" class="headerlink" title="序列密码分类"></a>序列密码分类</h3><p>✓分为<strong>同步序列密码</strong>和<strong>自同步序列密码</strong> </p><p>✓在同步序列密码中，<strong>密钥流的产生与明密文消息流相互独立</strong></p><h4 id="同步序列密码"><a href="#同步序列密码" class="headerlink" title="同步序列密码"></a>同步序列密码</h4><p><img src="/img/course/image-20231221171933113.png" alt="image-20231221171933113"></p><h5 id="同步序列密码特点"><a href="#同步序列密码特点" class="headerlink" title="同步序列密码特点"></a><strong>同步序列密码特点</strong></h5><p>✓<strong>无错误传播</strong>，一个传播错误只影响一个符号，不会影响 到后继的符号 ✓同步要求 </p><p>➢ <strong>发送方和接收方必须保持精确的同步</strong>，用同样的密钥并作 用在同样的位置上，接收方才能正确的解密 </p><p>➢ 通信中丢失或增加了一个密文字符，接收方将<strong>一直错误</strong>， 直到重新同步为止，这是同步序列密码的一个主要缺点 </p><p>➢ 但对应的同步序列密码也能够容易<strong>检测插入、删除等主动攻击</strong>。这是因为一旦这种攻击发生，接收方就会出现解码 错误</p><h4 id="自同步序列密码"><a href="#自同步序列密码" class="headerlink" title="自同步序列密码"></a>自同步序列密码</h4><p><img src="/img/course/image-20231221172152791.png" alt="image-20231221172152791"></p><h5 id="自同步序列密码特点"><a href="#自同步序列密码特点" class="headerlink" title="自同步序列密码特点"></a>自同步序列密码特点</h5><p>✓<strong>有限错误传播</strong> </p><p>➢ 设自同步序列密码的密钥序列产生器具有n位存储，则一个 符号的传输错误将影响到后面n符号的解密，但<strong>不影响后面 第n+1个及其以后符号的解密</strong></p><h3 id="密钥流发生器设计准则"><a href="#密钥流发生器设计准则" class="headerlink" title="密钥流发生器设计准则"></a>密钥流发生器设计准则</h3><p>✓密钥量足够大（应不小于128位） </p><p>✓加密序列的周期足够长（一般为2 128或2 256） </p><p>✓密钥流应该尽可能地接近于一个真正的随机数流的特征</p><h3 id="线性反馈移位寄存器（LFSR）可能有大题"><a href="#线性反馈移位寄存器（LFSR）可能有大题" class="headerlink" title="线性反馈移位寄存器（LFSR）可能有大题"></a>线性反馈移位寄存器（LFSR）可能有大题</h3><p>求周期2的n次方减1</p><p><img src="/img/course/image-20231221202311569.png" alt="image-20231221202311569"></p>]]></content>
    
    
    
    <tags>
      
      <tag>信息安全课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手机推荐</title>
    <link href="/2023/12/05/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/"/>
    <url>/2023/12/05/%E6%89%8B%E6%9C%BA%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="荣耀100Pro"><a href="#荣耀100Pro" class="headerlink" title="荣耀100Pro"></a>荣耀100Pro</h2><p><img src="/img/%E8%8D%A3%E8%80%80.webp"></p><h4 id="配置推荐："><a href="#配置推荐：" class="headerlink" title="配置推荐："></a>配置推荐：</h4><p>1.12+2563399￥</p><p>2.16+5123999￥</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>1.更护眼</p><p>2.新款</p><p>3.信号</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>1.没有高端质感</p><p>2.没有防尘防水</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>该有的都有，拍照防抖，性能，信号较前代都有较大提升，但为了和高端拉开差距强行降配。以拍照为宣传点但实际效果堪忧，但硬件还行，<strong>未来可期</strong>。</p><h4 id="购买链接："><a href="#购买链接：" class="headerlink" title="购买链接："></a>购买链接：</h4><p><a href="https://item.m.jd.com/product/100077383114.html?gx=RnAomTM2bDTYnstH_oVxVVHZcratNss&amp;gxd=RnAowTJabjHfzJsSp9AlC6ew0yoe__o&amp;ad_od=share&amp;utm_source=androidapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=CopyURL">荣耀100Pro购买链接</a></p><h2 id="荣耀Magic5Pro"><a href="#荣耀Magic5Pro" class="headerlink" title="荣耀Magic5Pro"></a>荣耀Magic5Pro</h2><p><img src="/img/magic5pro.jpg"></p><h4 id="配置推荐：-1"><a href="#配置推荐：-1" class="headerlink" title="配置推荐："></a>配置推荐：</h4><p>1.12+256（勃朗蓝）4079￥</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><p>1.23年旗舰款，质感在线</p><p>2.信号</p><p>3.防尘防水</p><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>1.电池寿命堪忧</p><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p><strong>高端旗舰</strong>，没什么大问题。但采用的新电池技术似乎寿命一般。</p><h4 id="购买链接：-1"><a href="#购买链接：-1" class="headerlink" title="购买链接："></a>购买链接：</h4><p><a href="https://item.m.jd.com/product/10069754666716.html?gx=RnAomTM2bDTYnstH_oVxVVHZcratNss&amp;gxd=RnAowTJabjHfzJsSp9AlC6ew0yoe__o&amp;ad_od=share&amp;utm_source=androidapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=CopyURL">Magic5Pro购买链接</a></p><h2 id="荣耀Magic5（不太推荐）"><a href="#荣耀Magic5（不太推荐）" class="headerlink" title="荣耀Magic5（不太推荐）"></a>荣耀Magic5（不太推荐）</h2><p><img src="/img/magic5.jpg"></p><h4 id="配置推荐：-2"><a href="#配置推荐：-2" class="headerlink" title="配置推荐："></a>配置推荐：</h4><p>1.8+2563499￥</p><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><p>1.长得和旗舰一样</p><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><p>1.不支持防尘防水</p><p>2.相较于旗舰各方面减配</p><h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><p><strong>比上不足，比下也不足</strong>。</p><h2 id="小米14-（换系统，谨慎选择）"><a href="#小米14-（换系统，谨慎选择）" class="headerlink" title="小米14 （换系统，谨慎选择）"></a>小米14 （换系统，谨慎选择）</h2><p><img src="/img/Xiaomi14.jpg"></p><h4 id="配置推荐：-3"><a href="#配置推荐：-3" class="headerlink" title="配置推荐："></a>配置推荐：</h4><p>1.16+5124599￥</p><p>2.12+2564299￥</p><h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><p>1.性能更强</p><p>2.拍照效果出色，质感独特</p><p>3.高端旗舰的质感，小屏幕手感出色</p><p>4.屏幕，护眼</p><p>5.防尘防水</p><h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><p>1.换系统</p><h4 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h4><p><strong>综合优秀几乎没有缺点的旗舰款</strong>，好评如潮，但换品牌往往需要适应一段时间。</p><h4 id="购买链接：-2"><a href="#购买链接：-2" class="headerlink" title="购买链接："></a>购买链接：</h4><p><a href="https://item.m.jd.com/product/100071377749.html?gx=RnAomTM2bDTYnstH_oVxVVHZcratNss&amp;gxd=RnAowTJabjHfzJsSp9AlC6ew0yoe__o&amp;ad_od=share&amp;utm_source=androidapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=CopyURL">小米14购买链接</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人推荐度：荣耀100Pro &gt; 小米14  &gt;&#x3D; 荣耀Magic5Pro &gt; 荣耀Magic5</p><table><thead><tr><th>主观评分</th><th>荣耀100Pro</th><th>荣耀Magic5Pro</th><th>荣耀Magic5</th><th>小米14</th></tr></thead><tbody><tr><td>性能&#x2F;耐用性</td><td>8</td><td>8</td><td>8</td><td>9</td></tr><tr><td>拍照</td><td>8</td><td>8.5</td><td>7.9</td><td>8.9</td></tr><tr><td>续航</td><td>9</td><td>8</td><td>9</td><td>8</td></tr><tr><td>高端质感</td><td>7</td><td>9</td><td>8.5</td><td>8.9</td></tr><tr><td>屏幕</td><td>9</td><td>8</td><td>8</td><td>9</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器迁移 expoort/import</title>
    <link href="/2023/11/12/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>/2023/11/12/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="export-导出容器"><a href="#export-导出容器" class="headerlink" title="export 导出容器"></a>export 导出容器</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>命令<br>查看当前容器</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span> -a<br></code></pre></td></tr></table></figure><p><img src="/img/%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8.jpg" alt="查看当前容器"></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">docker</span> ex<span class="hljs-keyword">port</span> containerID &gt; filename.tar<br></code></pre></td></tr></table></figure><p>将容器快照导出为本地filename.tar文件</p><h2 id="import-导入容器"><a href="#import-导入容器" class="headerlink" title="import 导入容器"></a>import 导入容器</h2><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p> 从容器快照文件中再导入为镜像</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker import filename.tar - imagename:version<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/11/hello-world/"/>
    <url>/2023/11/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
